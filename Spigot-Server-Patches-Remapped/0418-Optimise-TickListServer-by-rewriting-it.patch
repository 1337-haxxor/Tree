From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Fri, 14 Feb 2020 01:24:39 -0800
Subject: [PATCH] Optimise TickListServer by rewriting it

In my profiling TickListServer showed up as
~10% for saving chunks and ~5% for the scheduling
of items on a server with ~90 players at
view distance = 5. Most of the performance
loss is unneccessary.

TickListServer has numerous performance issues:
 1. Handling scheduled items is O(nlogn)
 2. Getting scheduled items for a chunk is O(n),
    with n being the the number of scheduled items
    for all chunks (hits saving very hard)
 3. Checking if an item is scheduled for the current tick is O(n),
    with n being the number of items scheduled for current tick
 4. Items not in ticking chunks are churned in the scheduler

The biggest issues are 4 & 2.

We solve 1 by splitting up scheduled items into short and long scheduled,
where we expect the vast majority of our entries to be in the short scheduled
set. Handling short scheduled items is O(n) due to how the comparison
process is reduced to mapping. See TickListServerInterval. However,
this isn't memory-efficient - which is why long scheduled exists.
Long scheduled is handled the same as TickListServer.

2 is solved by mapping what entries are in what chunks.

3 is solved by mapping what blocks have what scheduled for them.

4 is solved by moving the items that are not in ticking chunks
into a map of entries for that chunk. Once the chunk is moved
to ticking, the items are re-scheduled.

This patch has also added two flags to debug excessive tick delays:
-Dpaper.ticklist-warn-on-excessive-delay=true (false by default)
and -Dpaper.ticklist-excessive-delay-threshold=ticks which
sets the excessive tick delay to the specified ticks (defaults to
60 * 20 ticks, aka 60 seconds)

diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 0fcabd12408a8209da5cb3332e217f98983aec02..9b1845024d16a7875ba3406da92efb003f58f8cb 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -349,6 +349,13 @@ public class PaperConfig {
         maxBookTotalSizeMultiplier = getDouble("settings.book-size.total-multiplier", maxBookTotalSizeMultiplier);
     }
 
+    public static boolean useOptimizedTickList = true;
+    private static void useOptimizedTickList() {
+        if (config.contains("settings.use-optimized-ticklist")) { // don't add default, hopefully temporary config
+            useOptimizedTickList = config.getBoolean("settings.use-optimized-ticklist");
+        }
+    }
+
     public static boolean asyncChunks = false;
     private static void asyncChunks() {
         ConfigurationSection section;
diff --git a/src/main/java/com/destroystokyo/paper/server/ticklist/PaperTickList.java b/src/main/java/com/destroystokyo/paper/server/ticklist/PaperTickList.java
new file mode 100644
index 0000000000000000000000000000000000000000..898fcadaa1e7bf8e4ba6e828feab1754e6a88414
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/server/ticklist/PaperTickList.java
@@ -0,0 +1,628 @@
+package com.destroystokyo.paper.server.ticklist;
+
+import net.minecraft.block.BlockState;
+import net.minecraft.crash.CrashReport;
+import net.minecraft.crash.CrashReportCategory;
+import net.minecraft.crash.ReportedException;
+import net.minecraft.nbt.ListNBT;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.util.ResourceLocation;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.math.MutableBoundingBox;
+import net.minecraft.world.NextTickListEntry;
+import net.minecraft.world.TickPriority;
+import net.minecraft.world.server.ServerChunkProvider;
+import net.minecraft.world.server.ServerTickList;
+import net.minecraft.world.server.ServerWorld;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Predicate;
+
+public final class PaperTickList<T> extends ServerTickList<T> { // extend to avoid breaking ABI
+
+    // in the order the state is expected to change (mostly)
+    public static final int STATE_UNSCHEDULED    = 1 << 0;
+    public static final int STATE_SCHEDULED      = 1 << 1; // scheduled for some tick
+    public static final int STATE_PENDING_TICK   = 1 << 2; // for this tick
+    public static final int STATE_TICKING        = 1 << 3;
+    public static final int STATE_TICKED         = 1 << 4; // after this, it gets thrown back to unscheduled
+    public static final int STATE_CANCELLED_TICK = 1 << 5; // still gets moved to unscheduled after tick
+
+    private static final int SHORT_SCHEDULE_TICK_THRESHOLD = 20 * 20 + 1; // 20 seconds
+
+    private final ServerWorld world;
+    private final Predicate<T> excludeFromScheduling;
+    private final Function<T, ResourceLocation> getMinecraftKeyFrom;
+    //private final Function<MinecraftKey, T> getObjectFronMinecraftKey;
+    private final Consumer<NextTickListEntry<T>> tickFunction;
+
+    private final co.aikar.timings.Timing timingCleanup; // Paper
+    private final co.aikar.timings.Timing timingTicking; // Paper
+    private final co.aikar.timings.Timing timingFinished;
+
+    // note: remove ops / add ops suck on fastutil, a chained hashtable implementation would work better, but Long...
+    // try to alleviate with a very small load factor
+    private final Long2ObjectOpenHashMap<ArrayList<NextTickListEntry<T>>> entriesByBlock = new Long2ObjectOpenHashMap<>(1024, 0.25f);
+    private final Long2ObjectOpenHashMap<ObjectRBTreeSet<NextTickListEntry<T>>> entriesByChunk = new Long2ObjectOpenHashMap<>(1024, 0.25f);
+    private final Long2ObjectOpenHashMap<ArrayList<NextTickListEntry<T>>> pendingChunkTickLoad = new Long2ObjectOpenHashMap<>(1024, 0.5f);
+
+    // fastutil has O(1) first/last while TreeMap/TreeSet are log(n)
+    private final ObjectRBTreeSet<NextTickListEntry<T>> longScheduled = new ObjectRBTreeSet<>(TickListServerInterval.ENTRY_COMPARATOR);
+
+    private final ArrayDeque<NextTickListEntry<T>> toTickThisTick = new ArrayDeque<>();
+
+    private final TickListServerInterval<T>[] shortScheduled = new TickListServerInterval[SHORT_SCHEDULE_TICK_THRESHOLD];
+    {
+        for (int i = 0, len = this.shortScheduled.length; i < len; ++i) {
+            this.shortScheduled[i] = new TickListServerInterval<>();
+        }
+    }
+    private int shortScheduledIndex;
+
+    private long currentTick;
+
+    private static final boolean WARN_ON_EXCESSIVE_DELAY = Boolean.getBoolean("paper.ticklist-warn-on-excessive-delay");
+    private static final long EXCESSIVE_DELAY_THRESHOLD = Long.getLong("paper.ticklist-excessive-delay-threshold", 60 * 20).longValue(); // 1 min dfl
+
+    // assume index < length
+    private static int getWrappedIndex(final int start, final int length, final int index) {
+        final int next = start + index;
+        return next < length ? next : next - length;
+    }
+
+    private static int getNextIndex(final int curr, final int length) {
+        final int next = curr + 1;
+        return next < length ? next : 0;
+    }
+
+    public PaperTickList(final ServerWorld world, final Predicate<T> excludeFromScheduling, final Function<T, ResourceLocation> getMinecraftKeyFrom,
+                         final Consumer<NextTickListEntry<T>> tickFunction, final String timingsType) {
+        super(world, excludeFromScheduling, getMinecraftKeyFrom, tickFunction, timingsType);
+        this.world = world;
+        this.excludeFromScheduling = excludeFromScheduling;
+        this.getMinecraftKeyFrom = getMinecraftKeyFrom;
+        this.tickFunction = tickFunction;
+        this.timingCleanup = co.aikar.timings.WorldTimingsHandler.getTickList(world, timingsType + " - Cleanup"); // Paper
+        this.timingTicking = co.aikar.timings.WorldTimingsHandler.getTickList(world, timingsType + " - Ticking"); // Paper
+        this.timingFinished = co.aikar.timings.WorldTimingsHandler.getTickList(world, timingsType + " - Finish");
+        this.currentTick = this.world.func_82737_E();
+    }
+
+    private void queueEntryForTick(final NextTickListEntry<T> entry, final ServerChunkProvider chunkProvider) {
+        if (entry.tickState == STATE_SCHEDULED) {
+            if (chunkProvider.isTickingReadyMainThread(entry.getPosition())) {
+                this.toTickThisTick.add(entry);
+                entry.tickState = STATE_PENDING_TICK;
+            } else {
+                // we dump them to a map to avoid constantly re-scheduling them
+                this.addToNotTickingReady(entry);
+            }
+        }
+    }
+
+    private void addToNotTickingReady(final NextTickListEntry<T> entry) {
+        this.pendingChunkTickLoad.computeIfAbsent(MCUtil.getCoordinateKey(entry.getPosition()), (long keyInMap) -> {
+            return new ArrayList<>();
+        }).add(entry);
+    }
+
+    private void addToSchedule(final NextTickListEntry<T> entry) {
+        long delay = entry.getTargetTick() - (this.currentTick + 1);
+        if (delay < SHORT_SCHEDULE_TICK_THRESHOLD) {
+            if (delay < 0) {
+                // longScheduled orders by tick time, short scheduled does not
+                this.longScheduled.add(entry);
+            } else {
+                this.shortScheduled[getWrappedIndex(this.shortScheduledIndex, SHORT_SCHEDULE_TICK_THRESHOLD, (int)delay)].addEntryLast(entry);
+            }
+        } else {
+            this.longScheduled.add(entry);
+        }
+    }
+
+    private void removeEntry(final NextTickListEntry<T> entry) {
+        entry.tickState = STATE_CANCELLED_TICK;
+        // short/long scheduled will skip the entry
+
+        final BlockPos pos = entry.getPosition();
+        final long blockKey = MCUtil.getBlockKey(pos);
+
+        final ArrayList<NextTickListEntry<T>> currentEntries = this.entriesByBlock.get(blockKey);
+
+        if (currentEntries.size() == 1) {
+            // it should contain our entry
+            this.entriesByBlock.remove(blockKey);
+        } else {
+            // it's more likely that this entry is at the start of the list than the end
+            for (int i = 0, len = currentEntries.size(); i < len; ++i) {
+                final NextTickListEntry<T> currentEntry = currentEntries.get(i);
+                if (currentEntry == entry) {
+                    currentEntries.remove(i);
+                    break;
+                }
+            }
+        }
+
+        final long chunkKey = MCUtil.getCoordinateKey(entry.getPosition());
+
+        ObjectRBTreeSet<NextTickListEntry<T>> set = this.entriesByChunk.get(chunkKey);
+
+        set.remove(entry);
+
+        if (set.isEmpty()) {
+            this.entriesByChunk.remove(chunkKey);
+        }
+
+        ArrayList<NextTickListEntry<T>> pendingTickingLoad = this.pendingChunkTickLoad.get(chunkKey);
+
+        if (pendingTickingLoad != null) {
+            for (int i = 0, len = pendingTickingLoad.size(); i < len; ++i) {
+                if (pendingTickingLoad.get(i) == entry) {
+                    pendingTickingLoad.remove(i);
+                    break;
+                }
+            }
+
+            if (pendingTickingLoad.isEmpty()) {
+                this.pendingChunkTickLoad.remove(chunkKey);
+            }
+        }
+
+        long delay = entry.getTargetTick() - (this.currentTick + 1);
+        if (delay >= SHORT_SCHEDULE_TICK_THRESHOLD) {
+            this.longScheduled.remove(entry);
+        }
+    }
+
+    public void onChunkSetTicking(final int chunkX, final int chunkZ) {
+        final ArrayList<NextTickListEntry<T>> pending = this.pendingChunkTickLoad.remove(MCUtil.getCoordinateKey(chunkX, chunkZ));
+        if (pending == null) {
+            return;
+        }
+
+        for (int i = 0, size = pending.size(); i < size; ++i) {
+            final NextTickListEntry<T> entry = pending.get(i);
+            // already in all the relevant reference maps, just need to add to longScheduled or shortScheduled
+            this.addToSchedule(entry);
+        }
+    }
+
+    private void prepare() {
+        final long currentTick = this.currentTick;
+
+        final ServerChunkProvider chunkProvider = this.world.func_72863_F();
+
+        // here we setup what's going to tick
+
+        // we don't remove items from shortScheduled (but do from longScheduled) because they're cleared at the end of
+        // this tick
+        if (this.longScheduled.isEmpty() || this.longScheduled.first().getTargetTick() > currentTick) {
+            // nothing in longScheduled to worry about
+            final TickListServerInterval<T> interval = this.shortScheduled[this.shortScheduledIndex];
+            for (int i = 0, len = interval.byPriority.length; i < len; ++i) {
+                for (final Iterator<NextTickListEntry<T>> iterator = interval.byPriority[i].iterator(); iterator.hasNext();) {
+                    this.queueEntryForTick(iterator.next(), chunkProvider);
+                }
+            }
+        } else {
+            final TickListServerInterval<T> interval = this.shortScheduled[this.shortScheduledIndex];
+
+            // combine interval and longScheduled, keeping order
+            final Comparator<NextTickListEntry<T>> comparator = (Comparator)TickListServerInterval.ENTRY_COMPARATOR;
+            final Iterator<NextTickListEntry<T>> longScheduledIterator = this.longScheduled.iterator();
+            NextTickListEntry<T> longCurrent = longScheduledIterator.next();
+
+            for (int i = 0, len = interval.byPriority.length; i < len; ++i) {
+                for (final Iterator<NextTickListEntry<T>> iterator = interval.byPriority[i].iterator(); iterator.hasNext();) {
+                    final NextTickListEntry<T> shortCurrent = iterator.next();
+                    if (longCurrent != null) {
+                        // drain longCurrent until we can add shortCurrent
+                        while (comparator.compare(longCurrent, shortCurrent) <= 0) {
+                            this.queueEntryForTick(longCurrent, chunkProvider);
+                            longScheduledIterator.remove();
+                            if (longScheduledIterator.hasNext()) {
+                                longCurrent = longScheduledIterator.next();
+                                if (longCurrent.getTargetTick() > currentTick) {
+                                    longCurrent = null;
+                                    break;
+                                }
+                            } else {
+                                longCurrent = null;
+                                break;
+                            }
+                        }
+                    }
+                    this.queueEntryForTick(shortCurrent, chunkProvider);
+                }
+            }
+
+            // add remaining from long scheduled
+            for (;;) {
+                if (longCurrent == null || longCurrent.getTargetTick() > currentTick) {
+                    break;
+                }
+                longScheduledIterator.remove();
+                this.queueEntryForTick(longCurrent, chunkProvider);
+
+                if (longScheduledIterator.hasNext()) {
+                    longCurrent = longScheduledIterator.next();
+                } else {
+                    break;
+                }
+            }
+        }
+    }
+
+    private boolean warnedAboutDesync;
+
+    @Override
+    protected void nextTick() {
+        ++this.currentTick;
+        if (this.currentTick != this.world.func_82737_E()) {
+            if (!this.warnedAboutDesync) {
+                this.warnedAboutDesync = true;
+                MinecraftServer.field_147145_h.error("World tick desync detected! Expected " + this.currentTick + " ticks, but got " + this.world.func_82737_E() + " ticks for world '" + this.world.getWorld().getName() + "'", new Throwable());
+                MinecraftServer.field_147145_h.error("Preventing redstone from breaking by refusing to accept new tick time");
+            }
+        }
+    }
+
+    @Override
+    public void tick() {
+        final ServerChunkProvider chunkProvider = this.world.func_72863_F();
+
+        this.world.func_217381_Z().func_76320_a("cleaning");
+        this.timingCleanup.startTiming();
+
+        this.prepare();
+
+        // this must be done here in case something schedules in the tick code
+        this.shortScheduled[this.shortScheduledIndex].clear();
+        this.shortScheduledIndex = getNextIndex(this.shortScheduledIndex, SHORT_SCHEDULE_TICK_THRESHOLD);
+
+        this.timingCleanup.stopTiming();
+        this.world.func_217381_Z().func_219895_b("ticking");
+        this.timingTicking.startTiming();
+
+        for (final NextTickListEntry<T> toTick : this.toTickThisTick) {
+            if (toTick.tickState != STATE_PENDING_TICK) {
+                // onTickEnd gets called at end of tick
+                continue;
+            }
+            try {
+                if (chunkProvider.isTickingReadyMainThread(toTick.getPosition())) {
+                    toTick.tickState = STATE_TICKING;
+                    this.tickFunction.accept(toTick);
+                    if (toTick.tickState == STATE_TICKING) {
+                        toTick.tickState = STATE_TICKED;
+                    } // else it's STATE_CANCELLED_TICK
+                } else {
+                    // re-schedule eventually
+                    toTick.tickState = STATE_SCHEDULED;
+                    this.addToNotTickingReady(toTick);
+                }
+            } catch (final Throwable thr) {
+                // start copy from TickListServer // TODO check on update
+                CrashReport crashreport = CrashReport.func_85055_a(thr, "Exception while ticking");
+                CrashReportCategory crashreportsystemdetails = crashreport.func_85058_a("Block being ticked");
+
+                CrashReportCategory.func_175750_a(crashreportsystemdetails, toTick.getPosition(), (BlockState) null);
+                throw new ReportedException(crashreport);
+                // end copy from TickListServer
+            }
+        }
+
+        this.timingTicking.stopTiming();
+        this.world.func_217381_Z().func_76319_b();
+        this.timingFinished.startTiming();
+
+        // finished ticking, actual cleanup time
+        for (int i = 0, len = this.toTickThisTick.size(); i < len; ++i) {
+            final NextTickListEntry<T> entry = this.toTickThisTick.poll();
+            if (entry.tickState != STATE_SCHEDULED) {
+                // some entries get re-scheduled due to their chunk not being loaded/at correct status, so do not
+                // call onTickEnd for them
+                this.onTickEnd(entry);
+            }
+        }
+
+        this.timingFinished.stopTiming();
+    }
+
+    private void onTickEnd(final NextTickListEntry<T> entry) {
+        if (entry.tickState == STATE_CANCELLED_TICK) {
+            return;
+        }
+        entry.tickState = STATE_UNSCHEDULED;
+
+        final BlockPos pos = entry.getPosition();
+        final long blockKey = MCUtil.getBlockKey(pos);
+
+        final ArrayList<NextTickListEntry<T>> currentEntries = this.entriesByBlock.get(blockKey);
+
+        if (currentEntries.size() == 1) {
+            // it should contain our entry
+            this.entriesByBlock.remove(blockKey);
+        } else {
+            // it's more likely that this entry is at the start of the list than the end
+            for (int i = 0, len = currentEntries.size(); i < len; ++i) {
+                final NextTickListEntry<T> currentEntry = currentEntries.get(i);
+                if (currentEntry == entry) {
+                    currentEntries.remove(i);
+                    break;
+                }
+            }
+        }
+
+        final long chunkKey = MCUtil.getCoordinateKey(entry.getPosition());
+
+        ObjectRBTreeSet<NextTickListEntry<T>> set = this.entriesByChunk.get(chunkKey);
+
+        set.remove(entry);
+
+        if (set.isEmpty()) {
+            this.entriesByChunk.remove(chunkKey);
+        }
+
+        // already removed from longScheduled or shortScheduled
+    }
+
+    @Override
+    public boolean isPendingTickThisTick(final BlockPos blockposition, final T data) {
+        final ArrayList<NextTickListEntry<T>> entries = this.entriesByBlock.get(MCUtil.getBlockKey(blockposition));
+
+        if (entries == null) {
+            return false;
+        }
+
+        for (int i = 0, size = entries.size(); i < size; ++i) {
+            final NextTickListEntry<T> entry = entries.get(i);
+            if (entry.getData() == data && entry.tickState == STATE_PENDING_TICK) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean isScheduledForTick(final BlockPos blockposition, final T data) {
+        final ArrayList<NextTickListEntry<T>> entries = this.entriesByBlock.get(MCUtil.getBlockKey(blockposition));
+
+        if (entries == null) {
+            return false;
+        }
+
+        for (int i = 0, size = entries.size(); i < size; ++i) {
+            final NextTickListEntry<T> entry = entries.get(i);
+            if (entry.getData() == data && entry.tickState == STATE_SCHEDULED) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public void schedule(BlockPos blockPosition, T t, int i, TickPriority tickListPriority) {
+        this.schedule(blockPosition, t, i + this.currentTick, tickListPriority);
+    }
+
+    public void schedule(final NextTickListEntry<T> entry) {
+        this.schedule(entry.getPosition(), entry.getData(), entry.getTargetTick(), entry.getPriority());
+    }
+
+    public void schedule(final BlockPos pos, final T data, final long targetTick, final TickPriority priority) {
+        final NextTickListEntry<T> entry = new NextTickListEntry<>(pos, data, targetTick, priority);
+        if (this.excludeFromScheduling.test(entry.getData())) {
+            return;
+        }
+
+        if (WARN_ON_EXCESSIVE_DELAY) {
+            final long delay = entry.getTargetTick() - this.currentTick;
+            if (delay >= EXCESSIVE_DELAY_THRESHOLD) {
+                MinecraftServer.field_147145_h.warn("Entry " + entry.toString() + " has been scheduled with an excessive delay of: " + delay, new Throwable());
+            }
+        }
+
+        final long blockKey = MCUtil.getBlockKey(pos);
+
+        final ArrayList<NextTickListEntry<T>> currentEntries = this.entriesByBlock.computeIfAbsent(blockKey, (long keyInMap) -> new ArrayList<>(3));
+
+        if (currentEntries.isEmpty()) {
+            currentEntries.add(entry);
+        } else {
+            for (int i = 0, size = currentEntries.size(); i < size; ++i) {
+                final NextTickListEntry<T> currentEntry = currentEntries.get(i);
+
+                // entries are only blocked from scheduling if currentEntry.equals(toSchedule) && currentEntry is scheduled to tick (NOT including pending)
+                if (currentEntry.getData() == entry.getData() && currentEntry.tickState == STATE_SCHEDULED) {
+                    // can't add
+                    return;
+                }
+            }
+            currentEntries.add(entry);
+        }
+
+        entry.tickState = STATE_SCHEDULED;
+
+        this.entriesByChunk.computeIfAbsent(MCUtil.getCoordinateKey(entry.getPosition()), (final long keyInMap) -> {
+            return new ObjectRBTreeSet<>(TickListServerInterval.ENTRY_COMPARATOR);
+        }).add(entry);
+
+        this.addToSchedule(entry);
+    }
+
+    public void scheduleAll(final Iterator<NextTickListEntry<T>> iterator) {
+        while (iterator.hasNext()) {
+            this.schedule(iterator.next());
+        }
+    }
+
+    // this is not the standard interception calculation, but it's the one vanilla uses
+    // i.e the y value is ignored? the x, z calc isn't correct?
+    // however for the copy op they use the correct intersection, after using this one of course...
+    private static boolean isBlockInSortof(final MutableBoundingBox boundingBox, final BlockPos pos) {
+        return pos.func_177958_n() >= boundingBox.getMinX() && pos.func_177958_n() < boundingBox.getMaxX() && pos.func_177952_p() >= boundingBox.getMinZ() && pos.func_177952_p() < boundingBox.getMaxZ();
+    }
+
+    @Override
+    public List<NextTickListEntry<T>> getEntriesInBoundingBox(final MutableBoundingBox structureboundingbox, final boolean removeReturned, final boolean excludeTicked) {
+        if (structureboundingbox.getMinX() == structureboundingbox.getMaxX() || structureboundingbox.getMinZ() == structureboundingbox.getMaxZ()) {
+            return Collections.emptyList(); // vanilla behaviour, check isBlockInSortof above
+        }
+
+        final int lowerChunkX = structureboundingbox.getMinX() >> 4;
+        final int upperChunkX = (structureboundingbox.getMaxX() - 1) >> 4; // subtract 1 since maxX is exclusive
+        final int lowerChunkZ = structureboundingbox.getMinZ() >> 4;
+        final int upperChunkZ = (structureboundingbox.getMaxZ() - 1) >> 4; // subtract 1 since maxZ is exclusive
+
+        final int xChunksLength = (upperChunkX - lowerChunkX + 1);
+        final int zChunksLength = (upperChunkZ - lowerChunkZ + 1);
+
+        final ObjectRBTreeSet<NextTickListEntry<T>>[] containingChunks = new ObjectRBTreeSet[xChunksLength * zChunksLength];
+
+        final int offset = (xChunksLength * -lowerChunkZ - lowerChunkX);
+        int totalEntries = 0;
+        for (int currChunkX = lowerChunkX; currChunkX <= upperChunkX; ++currChunkX) {
+            for (int currChunkZ = lowerChunkZ; currChunkZ <= upperChunkZ; ++currChunkZ) {
+                // todo optimize
+                //final int index = (currChunkX - lowerChunkX) + xChunksLength * (currChunkZ - lowerChunkZ);
+                final int index = offset + currChunkX + xChunksLength * currChunkZ;
+                final ObjectRBTreeSet<NextTickListEntry<T>> set = containingChunks[index] = this.entriesByChunk.get(MCUtil.getCoordinateKey(currChunkX, currChunkZ));
+                if (set != null) {
+                    totalEntries += set.size();
+                }
+            }
+        }
+
+        final List<NextTickListEntry<T>> ret = new ArrayList<>(totalEntries);
+
+        final int matchOne = (STATE_SCHEDULED | STATE_PENDING_TICK) | (excludeTicked ? 0 : (STATE_TICKING | STATE_TICKED));
+
+        MCUtil.mergeSortedSets((NextTickListEntry<T> entry) -> {
+            if (!isBlockInSortof(structureboundingbox, entry.getPosition())) {
+                return;
+            }
+            final int tickState = entry.tickState;
+            if ((tickState & matchOne) == 0) {
+                return;
+            }
+
+            ret.add(entry);
+            return;
+        }, TickListServerInterval.ENTRY_COMPARATOR, containingChunks);
+
+        if (removeReturned) {
+            for (NextTickListEntry<T> entry : ret) {
+                this.removeEntry(entry);
+            }
+        }
+
+        return ret;
+    }
+
+    @Override
+    public void copy(MutableBoundingBox structureboundingbox, BlockPos blockposition) {
+        // start copy from TickListServer // TODO check on update
+        List<NextTickListEntry<T>> list = this.getEntriesInBoundingBox(structureboundingbox, false, false);
+        Iterator<NextTickListEntry<T>> iterator = list.iterator();
+
+        while (iterator.hasNext()) {
+            NextTickListEntry<T> nextticklistentry = iterator.next();
+
+            if (structureboundingbox.hasPoint( nextticklistentry.getPosition())) {
+                BlockPos blockposition1 = nextticklistentry.getPosition().add(blockposition);
+                T t0 = nextticklistentry.getData();
+
+                this.schedule(new NextTickListEntry<>(blockposition1, t0, nextticklistentry.getTargetTick(), nextticklistentry.getPriority()));
+            }
+        }
+        // end copy from TickListServer
+    }
+
+    @Override
+    public List<NextTickListEntry<T>> getEntriesInChunk(ChunkPos chunkPos, boolean removeReturned, boolean excludeTicked) {
+        // Vanilla DOES get the entries 2 blocks out of the chunk too, but that doesn't matter since we ignore chunks
+        // not at ticking status, and ticking status requires neighbours loaded
+        // so with this method we will reduce scheduler churning
+        final int matchOne = (STATE_SCHEDULED | STATE_PENDING_TICK) | (excludeTicked ? 0 : (STATE_TICKING | STATE_TICKED));
+
+        final ObjectRBTreeSet<NextTickListEntry<T>> entries = this.entriesByChunk.get(MCUtil.getCoordinateKey(chunkPos));
+
+        if (entries == null) {
+            return Collections.emptyList();
+        }
+
+        final List<NextTickListEntry<T>> ret = new ArrayList<>(entries.size());
+
+        for (NextTickListEntry<T> entry : entries) {
+            if ((entry.tickState & matchOne) == 0) {
+                continue;
+            }
+            ret.add(entry);
+        }
+
+        if (removeReturned) {
+            for (NextTickListEntry<T> entry : ret) {
+                this.removeEntry(entry);
+            }
+        }
+
+        return ret;
+    }
+
+    @Override
+    public ListNBT serialize(ChunkPos chunkcoordintpair) {
+        // start copy from TickListServer  // TODO check on update
+        List<NextTickListEntry<T>> list = this.getEntriesInChunk(chunkcoordintpair, false, true);
+
+        return ServerTickList.serialize(this.getMinecraftKeyFrom, list, this.currentTick);
+        // end copy from TickListServer
+    }
+
+    @Override
+    public int getTotalScheduledEntries() {
+        // good thing this is only used in debug reports // TODO check on update
+        int ret = 0;
+
+        for (NextTickListEntry<T> entry : this.longScheduled) {
+            if (entry.tickState == STATE_SCHEDULED) {
+                ++ret;
+            }
+        }
+
+        for (Iterator<Long2ObjectMap.Entry<ArrayList<NextTickListEntry<T>>>> iterator = this.pendingChunkTickLoad.long2ObjectEntrySet().iterator(); iterator.hasNext();) {
+            ArrayList<NextTickListEntry<T>> list = iterator.next().getValue();
+
+            for (NextTickListEntry<T> entry : list) {
+                if (entry.tickState == STATE_SCHEDULED) {
+                    ++ret;
+                }
+            }
+        }
+
+        for (TickListServerInterval<T> interval : this.shortScheduled) {
+            for (Iterable<NextTickListEntry<T>> set : interval.byPriority) {
+                for (NextTickListEntry<T> entry : set) {
+                    if (entry.tickState == STATE_SCHEDULED) {
+                        ++ret;
+                    }
+                }
+            }
+        }
+
+        return ret;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/server/ticklist/TickListServerInterval.java b/src/main/java/com/destroystokyo/paper/server/ticklist/TickListServerInterval.java
new file mode 100644
index 0000000000000000000000000000000000000000..c8598a1b1e04b250843e74c2462f3d58d79dd94c
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/server/ticklist/TickListServerInterval.java
@@ -0,0 +1,41 @@
+package com.destroystokyo.paper.server.ticklist;
+
+import com.destroystokyo.paper.util.set.LinkedSortedSet;
+import java.util.Comparator;
+import net.minecraft.world.NextTickListEntry;
+import net.minecraft.world.TickPriority;
+
+// represents a set of entries to tick at a specified time
+public final class TickListServerInterval<T> {
+
+    public static final int TOTAL_PRIORITIES = TickPriority.values().length;
+    public static final Comparator<NextTickListEntry<?>> ENTRY_COMPARATOR_BY_ID = (entry1, entry2) -> {
+        return Long.compare(entry1.getId(), entry2.getId());
+    };
+    public static final Comparator<NextTickListEntry<?>> ENTRY_COMPARATOR = (Comparator)NextTickListEntry.comparator();
+
+    // we do not record the interval, this class is meant to be used on a ring buffer
+
+    // inlined enum map for TickListPriority
+    public final LinkedSortedSet<NextTickListEntry<T>>[] byPriority = new LinkedSortedSet[TOTAL_PRIORITIES];
+
+    {
+        for (int i = 0, len = this.byPriority.length; i < len; ++i) {
+            this.byPriority[i] = new LinkedSortedSet<>(ENTRY_COMPARATOR_BY_ID);
+        }
+    }
+
+    public void addEntryLast(final NextTickListEntry<T> entry) {
+        this.byPriority[entry.getPriority().ordinal()].addLast(entry);
+    }
+
+    public void addEntryFirst(final NextTickListEntry<T> entry) {
+        this.byPriority[entry.getPriority().ordinal()].addFirst(entry);
+    }
+
+    public void clear() {
+        for (int i = 0, len = this.byPriority.length; i < len; ++i) {
+            this.byPriority[i].clear(); // O(1) clear
+        }
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/set/LinkedSortedSet.java b/src/main/java/com/destroystokyo/paper/util/set/LinkedSortedSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..118988c39e58f28e8a2851792b9c014f341f06fc
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/set/LinkedSortedSet.java
@@ -0,0 +1,142 @@
+package com.destroystokyo.paper.util.set;
+
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+public final class LinkedSortedSet<E> implements Iterable<E> {
+
+    public final Comparator<? super E> comparator;
+
+    protected Link<E> head;
+    protected Link<E> tail;
+
+    public LinkedSortedSet() {
+        this((Comparator)Comparator.naturalOrder());
+    }
+
+    public LinkedSortedSet(final Comparator<? super E> comparator) {
+        this.comparator = comparator;
+    }
+
+    public void clear() {
+        this.head = this.tail = null;
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        return new Iterator<E>() {
+
+            Link<E> next = LinkedSortedSet.this.head;
+
+            @Override
+            public boolean hasNext() {
+                return this.next != null;
+            }
+
+            @Override
+            public E next() {
+                final Link<E> next = this.next;
+                if (next == null) {
+                    throw new NoSuchElementException();
+                }
+                this.next = next.next;
+                return next.element;
+            }
+        };
+    }
+
+    public boolean addLast(final E element) {
+        final Comparator<? super E> comparator = this.comparator;
+
+        Link<E> curr = this.tail;
+        if (curr != null) {
+            int compare;
+
+            while ((compare = comparator.compare(element, curr.element)) < 0) {
+                Link<E> prev = curr;
+                curr = curr.prev;
+                if (curr != null) {
+                    continue;
+                }
+                this.head = prev.prev = new Link<>(element, null, prev);
+                return true;
+            }
+
+            if (compare != 0) {
+                // insert after curr
+                final Link<E> next = curr.next;
+                final Link<E> insert = new Link<>(element, curr, next);
+                curr.next = insert;
+
+                if (next == null) {
+                    this.tail = insert;
+                } else {
+                    next.prev = insert;
+                }
+                return true;
+            }
+
+            return false;
+        } else {
+            this.head = this.tail = new Link<>(element);
+            return true;
+        }
+    }
+
+    public boolean addFirst(final E element) {
+        final Comparator<? super E> comparator = this.comparator;
+
+        Link<E> curr = this.head;
+        if (curr != null) {
+            int compare;
+
+            while ((compare = comparator.compare(element, curr.element)) > 0) {
+                Link<E> prev = curr;
+                curr = curr.next;
+                if (curr != null) {
+                    continue;
+                }
+                this.tail = prev.next = new Link<>(element, prev, null);
+                return true;
+            }
+
+            if (compare != 0) {
+                // insert before curr
+                final Link<E> prev = curr.prev;
+                final Link<E> insert = new Link<>(element, prev, curr);
+                curr.prev = insert;
+
+                if (prev == null) {
+                    this.head = insert;
+                } else {
+                    prev.next = insert;
+                }
+                return true;
+            }
+
+            return false;
+        } else {
+            this.head = this.tail = new Link<>(element);
+            return true;
+        }
+    }
+
+    protected static final class Link<E> {
+        public E element;
+        public Link<E> prev;
+        public Link<E> next;
+
+        public Link() {}
+
+        public Link(final E element) {
+            this.element = element;
+        }
+
+        public Link(final E element, final Link<E> prev, final Link<E> next) {
+            this.element = element;
+            this.prev = prev;
+            this.next = next;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/util/math/BlockPos.java b/src/main/java/net/minecraft/util/math/BlockPos.java
index 1160c741fa63c74ab6143b9d957617df3d9e65bf..aeec4e309bebcf5fa26acd297b2cf9d1d3af0c0b 100644
--- a/src/main/java/net/minecraft/util/math/BlockPos.java
+++ b/src/main/java/net/minecraft/util/math/BlockPos.java
@@ -112,6 +112,7 @@ public class BlockPos extends Vector3i {
         return p_177982_1_ == 0 && p_177982_2_ == 0 && p_177982_3_ == 0 ? this : new BlockPos(this.func_177958_n() + p_177982_1_, this.func_177956_o() + p_177982_2_, this.func_177952_p() + p_177982_3_);
     }
 
+    public final BlockPos add(Vector3i baseblockposition) { return this.func_177971_a(baseblockposition); } // Paper - OBFHELPER
     public BlockPos func_177971_a(Vector3i p_177971_1_) {
         return this.func_177982_a(p_177971_1_.func_177958_n(), p_177971_1_.func_177956_o(), p_177971_1_.func_177952_p());
     }
diff --git a/src/main/java/net/minecraft/util/math/MutableBoundingBox.java b/src/main/java/net/minecraft/util/math/MutableBoundingBox.java
index f641a13572f905a75b40f674dacb393fb7b24a74..5e246ccca4925182771f8b2ee6e15ff30e36d9f1 100644
--- a/src/main/java/net/minecraft/util/math/MutableBoundingBox.java
+++ b/src/main/java/net/minecraft/util/math/MutableBoundingBox.java
@@ -7,12 +7,12 @@ import net.minecraft.util.math.vector.Vector3i;
 
 public class MutableBoundingBox {
 
-    public int field_78897_a;
-    public int field_78895_b;
-    public int field_78896_c;
-    public int field_78893_d;
-    public int field_78894_e;
-    public int field_78892_f;
+    public int field_78897_a; public final int getMinX() { return this.field_78897_a; } // Paper - OBFHELPER
+    public int field_78895_b; public final int getMinY() { return this.field_78895_b; } // Paper - OBFHELPER
+    public int field_78896_c; public final int getMinZ() { return this.field_78896_c; } // Paper - OBFHELPER
+    public int field_78893_d; public final int getMaxX() { return this.field_78893_d; } // Paper - OBFHELPER
+    public int field_78894_e; public final int getMaxY() { return this.field_78894_e; } // Paper - OBFHELPER
+    public int field_78892_f; public final int getMaxZ() { return this.field_78892_f; } // Paper - OBFHELPER
 
     public MutableBoundingBox() {}
 
@@ -91,6 +91,7 @@ public class MutableBoundingBox {
         this.field_78894_e = 512;
     }
 
+    public final boolean intersects(MutableBoundingBox boundingBox) { return this.func_78884_a(boundingBox); } // Paper - OBFHELPER
     public boolean func_78884_a(MutableBoundingBox p_78884_1_) {
         return this.field_78893_d >= p_78884_1_.field_78897_a && this.field_78897_a <= p_78884_1_.field_78893_d && this.field_78892_f >= p_78884_1_.field_78896_c && this.field_78896_c <= p_78884_1_.field_78892_f && this.field_78894_e >= p_78884_1_.field_78895_b && this.field_78895_b <= p_78884_1_.field_78894_e;
     }
@@ -125,6 +126,7 @@ public class MutableBoundingBox {
         this.func_78886_a(p_236989_1_.func_177958_n(), p_236989_1_.func_177956_o(), p_236989_1_.func_177952_p());
     }
 
+    public final boolean hasPoint(Vector3i baseblockposition) { return this.func_175898_b(baseblockposition); } // Paper - OBFHELPER
     public boolean func_175898_b(Vector3i p_175898_1_) {
         return p_175898_1_.func_177958_n() >= this.field_78897_a && p_175898_1_.func_177958_n() <= this.field_78893_d && p_175898_1_.func_177952_p() >= this.field_78896_c && p_175898_1_.func_177952_p() <= this.field_78892_f && p_175898_1_.func_177956_o() >= this.field_78895_b && p_175898_1_.func_177956_o() <= this.field_78894_e;
     }
diff --git a/src/main/java/net/minecraft/world/NextTickListEntry.java b/src/main/java/net/minecraft/world/NextTickListEntry.java
index c08c72c9fb8bb3a1ce1b8fd732ea335ae4f66104..87b7b5424d20e8ff3571e19991b8010924dbcf37 100644
--- a/src/main/java/net/minecraft/world/NextTickListEntry.java
+++ b/src/main/java/net/minecraft/world/NextTickListEntry.java
@@ -6,11 +6,13 @@ import net.minecraft.util.math.BlockPos;
 public class NextTickListEntry<T> {
 
     private static final java.util.concurrent.atomic.AtomicLong COUNTER = new java.util.concurrent.atomic.AtomicLong(); // Paper - async chunk loading
-    private final T field_151352_g;
-    public final BlockPos field_180282_a;
-    public final long field_235017_b_;
-    public final TickPriority field_82754_f;
-    private final long field_77178_g;
+    private final T field_151352_g; public final T getData() { return this.field_151352_g; } // Paper - OBFHELPER
+    public final BlockPos field_180282_a; public final BlockPos getPosition() { return this.field_180282_a; } // Paper - OBFHELPER
+    public final long field_235017_b_; public final long getTargetTick() { return this.field_235017_b_; } // Paper - OBFHELPER
+    public final TickPriority field_82754_f; public final TickPriority getPriority() { return this.field_82754_f; } // Paper - OBFHELPER
+    private final long field_77178_g; public final long getId() { return this.field_77178_g; } // Paper - OBFHELPER
+    private final int hash; // Paper
+    public int tickState; // Paper
 
     public NextTickListEntry(BlockPos blockposition, T t0) {
         this(blockposition, t0, 0L, TickPriority.NORMAL);
@@ -22,6 +24,7 @@ public class NextTickListEntry<T> {
         this.field_151352_g = t0;
         this.field_235017_b_ = i;
         this.field_82754_f = ticklistpriority;
+        this.hash = this.computeHash(); // Paper
     }
 
     public boolean equals(Object object) {
@@ -34,19 +37,31 @@ public class NextTickListEntry<T> {
         }
     }
 
+    // Paper start - optimize hashcode
+    @Override
     public int hashCode() {
+        return this.hash;
+    }
+    public final int computeHash() {
+        // Paper end - optimize hashcode
         return this.field_180282_a.hashCode();
     }
 
-    public static <T> Comparator<Object> func_223192_a() { // Paper - decompile fix
-        return Comparator.comparingLong((nextticklistentry) -> {
-            return ((NextTickListEntry<T>) nextticklistentry).field_235017_b_; // Paper - decompile fix
-        }).thenComparing((nextticklistentry) -> {
-            return ((NextTickListEntry<T>) nextticklistentry).field_82754_f; // Paper - decompile fix
-        }).thenComparingLong((nextticklistentry) -> {
-            return ((NextTickListEntry<T>) nextticklistentry).field_77178_g; // Paper - decompile fix
-        });
+    // Paper start - let's not use more functional code for no reason.
+    public static <T> Comparator<Object> comparator() { return NextTickListEntry.func_223192_a(); } // Paper - OBFHELPER
+    public static <T> Comparator<Object> func_223192_a() {
+        return (Comparator)(Comparator<NextTickListEntry>)(NextTickListEntry nextticklistentry, NextTickListEntry nextticklistentry1) -> {
+            int i = Long.compare(nextticklistentry.getTargetTick(), nextticklistentry1.getTargetTick());
+
+            if (i != 0) {
+                return i;
+            } else {
+                i = nextticklistentry.getPriority().compareTo(nextticklistentry1.getPriority());
+                return i != 0 ? i : Long.compare(nextticklistentry.getId(), nextticklistentry1.getId());
+            }
+        };
     }
+    // Paper end - let's not use more functional code for no reason.
 
     public String toString() {
         return this.field_151352_g + ": " + this.field_180282_a + ", " + this.field_235017_b_ + ", " + this.field_82754_f + ", " + this.field_77178_g;
diff --git a/src/main/java/net/minecraft/world/SerializableTickList.java b/src/main/java/net/minecraft/world/SerializableTickList.java
index f740066b0bf6605c9e78b2a5a4630e24142f16a2..9ac13954fad57e7ba2630e7c2c49143d0cf34d0f 100644
--- a/src/main/java/net/minecraft/world/SerializableTickList.java
+++ b/src/main/java/net/minecraft/world/SerializableTickList.java
@@ -7,6 +7,7 @@ import java.util.function.Function;
 import java.util.stream.Collectors;
 import net.minecraft.nbt.CompoundNBT;
 import net.minecraft.nbt.ListNBT;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.BlockPos;
 
@@ -61,6 +62,8 @@ public class SerializableTickList<T> implements ITickList<T> {
         return nbttaglist;
     }
 
+    private static final int MAX_TICK_DELAY = Integer.getInteger("paper.ticklist-max-tick-delay", -1).intValue(); // Paper - clean up broken entries
+
     public static <T> SerializableTickList<T> func_222984_a(ListNBT p_222984_0_, Function<T, ResourceLocation> p_222984_1_, Function<ResourceLocation, T> p_222984_2_) {
         List<SerializableTickList.TickHolder<T>> list = Lists.newArrayList();
 
@@ -71,7 +74,14 @@ public class SerializableTickList<T> implements ITickList<T> {
             if (t0 != null) {
                 BlockPos blockposition = new BlockPos(nbttagcompound.func_74762_e("x"), nbttagcompound.func_74762_e("y"), nbttagcompound.func_74762_e("z"));
 
-                list.add(new SerializableTickList.TickHolder<>(t0, blockposition, nbttagcompound.func_74762_e("t"), TickPriority.func_205397_a(nbttagcompound.func_74762_e("p"))));
+                // Paper start - clean up broken entries
+                int delay = nbttagcompound.func_74762_e("t");
+                if (MAX_TICK_DELAY > 0 && delay > MAX_TICK_DELAY) {
+                    MinecraftServer.field_147145_h.warn("Dropping tick for pos " + blockposition + ", tick delay " + delay);
+                    continue;
+                }
+                list.add(new SerializableTickList.TickHolder<>(t0, blockposition, delay, TickPriority.func_205397_a(nbttagcompound.func_74762_e("p"))));
+                // Paper end - clean up broken entries
             }
         }
 
diff --git a/src/main/java/net/minecraft/world/server/ChunkHolder.java b/src/main/java/net/minecraft/world/server/ChunkHolder.java
index e53ea8ca75e392808f49832ade42c3eb866c3e3f..2ea31ffb3fba742dbf4a520478de79eddb1eb089 100644
--- a/src/main/java/net/minecraft/world/server/ChunkHolder.java
+++ b/src/main/java/net/minecraft/world/server/ChunkHolder.java
@@ -490,7 +490,9 @@ public class ChunkHolder {
                     ChunkHolder.this.isTickingReady = true;
 
 
-
+                    // Paper start - rewrite ticklistserver
+                    ChunkHolder.this.chunkMap.field_219255_i.onChunkSetTicking(ChunkHolder.this.field_219319_n.field_77276_a, ChunkHolder.this.field_219319_n.field_77275_b);
+                    // Paper end - rewrite ticklistserver
 
                 }
             });
diff --git a/src/main/java/net/minecraft/world/server/ServerChunkProvider.java b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
index d3a77f975c53f0dabe8f4f5aafac8a7452a6301d..5ca1da853d8ddefe6403752ec79ac7d22a1e9984 100644
--- a/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
+++ b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
@@ -232,6 +232,13 @@ public class ServerChunkProvider extends AbstractChunkProvider {
     }
     // Paper end
 
+    // Paper start - rewrite ticklistserver
+    public final boolean isTickingReadyMainThread(BlockPos pos) {
+        ChunkHolder chunk = this.field_217237_a.func_219220_a(MCUtil.getCoordinateKey(pos));
+        return chunk != null && chunk.isTickingReady();
+    }
+    // Paper end - rewrite ticklistserver
+
     public ServerChunkProvider(ServerWorld worldserver, SaveFormat.LevelSave convertable_conversionsession, DataFixer datafixer, TemplateManager definedstructuremanager, Executor executor, ChunkGenerator chunkgenerator, int i, boolean flag, IChunkStatusListener worldloadlistener, Supplier<DimensionSavedDataManager> supplier) {
         this.field_73251_h = worldserver;
         this.field_217243_i = new ServerChunkProvider.ChunkExecutor(worldserver);
diff --git a/src/main/java/net/minecraft/world/server/ServerTickList.java b/src/main/java/net/minecraft/world/server/ServerTickList.java
index 322381cfae6bf098d68914bd9cbf0c306f5ba2ce..a9603974b73c05c225128a528c214c9695f640df 100644
--- a/src/main/java/net/minecraft/world/server/ServerTickList.java
+++ b/src/main/java/net/minecraft/world/server/ServerTickList.java
@@ -52,7 +52,16 @@ public class ServerTickList<T> implements ITickList<T> {
     private final co.aikar.timings.Timing timingTicking; // Paper
     // Paper end
 
+    // Paper start
+    protected void nextTick() {}
+    // Paper end
+
     public void func_205365_a() {
+        // Paper start - allow overriding
+        this.tick();
+    }
+    public void tick() {
+        // Paper end
         int i = this.field_205375_e.size();
 
         if (false) { // CraftBukkit
@@ -120,28 +129,43 @@ public class ServerTickList<T> implements ITickList<T> {
 
     @Override
     public boolean func_205361_b(BlockPos p_205361_1_, T p_205361_2_) {
-        return this.field_205377_g.contains(new NextTickListEntry<>(p_205361_1_, p_205361_2_));
+        // Paper start - allow overriding
+        return this.isPendingTickThisTick(p_205361_1_, p_205361_2_);
+    }
+    public boolean isPendingTickThisTick(BlockPos blockposition, T t0) {
+        // Paper end
+        return this.field_205377_g.contains(new NextTickListEntry<>(blockposition, t0));
     }
 
     public List<NextTickListEntry<T>> func_223188_a(ChunkPos p_223188_1_, boolean p_223188_2_, boolean p_223188_3_) {
-        int i = (p_223188_1_.field_77276_a << 4) - 2;
+        // Paper start - allow overriding
+        return this.getEntriesInChunk(p_223188_1_, p_223188_2_, p_223188_3_);
+    }
+    public List<NextTickListEntry<T>> getEntriesInChunk(ChunkPos chunkcoordintpair, boolean flag, boolean flag1) {
+        // Paper end
+        int i = (chunkcoordintpair.field_77276_a << 4) - 2;
         int j = i + 16 + 2;
-        int k = (p_223188_1_.field_77275_b << 4) - 2;
+        int k = (chunkcoordintpair.field_77275_b << 4) - 2;
         int l = k + 16 + 2;
 
-        return this.func_205366_a(new MutableBoundingBox(i, 0, k, j, 256, l), p_223188_2_, p_223188_3_);
+        return this.func_205366_a(new MutableBoundingBox(i, 0, k, j, 256, l), flag, flag1);
     }
 
     public List<NextTickListEntry<T>> func_205366_a(MutableBoundingBox p_205366_1_, boolean p_205366_2_, boolean p_205366_3_) {
-        List<NextTickListEntry<T>> list = this.func_223187_a((List) null, this.field_205375_e, p_205366_1_, p_205366_2_);
+        // Paper start - allow overriding
+        return this.getEntriesInBoundingBox(p_205366_1_, p_205366_2_, p_205366_3_);
+    }
+    public List<NextTickListEntry<T>> getEntriesInBoundingBox(MutableBoundingBox structureboundingbox, boolean flag, boolean flag1) {
+        // Paper end
+        List<NextTickListEntry<T>> list = this.func_223187_a((List) null, this.field_205375_e, structureboundingbox, flag);
 
-        if (p_205366_2_ && list != null) {
+        if (flag && list != null) {
             this.field_205374_d.removeAll(list);
         }
 
-        list = this.func_223187_a(list, this.field_205377_g, p_205366_1_, p_205366_2_);
-        if (!p_205366_3_) {
-            list = this.func_223187_a(list, this.field_223189_h, p_205366_1_, p_205366_2_);
+        list = this.func_223187_a(list, this.field_205377_g, structureboundingbox, flag);
+        if (!flag1) {
+            list = this.func_223187_a(list, this.field_223189_h, structureboundingbox, flag);
         }
 
         return list == null ? Collections.emptyList() : list;
@@ -172,14 +196,19 @@ public class ServerTickList<T> implements ITickList<T> {
     }
 
     public void func_205368_a(MutableBoundingBox p_205368_1_, BlockPos p_205368_2_) {
-        List<NextTickListEntry<T>> list = this.func_205366_a(p_205368_1_, false, false);
+        // Paper start - allow overriding
+        this.copy(p_205368_1_, p_205368_2_);
+    }
+    public void copy(MutableBoundingBox structureboundingbox, BlockPos blockposition) {
+        // Paper end
+        List<NextTickListEntry<T>> list = this.func_205366_a(structureboundingbox, false, false);
         Iterator iterator = list.iterator();
 
         while (iterator.hasNext()) {
             NextTickListEntry<T> nextticklistentry = (NextTickListEntry) iterator.next();
 
-            if (p_205368_1_.func_175898_b((Vector3i) nextticklistentry.field_180282_a)) {
-                BlockPos blockposition1 = nextticklistentry.field_180282_a.func_177971_a((Vector3i) p_205368_2_);
+            if (structureboundingbox.func_175898_b((Vector3i) nextticklistentry.field_180282_a)) {
+                BlockPos blockposition1 = nextticklistentry.field_180282_a.func_177971_a((Vector3i) blockposition);
                 T t0 = nextticklistentry.func_151351_a();
 
                 this.func_219504_a(new NextTickListEntry<>(blockposition1, t0, nextticklistentry.field_235017_b_, nextticklistentry.field_82754_f));
@@ -189,11 +218,17 @@ public class ServerTickList<T> implements ITickList<T> {
     }
 
     public ListNBT func_219503_a(ChunkPos p_219503_1_) {
-        List<NextTickListEntry<T>> list = this.func_223188_a(p_219503_1_, false, true);
+        // Paper start - allow overriding
+        return this.serialize(p_219503_1_);
+    }
+    public ListNBT serialize(ChunkPos chunkcoordintpair) {
+        // Paper end
+        List<NextTickListEntry<T>> list = this.func_223188_a(chunkcoordintpair, false, true);
 
         return func_219502_a(this.field_205372_b, list, this.field_205376_f.func_82737_E());
     }
 
+    public static <T> ListNBT serialize(Function<T, ResourceLocation> function, Iterable<NextTickListEntry<T>> iterable, long i) { return ServerTickList.func_219502_a(function, iterable, i); } // Paper - OBFHELPER
     private static <T> ListNBT func_219502_a(Function<T, ResourceLocation> p_219502_0_, Iterable<NextTickListEntry<T>> p_219502_1_, long p_219502_2_) {
         ListNBT nbttaglist = new ListNBT();
         Iterator iterator = p_219502_1_.iterator();
@@ -216,13 +251,23 @@ public class ServerTickList<T> implements ITickList<T> {
 
     @Override
     public boolean func_205359_a(BlockPos p_205359_1_, T p_205359_2_) {
-        return this.field_205374_d.contains(new NextTickListEntry<>(p_205359_1_, p_205359_2_));
+        // Paper start - allow overriding
+        return this.isScheduledForTick(p_205359_1_, p_205359_2_);
+    }
+    public boolean isScheduledForTick(BlockPos blockposition, T t0) {
+        // Paper end
+        return this.field_205374_d.contains(new NextTickListEntry<>(blockposition, t0));
     }
 
     @Override
     public void func_205362_a(BlockPos p_205362_1_, T p_205362_2_, int p_205362_3_, TickPriority p_205362_4_) {
-        if (!this.field_205371_a.test(p_205362_2_)) {
-            this.func_219504_a(new NextTickListEntry<>(p_205362_1_, p_205362_2_, (long) p_205362_3_ + this.field_205376_f.func_82737_E(), p_205362_4_));
+        // Paper start - allow overriding
+        this.schedule(p_205362_1_, p_205362_2_, p_205362_3_, p_205362_4_);
+    }
+    public void schedule(BlockPos blockposition, T t0, int i, TickPriority ticklistpriority) {
+        // Paper end
+        if (!this.field_205371_a.test(t0)) {
+            this.func_219504_a(new NextTickListEntry<>(blockposition, t0, (long) i + this.field_205376_f.func_82737_E(), ticklistpriority));
         }
 
     }
@@ -236,6 +281,11 @@ public class ServerTickList<T> implements ITickList<T> {
     }
 
     public int func_225420_a() {
+        // Paper start - allow overriding
+        return this.getTotalScheduledEntries();
+    }
+    public int getTotalScheduledEntries() {
+        // Paper end
         return this.field_205374_d.size();
     }
 }
diff --git a/src/main/java/net/minecraft/world/server/ServerWorld.java b/src/main/java/net/minecraft/world/server/ServerWorld.java
index b95cb446615764a69969208fe5e26160e47424ee..80b931897f46efcbf8b5fd9f85a72be58f2b7317 100644
--- a/src/main/java/net/minecraft/world/server/ServerWorld.java
+++ b/src/main/java/net/minecraft/world/server/ServerWorld.java
@@ -293,6 +293,15 @@ public class ServerWorld extends World implements ISeedReader {
     }
     // Paper end
 
+    // Paper start - rewrite ticklistserver
+    void onChunkSetTicking(int chunkX, int chunkZ) {
+        if (com.destroystokyo.paper.PaperConfig.useOptimizedTickList) {
+            ((com.destroystokyo.paper.server.ticklist.PaperTickList) this.field_94579_S).onChunkSetTicking(chunkX, chunkZ);
+            ((com.destroystokyo.paper.server.ticklist.PaperTickList) this.field_205342_P).onChunkSetTicking(chunkX, chunkZ);
+        }
+    }
+    // Paper end - rewrite ticklistserver
+
     // Add env and gen to constructor, WorldData -> WorldDataServer
     public ServerWorld(MinecraftServer minecraftserver, Executor executor, SaveFormat.LevelSave convertable_conversionsession, IServerWorldInfo iworlddataserver, RegistryKey<World> resourcekey, DimensionType dimensionmanager, IChunkStatusListener worldloadlistener, ChunkGenerator chunkgenerator, boolean flag, long i, List<ISpecialSpawner> list, boolean flag1, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen) {
         super(iworlddataserver, resourcekey, dimensionmanager, minecraftserver::func_213185_aS, false, flag, i, gen, env, executor); // Paper pass executor
@@ -300,12 +309,21 @@ public class ServerWorld extends World implements ISeedReader {
         convertable = convertable_conversionsession;
         uuid = WorldUUID.getUUID(convertable_conversionsession.field_237279_c_.toFile());
         // CraftBukkit end
-        this.field_94579_S = new ServerTickList<>(this, (block) -> {
-            return block == null || block.func_176223_P().func_196958_f();
-        }, Registry.field_212618_g::func_177774_c, this::func_205338_b, "Blocks"); // Paper - Timings
-        this.field_205342_P = new ServerTickList<>(this, (fluidtype) -> {
-            return fluidtype == null || fluidtype == Fluids.field_204541_a;
-        }, Registry.field_212619_h::func_177774_c, this::func_205339_a, "Fluids"); // Paper - Timings
+        if (com.destroystokyo.paper.PaperConfig.useOptimizedTickList) {
+            this.field_94579_S = new com.destroystokyo.paper.server.ticklist.PaperTickList<>(this, (block) -> {
+                return block == null || block.func_176223_P().func_196958_f();
+            }, Registry.field_212618_g::func_177774_c, this::func_205338_b, "Blocks"); // Paper - Timings
+            this.field_205342_P = new com.destroystokyo.paper.server.ticklist.PaperTickList<>(this, (fluidtype) -> {
+                return fluidtype == null || fluidtype == Fluids.field_204541_a;
+            }, Registry.field_212619_h::func_177774_c, this::func_205339_a, "Fluids"); // Paper - Timings
+        } else {
+            this.field_94579_S = new ServerTickList<>(this, (block) -> {
+                return block == null || block.func_176223_P().func_196958_f();
+            }, Registry.field_212618_g::func_177774_c, this::func_205338_b, "Blocks"); // Paper - Timings
+            this.field_205342_P = new ServerTickList<>(this, (fluidtype) -> {
+                return fluidtype == null || fluidtype == Fluids.field_204541_a;
+            }, Registry.field_212619_h::func_177774_c, this::func_205339_a, "Fluids"); // Paper - Timings
+        }
         this.field_217495_I = Sets.newHashSet();
         this.field_147490_S = new ObjectLinkedOpenHashSet();
         this.field_241107_Q_ = flag1;
@@ -638,7 +656,9 @@ public class ServerWorld extends World implements ISeedReader {
         if (this.field_241107_Q_) {
             long i = this.field_72986_A.func_82573_f() + 1L;
 
-            this.field_241103_E_.func_82572_b(i);
+            this.field_241103_E_.func_82572_b(i); // Paper - diff on change, we want the below to be ran right after this
+            this.field_94579_S.nextTick(); // Paper
+            this.field_205342_P.nextTick(); // Paper
             this.field_241103_E_.func_215763_z().func_216331_a(this.field_73061_a, i);
             if (this.field_72986_A.func_82574_x().func_223586_b(GameRules.field_223607_j)) {
                 this.func_241114_a_(this.field_72986_A.func_76073_f() + 1L);
