From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Wed, 8 Apr 2020 03:06:30 -0400
Subject: [PATCH] Optimize PlayerChunkMap memory use for visibleChunks

No longer clones visible chunks which is causing massive memory
allocation issues, likely the source of Humongous Objects on large servers.

Instead we just synchronize, clear and rebuild, reusing the same object buffers
as before with only 2 small objects created (FastIterator/MapEntry)

This should result in siginificant memory use reduction and improved GC behavior.

diff --git a/src/main/java/com/destroystokyo/paper/util/map/Long2ObjectLinkedOpenHashMapFastCopy.java b/src/main/java/com/destroystokyo/paper/util/map/Long2ObjectLinkedOpenHashMapFastCopy.java
new file mode 100644
index 0000000000000000000000000000000000000000..f6ff4d8132a95895680f5bc81f8f873e78f0bbdb
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/map/Long2ObjectLinkedOpenHashMapFastCopy.java
@@ -0,0 +1,39 @@
+package com.destroystokyo.paper.util.map;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
+
+public class Long2ObjectLinkedOpenHashMapFastCopy<V> extends Long2ObjectLinkedOpenHashMap<V> {
+
+    public void copyFrom(Long2ObjectLinkedOpenHashMapFastCopy<V> map) {
+        if (key.length != map.key.length) {
+            key = null;
+            key = new long[map.key.length];
+        }
+        if (value.length != map.value.length) {
+            value = null;
+            //noinspection unchecked
+            value = (V[]) new Object[map.value.length];
+        }
+        if (link.length != map.link.length) {
+            link = null;
+            link = new long[map.link.length];
+        }
+        System.arraycopy(map.key, 0, this.key, 0, map.key.length);
+        System.arraycopy(map.value, 0, this.value, 0, map.value.length);
+        System.arraycopy(map.link, 0, this.link, 0, map.link.length);
+        this.size = map.size;
+        this.mask = map.mask;
+        this.first = map.first;
+        this.last = map.last;
+        this.n = map.n;
+        this.maxFill = map.maxFill;
+        this.containsNullKey = map.containsNullKey;
+    }
+
+    @Override
+    public Long2ObjectLinkedOpenHashMapFastCopy<V> clone() {
+        Long2ObjectLinkedOpenHashMapFastCopy<V> clone = (Long2ObjectLinkedOpenHashMapFastCopy<V>) super.clone();
+        clone.copyFrom(this);
+        return clone;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index c2aa07dc7be1c105bb84720a58b2ec3b8e0780e6..ff8ad0f50a3cf121a3767a1c389fecf7d797953b 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -616,7 +616,7 @@ public final class MCUtil {
 
             ServerWorld world = ((org.bukkit.craftbukkit.CraftWorld)bukkitWorld).getHandle();
             ChunkManager chunkMap = world.func_72863_F().field_217237_a;
-            Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunks = chunkMap.field_219252_f;
+            Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunks = chunkMap.getVisibleChunks();
             TicketManager chunkMapDistance = chunkMap.field_219267_u;
             List<ChunkHolder> allChunks = new ArrayList<>(visibleChunks.values());
             List<ServerPlayerEntity> players = world.field_217491_A;
diff --git a/src/main/java/net/minecraft/world/server/ChunkManager.java b/src/main/java/net/minecraft/world/server/ChunkManager.java
index 891ab06272090bb14fac47500f05c4d55c4c3967..871b91e32060f1b63b3c8476203090f36e2e49f1 100644
--- a/src/main/java/net/minecraft/world/server/ChunkManager.java
+++ b/src/main/java/net/minecraft/world/server/ChunkManager.java
@@ -110,8 +110,33 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
 
     private static final Logger field_219250_d = LogManager.getLogger();
     public static final int field_219249_a = 33 + ChunkStatus.func_222600_b();
-    public final Long2ObjectLinkedOpenHashMap<ChunkHolder> field_219251_e = new Long2ObjectLinkedOpenHashMap();
-    public volatile Long2ObjectLinkedOpenHashMap<ChunkHolder> field_219252_f;
+    // Paper start - faster copying
+    public final Long2ObjectLinkedOpenHashMap<ChunkHolder> field_219251_e = new com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<>(); // Paper - faster copying
+    public final Long2ObjectLinkedOpenHashMap<ChunkHolder> field_219252_f = new net.minecraft.world.server.ChunkManager.ProtectedVisibleChunksMap(); // Paper - faster copying
+
+    private class ProtectedVisibleChunksMap extends com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder> {
+        @Override
+        public ChunkHolder put(long k, ChunkHolder playerChunk) {
+            throw new UnsupportedOperationException("Updating visible Chunks");
+        }
+
+        @Override
+        public ChunkHolder remove(long k) {
+            throw new UnsupportedOperationException("Removing visible Chunks");
+        }
+
+        @Override
+        public ChunkHolder get(long k) {
+            return ChunkManager.this.func_219219_b(k);
+        }
+
+        public ChunkHolder safeGet(long k) {
+            return super.get(k);
+        }
+    }
+    // Paper end
+    public final com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder> pendingVisibleChunks = new com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder>(); // Paper - this is used if the visible chunks is updated while iterating only
+    public transient com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder> visibleChunksClone; // Paper - used for async access of visible chunks, clone and cache only when needed
     private final Long2ObjectLinkedOpenHashMap<ChunkHolder> field_219253_g;
     final LongSet field_219254_h; // Paper - private -> package
     public final ServerWorld field_219255_i;
@@ -184,7 +209,7 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
 
     public ChunkManager(ServerWorld worldserver, SaveFormat.LevelSave convertable_conversionsession, DataFixer datafixer, TemplateManager definedstructuremanager, Executor executor, ThreadTaskExecutor<Runnable> iasynctaskhandler, IChunkLightProvider ilightaccess, ChunkGenerator chunkgenerator, IChunkStatusListener worldloadlistener, Supplier<DimensionSavedDataManager> supplier, int i, boolean flag) {
         super(new File(convertable_conversionsession.func_237291_a_(worldserver.func_234923_W_()), "region"), datafixer, flag);
-        this.field_219252_f = this.field_219251_e.clone();
+        //this.visibleChunks = this.updatingChunks.clone(); // Paper - no more cloning
         this.field_219253_g = new Long2ObjectLinkedOpenHashMap();
         this.field_219254_h = new LongOpenHashSet();
         this.field_219261_o = new LongOpenHashSet();
@@ -276,9 +301,52 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
         return (ChunkHolder) this.field_219251_e.get(p_219220_1_);
     }
 
+    // Paper start - remove cloning of visible chunks unless accessed as a collection async
+    private static final boolean DEBUG_ASYNC_VISIBLE_CHUNKS = Boolean.getBoolean("paper.debug-async-visible-chunks");
+    private boolean isIterating = false;
+    private boolean hasPendingVisibleUpdate = false;
+    public void forEachVisibleChunk(java.util.function.Consumer<ChunkHolder> consumer) {
+        org.spigotmc.AsyncCatcher.catchOp("forEachVisibleChunk");
+        boolean prev = isIterating;
+        isIterating = true;
+        try {
+            for (ChunkHolder value : this.field_219252_f.values()) {
+                consumer.accept(value);
+            }
+        } finally {
+            this.isIterating = prev;
+            if (!this.isIterating && this.hasPendingVisibleUpdate) {
+                ((net.minecraft.world.server.ChunkManager.ProtectedVisibleChunksMap)this.field_219252_f).copyFrom(this.pendingVisibleChunks);
+                this.pendingVisibleChunks.clear();
+                this.hasPendingVisibleUpdate = false;
+            }
+        }
+    }
+    public Long2ObjectLinkedOpenHashMap<ChunkHolder> getVisibleChunks() {
+        if (Thread.currentThread() == this.field_219255_i.field_217407_c) {
+            return this.field_219252_f;
+        } else {
+            synchronized (this.field_219252_f) {
+                if (DEBUG_ASYNC_VISIBLE_CHUNKS) new Throwable("Async getVisibleChunks").printStackTrace();
+                if (this.visibleChunksClone == null) {
+                    this.visibleChunksClone = this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.clone() : ((net.minecraft.world.server.ChunkManager.ProtectedVisibleChunksMap)this.field_219252_f).clone();
+                }
+                return this.visibleChunksClone;
+            }
+        }
+    }
+    // Paper end
+
     @Nullable
     public ChunkHolder func_219219_b(long p_219219_1_) { // Paper - protected -> public
-        return (ChunkHolder) this.field_219252_f.get(p_219219_1_);
+        // Paper start - mt safe get
+        if (Thread.currentThread() != this.field_219255_i.field_217407_c) {
+            synchronized (this.field_219252_f) {
+                return (ChunkHolder) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(p_219219_1_) : ((net.minecraft.world.server.ChunkManager.ProtectedVisibleChunksMap)this.field_219252_f).safeGet(p_219219_1_));
+            }
+        }
+        return (ChunkHolder) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(p_219219_1_) : ((net.minecraft.world.server.ChunkManager.ProtectedVisibleChunksMap)this.field_219252_f).safeGet(p_219219_1_));
+        // Paper end
     }
 
     protected IntSupplier func_219191_c(long p_219191_1_) {
@@ -466,8 +534,9 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
     // Paper end
 
     protected void func_219177_a(boolean p_219177_1_) {
+        Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunks = this.getVisibleChunks(); // Paper remove clone of visible Chunks unless saving off main thread (watchdog kill)
         if (p_219177_1_) {
-            List<ChunkHolder> list = (List) this.field_219252_f.values().stream().filter(ChunkHolder::func_219289_k).peek(ChunkHolder::func_219303_l).collect(Collectors.toList());
+            List<ChunkHolder> list = (List) visibleChunks.values().stream().filter(ChunkHolder::func_219289_k).peek(ChunkHolder::func_219303_l).collect(Collectors.toList()); // Paper - remove cloning of visible chunks
             MutableBoolean mutableboolean = new MutableBoolean();
 
             do {
@@ -495,7 +564,7 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
 //            this.i(); // Paper - nuke IOWorker
             ChunkManager.field_219250_d.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", this.field_219270_x.getName());
         } else {
-            this.field_219252_f.values().stream().filter(ChunkHolder::func_219289_k).forEach((playerchunk) -> {
+            visibleChunks.values().stream().filter(ChunkHolder::func_219289_k).forEach((playerchunk) -> {
                 IChunk ichunkaccess = (IChunk) playerchunk.func_219302_f().getNow(null); // CraftBukkit - decompile error
 
                 if (ichunkaccess instanceof ChunkPrimerWrapper || ichunkaccess instanceof Chunk) {
@@ -666,7 +735,20 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
         if (!this.field_219262_p) {
             return false;
         } else {
-            this.field_219252_f = this.field_219251_e.clone();
+            // Paper start - stop cloning visibleChunks
+            synchronized (this.field_219252_f) {
+                if (isIterating) {
+                    hasPendingVisibleUpdate = true;
+                    this.pendingVisibleChunks.copyFrom((com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder>)this.field_219251_e);
+                } else {
+                    hasPendingVisibleUpdate = false;
+                    this.pendingVisibleChunks.clear();
+                    ((net.minecraft.world.server.ChunkManager.ProtectedVisibleChunksMap)this.field_219252_f).copyFrom((com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<ChunkHolder>)this.field_219251_e);
+                    this.visibleChunksClone = null;
+                }
+            }
+            // Paper end
+
             this.field_219262_p = false;
             return true;
         }
@@ -1137,12 +1219,12 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
     }
 
     protected Iterable<ChunkHolder> func_223491_f() {
-        return Iterables.unmodifiableIterable(this.field_219252_f.values());
+        return Iterables.unmodifiableIterable(this.getVisibleChunks().values()); // Paper
     }
 
     void func_225406_a(Writer p_225406_1_) throws IOException {
         CSVWriter csvwriter = CSVWriter.func_225428_a().func_225423_a("x").func_225423_a("z").func_225423_a("level").func_225423_a("in_memory").func_225423_a("status").func_225423_a("full_status").func_225423_a("accessible_ready").func_225423_a("ticking_ready").func_225423_a("entity_ticking_ready").func_225423_a("ticket").func_225423_a("spawning").func_225423_a("entity_count").func_225423_a("block_entity_count").func_225422_a(p_225406_1_);
-        ObjectBidirectionalIterator objectbidirectionaliterator = this.field_219252_f.long2ObjectEntrySet().iterator();
+        ObjectBidirectionalIterator objectbidirectionaliterator = this.getVisibleChunks().long2ObjectEntrySet().iterator(); // Paper
 
         while (objectbidirectionaliterator.hasNext()) {
             Entry<ChunkHolder> entry = (Entry) objectbidirectionaliterator.next();
diff --git a/src/main/java/net/minecraft/world/server/ServerChunkProvider.java b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
index 5ca1da853d8ddefe6403752ec79ac7d22a1e9984..2fb35ab9c422a5463ba545a41c5780aa88bfbcb3 100644
--- a/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
+++ b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
@@ -786,7 +786,7 @@ public class ServerChunkProvider extends AbstractChunkProvider {
                 entityPlayer.playerNaturallySpawnedEvent.callEvent();
             };
             // Paper end
-            this.field_217237_a.func_223491_f().forEach((playerchunk) -> { // Paper - no... just no...
+            this.field_217237_a.forEachVisibleChunk((playerchunk) -> { // Paper - safe iterator incase chunk loads, also no wrapping
                 Optional<Chunk> optional = ((Either) playerchunk.func_219296_a().getNow(ChunkHolder.field_219308_c)).left();
 
                 if (optional.isPresent()) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 7b1383765ea7588c0cda3825042cc09591ae995c..7285e77b92bfcc5455b1926db47216bafa5dc320 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -60,6 +60,7 @@ import net.minecraft.entity.projectile.SnowballEntity;
 import net.minecraft.network.play.server.SPlaySoundEventPacket;
 import net.minecraft.network.play.server.SPlaySoundPacket;
 import net.minecraft.network.play.server.SUpdateTimePacket;
+import net.minecraft.server.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.Direction;
 import net.minecraft.util.ResourceLocation;
@@ -288,6 +289,7 @@ public class CraftWorld implements World {
         return ret;
     }
     public int getTileEntityCount() {
+        return MCUtil.ensureMain(() -> {
         // We don't use the full world tile entity list, so we must iterate chunks
         Long2ObjectLinkedOpenHashMap<ChunkHolder> chunks = world.func_72863_F().field_217237_a.field_219252_f;
         int size = 0;
@@ -299,11 +301,13 @@ public class CraftWorld implements World {
             size += chunk.field_150816_i.size();
         }
         return size;
+        });
     }
     public int getTickableTileEntityCount() {
         return world.field_175730_i.size();
     }
     public int getChunkCount() {
+        return MCUtil.ensureMain(() -> {
         int ret = 0;
 
         for (ChunkHolder chunkHolder : world.func_72863_F().field_217237_a.field_219252_f.values()) {
@@ -312,7 +316,7 @@ public class CraftWorld implements World {
             }
         }
 
-        return ret;
+        return ret; });
     }
     public int getPlayerCount() {
         return world.field_217491_A.size();
@@ -437,6 +441,14 @@ public class CraftWorld implements World {
 
     @Override
     public Chunk[] getLoadedChunks() {
+        // Paper start
+        if (Thread.currentThread() != world.func_201672_e().field_217407_c) {
+            synchronized (world.func_72863_F().field_217237_a.field_219252_f) {
+                Long2ObjectLinkedOpenHashMap<ChunkHolder> chunks = world.func_72863_F().field_217237_a.field_219252_f;
+                return chunks.values().stream().map(ChunkHolder::getFullChunk).filter(Objects::nonNull).map(net.minecraft.world.chunk.Chunk::getBukkitChunk).toArray(Chunk[]::new);
+            }
+        }
+        // Paper end
         Long2ObjectLinkedOpenHashMap<ChunkHolder> chunks = world.func_72863_F().field_217237_a.field_219252_f;
         return chunks.values().stream().map(ChunkHolder::getFullChunk).filter(Objects::nonNull).map(net.minecraft.world.chunk.Chunk::getBukkitChunk).toArray(Chunk[]::new);
     }
