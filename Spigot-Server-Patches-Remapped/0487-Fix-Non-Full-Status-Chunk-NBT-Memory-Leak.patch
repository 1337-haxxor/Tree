From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sat, 23 May 2020 01:31:06 -0400
Subject: [PATCH] Fix Non Full Status Chunk NBT Memory Leak

Any full status chunk that was requested for any status less than full
would hold onto their entire nbt tree and every variable in that function.

This was due to use of a lambda that persists on the Chunk object
until that chunk reaches FULL status.

With introduction of no tick, we greatly increased the number of non
full chunks so this was really starting to hurt.

We further improve it by making a copy of the nbt tag with only the memory
it needs, so that we dont have to hold a copy to the entire compound.

diff --git a/src/main/java/net/minecraft/world/chunk/storage/ChunkSerializer.java b/src/main/java/net/minecraft/world/chunk/storage/ChunkSerializer.java
index a2b9970b51c6c4535609fbcce1bf1c513471cdaa..cabfff193a4b2778a99e5a0dab2df4106855e46a 100644
--- a/src/main/java/net/minecraft/world/chunk/storage/ChunkSerializer.java
+++ b/src/main/java/net/minecraft/world/chunk/storage/ChunkSerializer.java
@@ -200,15 +200,9 @@ public class ChunkSerializer {
                 object2 = protochunkticklist1;
             }
 
-            object = new Chunk(worldserver.func_201672_e(), chunkcoordintpair, biomestorage, chunkconverter, (ITickList) object1, (ITickList) object2, j, achunksection, (chunk) -> {
-                func_222650_a(nbttagcompound1, chunk);
-                // CraftBukkit start - load chunk persistent data from nbt
-                INBT persistentBase = nbttagcompound1.func_74781_a("ChunkBukkitValues");
-                if (persistentBase instanceof CompoundNBT) {
-                    chunk.persistentDataContainer.putAll((CompoundNBT) persistentBase);
-                }
-                // CraftBukkit end
-            });
+            object = new Chunk(worldserver.func_201672_e(), chunkcoordintpair, biomestorage, chunkconverter, (ITickList) object1, (ITickList) object2, j, achunksection, // Paper start - fix massive nbt memory leak due to lambda. move lambda into a container method to not leak scope. Only clone needed NBT keys.
+                createLoadEntitiesConsumer(new net.minecraft.world.chunk.storage.ChunkSerializer.SafeNBTCopy(nbttagcompound1, "TileEntities", "Entities", "ChunkBukkitValues")) // Paper - move CB Chunk PDC into here
+            );// Paper end
         } else {
             ChunkPrimer protochunk = new ChunkPrimer(chunkcoordintpair, chunkconverter, achunksection, protochunkticklist, protochunkticklist1, worldserver); // Paper - Anti-Xray - Add parameter
 
@@ -314,6 +308,50 @@ public class ChunkSerializer {
             return new InProgressChunkHolder(protochunk1, tasksToExecuteOnMain); // Paper - Async chunk loading
         }
     }
+    // Paper start
+
+    /**
+     * This wrapper will error out if any key is accessed that wasn't copied so we can catch it easy on an update
+     */
+    private static class SafeNBTCopy extends CompoundNBT {
+        private final java.util.Set<String> keys = new java.util.HashSet<String>();
+        public SafeNBTCopy(CompoundNBT base, String... keys) {
+            for (String key : keys) {
+                this.keys.add(key);
+                final INBT nbtBase = base.func_74781_a(key);
+                if (nbtBase != null) {
+                    this.func_218657_a(key, nbtBase);
+                }
+            }
+        }
+
+        @Override
+        public boolean func_74764_b(String p_74764_1_) {
+            if (super.func_74764_b(p_74764_1_)) {
+                return true;
+            } else if (keys.contains(p_74764_1_)) {
+                return false;
+            }
+            throw new IllegalStateException("Missing Key " + p_74764_1_ + " in SafeNBTCopy");
+        }
+
+        @Override
+        public boolean func_150297_b(String p_150297_1_, int p_150297_2_) {
+            return func_74764_b(p_150297_1_) && super.func_150297_b(p_150297_1_, p_150297_2_);
+        }
+    }
+    private static java.util.function.Consumer<Chunk> createLoadEntitiesConsumer(CompoundNBT nbt) {
+        return (chunk) -> {
+            func_222650_a(nbt, chunk);
+            // CraftBukkit start - load chunk persistent data from nbt
+            INBT persistentBase = nbt.func_74781_a("ChunkBukkitValues");
+            if (persistentBase instanceof CompoundNBT) {
+                chunk.persistentDataContainer.putAll((CompoundNBT) persistentBase);
+            }
+            // CraftBukkit end
+        };
+    }
+    // Paper end
 
     // Paper start - async chunk save for unload
     public static final class AsyncSaveData {
