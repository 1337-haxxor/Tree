From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Fri, 19 Jul 2019 03:29:14 -0700
Subject: [PATCH] Reduce sync loads

This reduces calls to getChunkAt which would load chunks.

This patch also adds a tool to find calls which are doing this, however
it must be enabled by setting the startup flag -Dpaper.debug-sync-loads=true

To get a debug log for sync loads, the command is /paper syncloadinfo

diff --git a/src/main/java/com/destroystokyo/paper/PaperCommand.java b/src/main/java/com/destroystokyo/paper/PaperCommand.java
index 6552678d1aa5a1a14dcb2cff09218ebc1b889efe..8613ea299daedc19b0ba9477f120a9ca1ce3cbf7 100644
--- a/src/main/java/com/destroystokyo/paper/PaperCommand.java
+++ b/src/main/java/com/destroystokyo/paper/PaperCommand.java
@@ -1,10 +1,14 @@
 package com.destroystokyo.paper;
 
 import com.destroystokyo.paper.io.chunk.ChunkTaskManager;
+import com.destroystokyo.paper.io.SyncLoadFinder;
 import com.google.common.base.Functions;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import com.google.gson.JsonObject;
+import com.google.gson.internal.Streams;
+import com.google.gson.stream.JsonWriter;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityType;
 import net.minecraft.server.*;
@@ -26,6 +30,9 @@ import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.entity.Player;
 
 import java.io.File;
+import java.io.FileOutputStream;
+import java.io.PrintStream;
+import java.io.StringWriter;
 import java.time.LocalDateTime;
 import java.time.format.DateTimeFormatter;
 import java.util.*;
@@ -36,14 +43,14 @@ public class PaperCommand extends Command {
     public PaperCommand(String name) {
         super(name);
         this.description = "Paper related commands";
-        this.usageMessage = "/paper [heap | entity | reload | version | debug | dumpwaiting | chunkinfo]";
+        this.usageMessage = "/paper [heap | entity | reload | version | debug | dumpwaiting | chunkinfo | syncloadinfo]";
         this.setPermission("bukkit.command.paper");
     }
 
     @Override
     public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
         if (args.length <= 1)
-            return getListMatchingLast(args, "heap", "entity", "reload", "version", "debug", "dumpwaiting", "chunkinfo");
+            return getListMatchingLast(args, "heap", "entity", "reload", "version", "debug", "dumpwaiting", "chunkinfo", "syncloadinfo");
 
         switch (args[0].toLowerCase(Locale.ENGLISH))
         {
@@ -141,6 +148,9 @@ public class PaperCommand extends Command {
             case "chunkinfo":
                 doChunkInfo(sender, args);
                 break;
+            case "syncloadinfo":
+                this.doSyncLoadInfo(sender, args);
+                break;
             case "ver":
             case "version":
                 Command ver = org.bukkit.Bukkit.getServer().getCommandMap().getCommand("version");
@@ -157,6 +167,40 @@ public class PaperCommand extends Command {
         return true;
     }
 
+    private void doSyncLoadInfo(CommandSender sender, String[] args) {
+        if (!SyncLoadFinder.ENABLED) {
+            sender.sendMessage(ChatColor.RED + "This command requires the server startup flag '-Dpaper.debug-sync-loads=true' to be set.");
+            return;
+        }
+        File file = new File(new File(new File("."), "debug"),
+            "sync-load-info" + DateTimeFormatter.ofPattern("yyyy-MM-dd_HH.mm.ss").format(LocalDateTime.now()) + ".txt");
+        file.getParentFile().mkdirs();
+        sender.sendMessage(ChatColor.GREEN + "Writing sync load info to " + file.toString());
+
+
+        try {
+            final JsonObject data = SyncLoadFinder.serialize();
+
+            StringWriter stringWriter = new StringWriter();
+            JsonWriter jsonWriter = new JsonWriter(stringWriter);
+            jsonWriter.setIndent(" ");
+            jsonWriter.setLenient(false);
+            Streams.write(data, jsonWriter);
+
+            String fileData = stringWriter.toString();
+
+            try (
+                PrintStream out = new PrintStream(new FileOutputStream(file), false, "UTF-8")
+            ) {
+                out.print(fileData);
+            }
+            sender.sendMessage(ChatColor.GREEN + "Successfully written sync load information!");
+        } catch (Throwable thr) {
+            sender.sendMessage(ChatColor.RED + "Failed to write sync load information");
+            thr.printStackTrace();
+        }
+    }
+
     private void doChunkInfo(CommandSender sender, String[] args) {
         List<org.bukkit.World> worlds;
         if (args.length < 2 || args[1].equals("*")) {
diff --git a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
index 0edefd6322b57efa2efca28d5009f5d89c6f0e40..404d14c9dfc8589284b5865320b20ec9416cbda2 100644
--- a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
+++ b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
@@ -6,7 +6,7 @@ import net.minecraft.util.math.ChunkPos;
 import net.minecraft.world.chunk.storage.RegionFile;
 import net.minecraft.world.server.ServerWorld;
 import org.apache.logging.log4j.Logger;
-import com.destroystokyo.paper.io.PaperFileIOThread.GeneralTask;
+
 import java.io.IOException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
diff --git a/src/main/java/com/destroystokyo/paper/io/SyncLoadFinder.java b/src/main/java/com/destroystokyo/paper/io/SyncLoadFinder.java
new file mode 100644
index 0000000000000000000000000000000000000000..9e04d917a4b9f5d75a1ae5d467dfdf15e17f2b3b
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/io/SyncLoadFinder.java
@@ -0,0 +1,172 @@
+package com.destroystokyo.paper.io;
+
+import com.destroystokyo.paper.io.SyncLoadFinder.ThrowableWithEquals;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.mojang.datafixers.util.Pair;
+import it.unimi.dsi.fastutil.longs.Long2IntMap;
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.WeakHashMap;
+import net.minecraft.world.World;
+
+public class SyncLoadFinder {
+
+    public static final boolean ENABLED = Boolean.getBoolean("paper.debug-sync-loads");
+
+    private static final WeakHashMap<World, Object2ObjectOpenHashMap<ThrowableWithEquals, SyncLoadInformation>> SYNC_LOADS = new WeakHashMap<>();
+
+    private static final class SyncLoadInformation {
+
+        public int times;
+
+        public final Long2IntOpenHashMap coordinateTimes = new Long2IntOpenHashMap();
+    }
+
+    public static void logSyncLoad(final World world, final int chunkX, final int chunkZ) {
+        if (!ENABLED) {
+            return;
+        }
+
+        final ThrowableWithEquals stacktrace = new ThrowableWithEquals(Thread.currentThread().getStackTrace());
+
+        SYNC_LOADS.compute(world, (final World keyInMap, Object2ObjectOpenHashMap<ThrowableWithEquals, SyncLoadInformation> map) -> {
+            if (map == null) {
+                map = new Object2ObjectOpenHashMap<>();
+            }
+
+            map.compute(stacktrace, (ThrowableWithEquals keyInMap0, SyncLoadInformation valueInMap) -> {
+                if (valueInMap == null) {
+                    valueInMap = new SyncLoadInformation();
+                }
+
+                ++valueInMap.times;
+
+                valueInMap.coordinateTimes.compute(IOUtil.getCoordinateKey(chunkX, chunkZ), (Long keyInMap1, Integer valueInMap1) -> {
+                    return valueInMap1 == null ? Integer.valueOf(1) : Integer.valueOf(valueInMap1.intValue() + 1);
+                });
+
+                return valueInMap;
+            });
+
+            return map;
+        });
+    }
+
+    public static JsonObject serialize() {
+        final JsonObject ret = new JsonObject();
+
+        final JsonArray worldsData = new JsonArray();
+
+        for (final Map.Entry<World, Object2ObjectOpenHashMap<ThrowableWithEquals, SyncLoadInformation>> entry : SYNC_LOADS.entrySet()) {
+            final World world = entry.getKey();
+
+            final JsonObject worldData = new JsonObject();
+
+            worldData.addProperty("name", world.getWorld().getName());
+
+            final List<Pair<ThrowableWithEquals, SyncLoadInformation>> data = new ArrayList<>();
+
+            entry.getValue().forEach((ThrowableWithEquals stacktrace, SyncLoadInformation times) -> {
+                data.add(new Pair<>(stacktrace, times));
+            });
+
+            data.sort((Pair<ThrowableWithEquals, SyncLoadInformation> pair1, Pair<ThrowableWithEquals, SyncLoadInformation> pair2) -> {
+                return Integer.compare(pair2.getSecond().times, pair1.getSecond().times); // reverse order
+            });
+
+            final JsonArray stacktraces = new JsonArray();
+
+            for (Pair<ThrowableWithEquals, SyncLoadInformation> pair : data) {
+                final JsonObject stacktrace = new JsonObject();
+
+                stacktrace.addProperty("times", pair.getSecond().times);
+
+                final JsonArray traces = new JsonArray();
+
+                for (StackTraceElement element : pair.getFirst().stacktrace) {
+                    traces.add(String.valueOf(element));
+                }
+
+                stacktrace.add("stacktrace", traces);
+
+                final JsonArray coordinates = new JsonArray();
+
+                for (Long2IntMap.Entry coordinate : pair.getSecond().coordinateTimes.long2IntEntrySet()) {
+                    final long key = coordinate.getLongKey();
+                    final int times = coordinate.getIntValue();
+                    coordinates.add("(" + IOUtil.getCoordinateX(key) + "," + IOUtil.getCoordinateZ(key) + "): " + times);
+                }
+
+                stacktrace.add("coordinates", coordinates);
+
+                stacktraces.add(stacktrace);
+            }
+
+
+            worldData.add("stacktraces", stacktraces);
+            worldsData.add(worldData);
+        }
+
+        ret.add("worlds", worldsData);
+
+        return ret;
+    }
+
+    static final class ThrowableWithEquals {
+
+        private final StackTraceElement[] stacktrace;
+        private final int hash;
+
+        public ThrowableWithEquals(final StackTraceElement[] stacktrace) {
+            this.stacktrace = stacktrace;
+            this.hash = ThrowableWithEquals.hash(stacktrace);
+        }
+
+        public static int hash(final StackTraceElement[] stacktrace) {
+            int hash = 0;
+
+            for (int i = 0; i < stacktrace.length; ++i) {
+                hash *= 31;
+                hash += stacktrace[i].hashCode();
+            }
+
+            return hash;
+        }
+
+        @Override
+        public int hashCode() {
+            return this.hash;
+        }
+
+        @Override
+        public boolean equals(final Object obj) {
+            if (obj == null || obj.getClass() != this.getClass()) {
+                return false;
+            }
+
+            final ThrowableWithEquals other = (ThrowableWithEquals)obj;
+            final StackTraceElement[] otherStackTrace = other.stacktrace;
+
+            if (this.stacktrace.length != otherStackTrace.length || this.hash != other.hash) {
+                return false;
+            }
+
+            if (this == obj) {
+                return true;
+            }
+
+            for (int i = 0; i < this.stacktrace.length; ++i) {
+                if (!this.stacktrace[i].equals(otherStackTrace[i])) {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java b/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java
index 1cada9377a55b9e1d8bf70ade3396c4c2dadce62..e51104e65a07b6ea7bbbcbb6afb066ef6401cc5b 100644
--- a/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java
+++ b/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java
@@ -1,6 +1,5 @@
 package com.destroystokyo.paper.util.misc;
 
-import com.destroystokyo.paper.util.misc.PooledLinkedHashSets.RawSetObjectLinkedOpenHashSet;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import java.lang.ref.WeakReference;
diff --git a/src/main/java/net/minecraft/block/ChestBlock.java b/src/main/java/net/minecraft/block/ChestBlock.java
index 52ffd52a74c5fdcb29c290c8fa45d2df3e4681c2..acb04bba64952a91533e1c88a8ced5dbd35ffb0e 100644
--- a/src/main/java/net/minecraft/block/ChestBlock.java
+++ b/src/main/java/net/minecraft/block/ChestBlock.java
@@ -80,7 +80,7 @@ public class ChestBlock extends AbstractChestBlock<ChestTileEntity> implements I
         public Optional<INamedContainerProvider> func_225539_a_(final ChestTileEntity p_225539_1_, final ChestTileEntity p_225539_2_) {
             final DoubleSidedInventory inventorylargechest = new DoubleSidedInventory(p_225539_1_, p_225539_2_);
 
-            return Optional.of(new net.minecraft.block.ChestBlock.DoubleInventory(p_225539_1_, p_225539_2_, inventorylargechest)); // CraftBukkit
+            return Optional.of(new DoubleInventory(p_225539_1_, p_225539_2_, inventorylargechest)); // CraftBukkit
         }
 
         public Optional<INamedContainerProvider> func_225538_a_(ChestTileEntity p_225538_1_) {
diff --git a/src/main/java/net/minecraft/entity/LivingEntity.java b/src/main/java/net/minecraft/entity/LivingEntity.java
index b71e5940fbeac245c96d51ff909b3a662c4914c0..1d7a5b8a33b9dcee97ec84b3ad01fba95238dedf 100644
--- a/src/main/java/net/minecraft/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/entity/LivingEntity.java
@@ -774,7 +774,7 @@ public abstract class LivingEntity extends Entity {
 
     // CraftBukkit start
     private boolean isTickingEffects = false;
-    private List<net.minecraft.entity.LivingEntity.ProcessableEffect> effectsToProcess = Lists.newArrayList();
+    private List<ProcessableEffect> effectsToProcess = Lists.newArrayList();
 
     private static class ProcessableEffect {
 
@@ -825,7 +825,7 @@ public abstract class LivingEntity extends Entity {
         }
         // CraftBukkit start
         isTickingEffects = false;
-        for (net.minecraft.entity.LivingEntity.ProcessableEffect e : effectsToProcess) {
+        for (ProcessableEffect e : effectsToProcess) {
             if (e.effect != null) {
                 addEffect(e.effect, e.cause);
             } else {
@@ -998,7 +998,7 @@ public abstract class LivingEntity extends Entity {
     public boolean addEffect(EffectInstance mobeffect, EntityPotionEffectEvent.Cause cause) {
         org.spigotmc.AsyncCatcher.catchOp("effect add"); // Spigot
         if (isTickingEffects) {
-            effectsToProcess.add(new net.minecraft.entity.LivingEntity.ProcessableEffect(mobeffect, cause));
+            effectsToProcess.add(new ProcessableEffect(mobeffect, cause));
             return true;
         }
         // CraftBukkit end
@@ -1061,7 +1061,7 @@ public abstract class LivingEntity extends Entity {
     @Nullable
     public EffectInstance c(@Nullable Effect mobeffectlist, EntityPotionEffectEvent.Cause cause) {
         if (isTickingEffects) {
-            effectsToProcess.add(new net.minecraft.entity.LivingEntity.ProcessableEffect(mobeffectlist, cause));
+            effectsToProcess.add(new ProcessableEffect(mobeffectlist, cause));
             return null;
         }
 
diff --git a/src/main/java/net/minecraft/network/NettyPacketEncoder.java b/src/main/java/net/minecraft/network/NettyPacketEncoder.java
index b17b48341a525f3dbad2de10f92d07ffcf49d4df..d6949f2150a3857a51a0afd9f8753110cc0743e8 100644
--- a/src/main/java/net/minecraft/network/NettyPacketEncoder.java
+++ b/src/main/java/net/minecraft/network/NettyPacketEncoder.java
@@ -53,7 +53,7 @@ public class NettyPacketEncoder extends MessageToByteEncoder<IPacket<?>> {
                 // Paper start
                 int packetLength = bytebuf.readableBytes();
                 if (packetLength > MAX_PACKET_SIZE) {
-                    throw new net.minecraft.network.NettyPacketEncoder.PacketTooLargeException(packet, packetLength);
+                    throw new PacketTooLargeException(packet, packetLength);
                 }
                 // Paper end
             }
diff --git a/src/main/java/net/minecraft/network/NetworkManager.java b/src/main/java/net/minecraft/network/NetworkManager.java
index d0591515bae2269efb08294062d336c619edfc24..3ccf8e64ba14475ed7367e624eef7f431f1178a8 100644
--- a/src/main/java/net/minecraft/network/NetworkManager.java
+++ b/src/main/java/net/minecraft/network/NetworkManager.java
@@ -226,7 +226,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<IPacket<?>> {
             return; // Do nothing
         }
         p_201058_1_.onPacketDispatch(getPlayer());
-        if (connected && (net.minecraft.network.NetworkManager.InnerUtil.canSendImmediate(this, p_201058_1_) || (
+        if (connected && (InnerUtil.canSendImmediate(this, p_201058_1_) || (
             MCUtil.isMainThread() && p_201058_1_.isReady() && this.field_150745_j.isEmpty() &&
             (p_201058_1_.getExtraPackets() == null || p_201058_1_.getExtraPackets().isEmpty())
         ))) {
@@ -234,7 +234,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<IPacket<?>> {
             return;
         }
         // write the packets to the queue, then flush - antixray hooks there already
-        java.util.List<IPacket> extraPackets = net.minecraft.network.NetworkManager.InnerUtil.buildExtraPackets(p_201058_1_);
+        java.util.List<IPacket> extraPackets = InnerUtil.buildExtraPackets(p_201058_1_);
         boolean hasExtraPackets = extraPackets != null && !extraPackets.isEmpty();
         if (!hasExtraPackets) {
             this.field_150745_j.add(new NetworkManager.QueuedPacket(p_201058_1_, p_201058_2_));
diff --git a/src/main/java/net/minecraft/network/login/ServerLoginNetHandler.java b/src/main/java/net/minecraft/network/login/ServerLoginNetHandler.java
index 6e6ba8b66af7d91acad3e08b72dedfe8eea49936..d3659daa9e6d6bb8c3bfced39fc0fd2ae9da46ca 100644
--- a/src/main/java/net/minecraft/network/login/ServerLoginNetHandler.java
+++ b/src/main/java/net/minecraft/network/login/ServerLoginNetHandler.java
@@ -226,7 +226,7 @@ public class ServerLoginNetHandler implements IServerLoginNetHandler {
                 public void run() {
                     try {
                         initUUID();
-                        new net.minecraft.network.login.ServerLoginNetHandler.LoginHandler().fireEvents();
+                        new LoginHandler().fireEvents();
                     } catch (Exception ex) {
                         disconnect("Failed to verify username!");
                         field_147327_f.server.getLogger().log(java.util.logging.Level.WARNING, "Exception verifying " + field_147337_i.getName(), ex);
@@ -265,7 +265,7 @@ public class ServerLoginNetHandler implements IServerLoginNetHandler {
                                 return;
                             }
 
-                            new net.minecraft.network.login.ServerLoginNetHandler.LoginHandler().fireEvents();
+                            new LoginHandler().fireEvents();
                         } else if (ServerLoginNetHandler.this.field_147327_f.func_71264_H()) {
                             ServerLoginNetHandler.field_147332_c.warn("Failed to verify username but will let them in anyway!");
                             ServerLoginNetHandler.this.field_147337_i = ServerLoginNetHandler.this.func_152506_a(gameprofile);
@@ -384,7 +384,7 @@ public class ServerLoginNetHandler implements IServerLoginNetHandler {
             // Proceed with login
             authenticatorPool.execute(() -> {
                 try {
-                    new net.minecraft.network.login.ServerLoginNetHandler.LoginHandler().fireEvents();
+                    new LoginHandler().fireEvents();
                 } catch (Exception ex) {
                     disconnect("Failed to verify username!");
                     field_147327_f.server.getLogger().log(java.util.logging.Level.WARNING, "Exception verifying " + field_147337_i.getName(), ex);
diff --git a/src/main/java/net/minecraft/tileentity/LecternTileEntity.java b/src/main/java/net/minecraft/tileentity/LecternTileEntity.java
index 1b7b3580bb63063fec3465ac8edbe1f0df46cdd5..e640dfd67ca12e6800026e1fc17c46c1353e2ac6 100644
--- a/src/main/java/net/minecraft/tileentity/LecternTileEntity.java
+++ b/src/main/java/net/minecraft/tileentity/LecternTileEntity.java
@@ -42,7 +42,7 @@ import org.bukkit.inventory.InventoryHolder;
 public class LecternTileEntity extends TileEntity implements IClearable, INamedContainerProvider, ICommandSource { // CraftBukkit - ICommandListener
 
     // CraftBukkit start - add fields and methods
-    public final IInventory field_214048_a = new net.minecraft.tileentity.LecternTileEntity.LecternInventory();
+    public final IInventory field_214048_a = new LecternInventory();
     public class LecternInventory implements IInventory {
 
         public List<HumanEntity> transaction = new ArrayList<>();
diff --git a/src/main/java/net/minecraft/world/Explosion.java b/src/main/java/net/minecraft/world/Explosion.java
index 2456e4f8932ea68867af5fd358044250d62bfb73..9b6095133fcf35effca61b56668157256e33cb99 100644
--- a/src/main/java/net/minecraft/world/Explosion.java
+++ b/src/main/java/net/minecraft/world/Explosion.java
@@ -424,7 +424,7 @@ public class Explosion {
         if (!this.field_77287_j.paperConfig.optimizeExplosions) {
             return func_222259_a(vec3d, entity);
         }
-        net.minecraft.world.Explosion.CacheKey key = new net.minecraft.world.Explosion.CacheKey(this, entity.func_174813_aQ());
+        CacheKey key = new CacheKey(this, entity.func_174813_aQ());
         Float blockDensity = this.field_77287_j.explosionDensityCache.get(key);
         if (blockDensity == null) {
             blockDensity = func_222259_a(vec3d, entity);
@@ -458,7 +458,7 @@ public class Explosion {
             if (this == o) return true;
             if (o == null || getClass() != o.getClass()) return false;
 
-            net.minecraft.world.Explosion.CacheKey cacheKey = (net.minecraft.world.Explosion.CacheKey) o;
+            CacheKey cacheKey = (CacheKey) o;
 
             if (Double.compare(cacheKey.posX, posX) != 0) return false;
             if (Double.compare(cacheKey.posY, posY) != 0) return false;
diff --git a/src/main/java/net/minecraft/world/World.java b/src/main/java/net/minecraft/world/World.java
index add4703bea46aaeaeafb4601a849b198aa2fa899..d86e48aea3e37dd2a45a5b1d64007f05a22aa4da 100644
--- a/src/main/java/net/minecraft/world/World.java
+++ b/src/main/java/net/minecraft/world/World.java
@@ -1161,7 +1161,7 @@ public abstract class World implements IWorld, AutoCloseable {
 
         for (int i1 = i; i1 <= j; ++i1) {
             for (int j1 = k; j1 <= l; ++j1) {
-                Chunk chunk = ichunkprovider.func_217205_a(i1, j1, false);
+                Chunk chunk = (Chunk)this.getChunkIfLoadedImmediately(i1, j1); // Paper
 
                 if (chunk != null) {
                     chunk.func_177414_a(p_175674_1_, p_175674_2_, list, p_175674_3_);
@@ -1182,7 +1182,7 @@ public abstract class World implements IWorld, AutoCloseable {
 
         for (int i1 = i; i1 < j; ++i1) {
             for (int j1 = k; j1 < l; ++j1) {
-                Chunk chunk = this.func_72863_F().func_217205_a(i1, j1, false);
+                Chunk chunk = (Chunk)this.getChunkIfLoadedImmediately(i1, j1); // Paper
 
                 if (chunk != null) {
                     chunk.func_217313_a(p_217394_1_, p_217394_2_, list, p_217394_3_);
@@ -1205,7 +1205,7 @@ public abstract class World implements IWorld, AutoCloseable {
 
         for (int i1 = i; i1 < j; ++i1) {
             for (int j1 = k; j1 < l; ++j1) {
-                Chunk chunk = ichunkprovider.func_217205_a(i1, j1, false);
+                Chunk chunk = (Chunk)this.getChunkIfLoadedImmediately(i1, j1); // Paper
 
                 if (chunk != null) {
                     chunk.func_177430_a(p_175647_1_, p_175647_2_, list, p_175647_3_);
diff --git a/src/main/java/net/minecraft/world/biome/Biome.java b/src/main/java/net/minecraft/world/biome/Biome.java
index 9f199193e23b1700565b6f378c7ff1b7e23a5049..43b648455108a10f786aee12ef8b2fbeade8afec 100644
--- a/src/main/java/net/minecraft/world/biome/Biome.java
+++ b/src/main/java/net/minecraft/world/biome/Biome.java
@@ -165,7 +165,7 @@ public class Biome {
             for (j = 0; j < i; ++j) {
                 EntityClassification enumcreaturetype = aenumcreaturetype[j];
 
-                this.field_201880_ax.put(enumcreaturetype, new net.minecraft.world.biome.Biome.MobList()); // Paper
+                this.field_201880_ax.put(enumcreaturetype, new MobList()); // Paper
             }
 
         } else {
diff --git a/src/main/java/net/minecraft/world/chunk/Chunk.java b/src/main/java/net/minecraft/world/chunk/Chunk.java
index 9e803a9bdd7790c4341df7ec22c976747ffda9e5..28f17c1cfb2816159d91440040ce8884c262bc58 100644
--- a/src/main/java/net/minecraft/world/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/chunk/Chunk.java
@@ -139,7 +139,7 @@ public class Chunk implements IChunk {
         this.field_76652_q = new ChunkSection[16];
         this.field_201618_i = Maps.newHashMap();
         this.field_76634_f = Maps.newEnumMap(Heightmap.Type.class);
-        this.field_150816_i = new net.minecraft.world.chunk.Chunk.TileEntityHashMap(); // Paper
+        this.field_150816_i = new TileEntityHashMap(); // Paper
         this.field_201619_q = Maps.newHashMap();
         this.field_201620_r = Maps.newHashMap();
         this.field_201622_t = new ShortList[16];
diff --git a/src/main/java/net/minecraft/world/chunk/storage/ChunkSerializer.java b/src/main/java/net/minecraft/world/chunk/storage/ChunkSerializer.java
index 0af1f3b92a0ebaccbdd4be86a578acc057373aad..0f618c20e0bbcfc54c2370dd73a7a65c196635f5 100644
--- a/src/main/java/net/minecraft/world/chunk/storage/ChunkSerializer.java
+++ b/src/main/java/net/minecraft/world/chunk/storage/ChunkSerializer.java
@@ -82,12 +82,12 @@ public class ChunkSerializer {
     }
 
     public static ChunkPrimer func_222656_a(ServerWorld p_222656_0_, TemplateManager p_222656_1_, PointOfInterestManager p_222656_2_, ChunkPos p_222656_3_, CompoundNBT p_222656_4_) {
-        net.minecraft.world.chunk.storage.ChunkSerializer.InProgressChunkHolder holder = loadChunk(p_222656_0_, p_222656_1_, p_222656_2_, p_222656_3_, p_222656_4_, true);
+        InProgressChunkHolder holder = loadChunk(p_222656_0_, p_222656_1_, p_222656_2_, p_222656_3_, p_222656_4_, true);
         holder.tasks.forEach(Runnable::run);
         return holder.protoChunk;
     }
 
-    public static net.minecraft.world.chunk.storage.ChunkSerializer.InProgressChunkHolder loadChunk(ServerWorld worldserver, TemplateManager definedstructuremanager, PointOfInterestManager villageplace, ChunkPos chunkcoordintpair, CompoundNBT nbttagcompound, boolean distinguish) {
+    public static InProgressChunkHolder loadChunk(ServerWorld worldserver, TemplateManager definedstructuremanager, PointOfInterestManager villageplace, ChunkPos chunkcoordintpair, CompoundNBT nbttagcompound, boolean distinguish) {
         ArrayDeque<Runnable> tasksToExecuteOnMain = new ArrayDeque<>();
         // Paper end
         ChunkGenerator chunkgenerator = worldserver.E().func_201711_g();
@@ -258,7 +258,7 @@ public class ChunkSerializer {
         }
 
         if (chunkstatus_type == ChunkStatus.Type.LEVELCHUNK) {
-            return new net.minecraft.world.chunk.storage.ChunkSerializer.InProgressChunkHolder(new ChunkPrimerWrapper((Chunk) object), tasksToExecuteOnMain); // Paper - Async chunk loading
+            return new InProgressChunkHolder(new ChunkPrimerWrapper((Chunk) object), tasksToExecuteOnMain); // Paper - Async chunk loading
         } else {
             ChunkPrimer protochunk1 = (ChunkPrimer) object;
 
@@ -297,7 +297,7 @@ public class ChunkSerializer {
                 protochunk1.func_205767_a(worldgenstage_features, BitSet.valueOf(nbttagcompound5.func_74770_j(s1)));
             }
 
-            return new net.minecraft.world.chunk.storage.ChunkSerializer.InProgressChunkHolder(protochunk1, tasksToExecuteOnMain); // Paper - Async chunk loading
+            return new InProgressChunkHolder(protochunk1, tasksToExecuteOnMain); // Paper - Async chunk loading
         }
     }
 
@@ -322,7 +322,7 @@ public class ChunkSerializer {
     }
 
     // must be called sync
-    public static net.minecraft.world.chunk.storage.ChunkSerializer.AsyncSaveData getAsyncSaveData(ServerWorld world, IChunk chunk) {
+    public static AsyncSaveData getAsyncSaveData(ServerWorld world, IChunk chunk) {
         org.spigotmc.AsyncCatcher.catchOp("preparation of chunk data for async save");
         ChunkPos chunkPos = chunk.func_76632_l();
 
@@ -366,13 +366,13 @@ public class ChunkSerializer {
             fluidTickListSerialized = world.F().func_219503_a(chunkPos);
         }
 
-        return new net.minecraft.world.chunk.storage.ChunkSerializer.AsyncSaveData(blockLight, skyLight, blockTickListSerialized, fluidTickListSerialized, world.func_82737_E());
+        return new AsyncSaveData(blockLight, skyLight, blockTickListSerialized, fluidTickListSerialized, world.func_82737_E());
     }
 
     public static CompoundNBT func_222645_a(ServerWorld p_222645_0_, IChunk p_222645_1_) {
         return saveChunk(p_222645_0_, p_222645_1_, null);
     }
-    public static CompoundNBT saveChunk(ServerWorld worldserver, IChunk ichunkaccess, net.minecraft.world.chunk.storage.ChunkSerializer.AsyncSaveData asyncsavedata) {
+    public static CompoundNBT saveChunk(ServerWorld worldserver, IChunk ichunkaccess, AsyncSaveData asyncsavedata) {
         // Paper end
         ChunkPos chunkcoordintpair = ichunkaccess.func_76632_l();
         CompoundNBT nbttagcompound = new CompoundNBT();
diff --git a/src/main/java/net/minecraft/world/server/ServerChunkProvider.java b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
index e80e607a339615f8d257e04427d57b8c8e129622..b085b3500d0d0b7309cd2051f9eb3b4d60a0db23 100644
--- a/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
+++ b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
@@ -500,6 +500,7 @@ public class ServerChunkProvider extends AbstractChunkProvider {
                 this.field_73251_h.asyncChunkTaskManager.raisePriority(x, z, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY);
                 com.destroystokyo.paper.io.chunk.ChunkTaskManager.pushChunkWait(this.field_73251_h, x, z);
                 // Paper end
+                com.destroystokyo.paper.io.SyncLoadFinder.logSyncLoad(this.field_73251_h, x, z); // Paper - sync load info
                 this.field_73251_h.timings.syncChunkLoad.startTiming(); // Paper
             this.field_217243_i.func_213161_c(completablefuture::isDone);
                 com.destroystokyo.paper.io.chunk.ChunkTaskManager.popChunkWait(); // Paper - async chunk debug
diff --git a/src/main/java/net/minecraft/world/server/ServerWorld.java b/src/main/java/net/minecraft/world/server/ServerWorld.java
index 5ca03603e71ba29017d7fa1320e5122acdcf96fa..1225229e1eb643fc9ca9587e74882953afa15036 100644
--- a/src/main/java/net/minecraft/world/server/ServerWorld.java
+++ b/src/main/java/net/minecraft/world/server/ServerWorld.java
@@ -270,6 +270,12 @@ public class ServerWorld extends World implements ISeedReader {
     };
     public final com.destroystokyo.paper.io.chunk.ChunkTaskManager asyncChunkTaskManager;
     // Paper end
+    // Paper start
+    @Override
+    public boolean b(int x, int z) {
+        return this.E().getChunkAtIfLoadedImmediately(x, z) != null;
+    }
+    // Paper end
 
     // Add env and gen to constructor, WorldData -> WorldDataServer
     public ServerWorld(MinecraftServer minecraftserver, Executor executor, SaveFormat.LevelSave convertable_conversionsession, IServerWorldInfo iworlddataserver, RegistryKey<World> resourcekey, RegistryKey<DimensionType> resourcekey1, DimensionType dimensionmanager, IChunkStatusListener worldloadlistener, ChunkGenerator chunkgenerator, boolean flag, long i, List<ISpecialSpawner> list, boolean flag1, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java
index 86cf864385bddf726efe6380bf5f81935e7421ad..c6b1118943e38ade69dd2a8c0612de1d99ccb3f3 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java
@@ -68,7 +68,6 @@ import org.bukkit.craftbukkit.block.CraftSign;
 import org.bukkit.craftbukkit.block.CraftSkull;
 import org.bukkit.craftbukkit.block.CraftSmoker;
 import org.bukkit.craftbukkit.block.CraftStructureBlock;
-import org.bukkit.craftbukkit.inventory.CraftMetaItem.ItemMetaKey;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.inventory.meta.BlockStateMeta;
 
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaLeatherArmor.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaLeatherArmor.java
index 801c77ab002c103ad6a301ec76e6208a80f6b54f..9d4a6e828519ed7b738d768f5913e7711296c3cf 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaLeatherArmor.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaLeatherArmor.java
@@ -8,7 +8,6 @@ import net.minecraft.nbt.IntNBT;
 import org.bukkit.Color;
 import org.bukkit.Material;
 import org.bukkit.configuration.serialization.DelegateDeserialization;
-import org.bukkit.craftbukkit.inventory.CraftMetaItem.ItemMetaKey;
 import org.bukkit.craftbukkit.inventory.CraftMetaItem.SerializableMeta;
 import org.bukkit.inventory.meta.LeatherArmorMeta;
 
