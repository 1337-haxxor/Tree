From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sat, 18 Jun 2016 23:22:12 -0400
Subject: [PATCH] Delay Chunk Unloads based on Player Movement

When players are moving in the world, doing things such as building or exploring,
they will commonly go back and forth in a small area. This causes a ton of chunk load
and unload activity on the edge chunks of their view distance.

A simple back and forth movement in 6 blocks could spam a chunk to thrash a
loading and unload cycle over and over again.

This is very wasteful. This system introduces a delay of inactivity on a chunk
before it actually unloads, which will be handled by the ticket expiry process.

This allows servers with smaller worlds who do less long distance exploring to stop
wasting cpu cycles on saving/unloading/reloading chunks repeatedly.

diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 9e55c800eb8b4dd4930dbf730bb6d106a2029036..62e25da19c7ffc13ef1f7dcc375585afd79bb59f 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -626,4 +626,13 @@ public class PaperWorldConfig {
     private void viewDistance() {
         this.noTickViewDistance = this.getInt("viewdistances.no-tick-view-distance", -1);
     }
+
+    public long delayChunkUnloadsBy;
+    private void delayChunkUnloadsBy() {
+        delayChunkUnloadsBy = PaperConfig.getSeconds(getString("delay-chunk-unloads-by", "10s"));
+        if (delayChunkUnloadsBy > 0) {
+            log("Delaying chunk unloads by " + delayChunkUnloadsBy + " seconds");
+            delayChunkUnloadsBy *= 20;
+        }
+    }
 }
diff --git a/src/main/java/net/minecraft/world/server/ServerWorldLightManager.java b/src/main/java/net/minecraft/world/server/ServerWorldLightManager.java
index e27a2c9e4c1f60fd23a64b9b0586776da23141e0..ee7267dc8f0eaefb45eb26040ad576cd70a7d029 100644
--- a/src/main/java/net/minecraft/world/server/ServerWorldLightManager.java
+++ b/src/main/java/net/minecraft/world/server/ServerWorldLightManager.java
@@ -70,8 +70,8 @@ public class ServerWorldLightManager extends WorldLightManager implements AutoCl
     // Retain the chunks priority level for queued light tasks
     class LightQueue {
         private int size = 0;
-        private final Long2ObjectLinkedOpenHashMap<net.minecraft.world.server.ServerWorldLightManager.ChunkLightQueue>[] buckets = new Long2ObjectLinkedOpenHashMap[MAX_PRIORITIES];
-        private final java.util.concurrent.ConcurrentLinkedQueue<net.minecraft.world.server.ServerWorldLightManager.PendingLightTask> pendingTasks = new java.util.concurrent.ConcurrentLinkedQueue<>();
+        private final Long2ObjectLinkedOpenHashMap<ChunkLightQueue>[] buckets = new Long2ObjectLinkedOpenHashMap[MAX_PRIORITIES];
+        private final java.util.concurrent.ConcurrentLinkedQueue<PendingLightTask> pendingTasks = new java.util.concurrent.ConcurrentLinkedQueue<>();
         private final java.util.concurrent.ConcurrentLinkedQueue<Runnable> priorityChanges = new java.util.concurrent.ConcurrentLinkedQueue<>();
 
         private LightQueue() {
@@ -82,9 +82,9 @@ public class ServerWorldLightManager extends WorldLightManager implements AutoCl
 
         public void changePriority(long pair, int currentPriority, int priority) {
             this.priorityChanges.add(() -> {
-                net.minecraft.world.server.ServerWorldLightManager.ChunkLightQueue remove = this.buckets[currentPriority].remove(pair);
+                ChunkLightQueue remove = this.buckets[currentPriority].remove(pair);
                 if (remove != null) {
-                    net.minecraft.world.server.ServerWorldLightManager.ChunkLightQueue existing = this.buckets[Math.max(1, priority)].put(pair, remove);
+                    ChunkLightQueue existing = this.buckets[Math.max(1, priority)].put(pair, remove);
                     if (existing != null) {
                         remove.pre.addAll(existing.pre);
                         remove.post.addAll(existing.post);
@@ -94,16 +94,16 @@ public class ServerWorldLightManager extends WorldLightManager implements AutoCl
         }
 
         public final void addChunk(long chunkId, IntSupplier priority, Runnable pre, Runnable post) {
-            pendingTasks.add(new net.minecraft.world.server.ServerWorldLightManager.PendingLightTask(chunkId, priority, pre, post, true));
+            pendingTasks.add(new PendingLightTask(chunkId, priority, pre, post, true));
             func_215588_z_();
         }
 
         public final void add(long chunkId, IntSupplier priority, ServerWorldLightManager.Phase type, Runnable run) {
-            pendingTasks.add(new net.minecraft.world.server.ServerWorldLightManager.PendingLightTask(chunkId, priority, type == Phase.PRE_UPDATE ? run : null, type == Phase.POST_UPDATE ? run : null, false));
+            pendingTasks.add(new PendingLightTask(chunkId, priority, type == Phase.PRE_UPDATE ? run : null, type == Phase.POST_UPDATE ? run : null, false));
         }
-        public final void add(net.minecraft.world.server.ServerWorldLightManager.PendingLightTask update) {
+        public final void add(PendingLightTask update) {
             int priority = update.priority.getAsInt();
-            net.minecraft.world.server.ServerWorldLightManager.ChunkLightQueue lightQueue = this.buckets[priority].computeIfAbsent(update.chunkId, net.minecraft.world.server.ServerWorldLightManager.ChunkLightQueue::new);
+            ChunkLightQueue lightQueue = this.buckets[priority].computeIfAbsent(update.chunkId, ChunkLightQueue::new);
 
             if (update.pre != null) {
                 this.size++;
@@ -127,7 +127,7 @@ public class ServerWorldLightManager extends WorldLightManager implements AutoCl
         }
 
         public boolean poll(java.util.List<Runnable> pre, java.util.List<Runnable> post) {
-            net.minecraft.world.server.ServerWorldLightManager.PendingLightTask pending;
+            PendingLightTask pending;
             while ((pending = pendingTasks.poll()) != null) {
                 add(pending);
             }
@@ -136,10 +136,10 @@ public class ServerWorldLightManager extends WorldLightManager implements AutoCl
                 run.run();
             }
             boolean hasWork = false;
-            Long2ObjectLinkedOpenHashMap<net.minecraft.world.server.ServerWorldLightManager.ChunkLightQueue>[] buckets = this.buckets;
+            Long2ObjectLinkedOpenHashMap<ChunkLightQueue>[] buckets = this.buckets;
             int priority = 0;
             while (priority < MAX_PRIORITIES && !isEmpty()) {
-                Long2ObjectLinkedOpenHashMap<net.minecraft.world.server.ServerWorldLightManager.ChunkLightQueue> bucket = buckets[priority];
+                Long2ObjectLinkedOpenHashMap<ChunkLightQueue> bucket = buckets[priority];
                 if (bucket.isEmpty()) {
                     priority++;
                     if (hasWork) {
@@ -148,7 +148,7 @@ public class ServerWorldLightManager extends WorldLightManager implements AutoCl
                         continue;
                     }
                 }
-                net.minecraft.world.server.ServerWorldLightManager.ChunkLightQueue queue = bucket.removeFirst();
+                ChunkLightQueue queue = bucket.removeFirst();
                 this.size -= queue.pre.size() + queue.post.size();
                 pre.addAll(queue.pre);
                 post.addAll(queue.post);
@@ -163,7 +163,7 @@ public class ServerWorldLightManager extends WorldLightManager implements AutoCl
         }
     }
 
-    final net.minecraft.world.server.ServerWorldLightManager.LightQueue queue = new net.minecraft.world.server.ServerWorldLightManager.LightQueue();
+    final LightQueue queue = new LightQueue();
     // Paper end
     private final ChunkManager field_215607_d; private final ChunkManager playerChunkMap; // Paper
     private final ITaskExecutor<ChunkTaskPriorityQueueSorter.FunctionEntry<Runnable>> field_215608_e;
diff --git a/src/main/java/net/minecraft/world/server/Ticket.java b/src/main/java/net/minecraft/world/server/Ticket.java
index 8542d970d3e6c3bca69df002d6f9d13677820d18..a605b8f43ff1011c780e665dc602364f6172acd4 100644
--- a/src/main/java/net/minecraft/world/server/Ticket.java
+++ b/src/main/java/net/minecraft/world/server/Ticket.java
@@ -9,11 +9,13 @@ public final class Ticket<T> implements Comparable<Ticket<?>> {
     public final T field_219482_c; public final T getObjectReason() { return this.field_219482_c; } // Paper - OBFHELPER
     private long field_219483_d; public final long getCreationTick() { return this.field_219483_d; } // Paper - OBFHELPER
     public int priority = 0; // Paper
+    public long delayUnloadBy; // Paper
 
     protected Ticket(TicketType<T> tickettype, int i, T t0) {
         this.field_219480_a = tickettype;
         this.field_219481_b = i;
         this.field_219482_c = t0;
+        this.delayUnloadBy = tickettype.field_223186_k; // Paper
     }
 
     public int compareTo(Ticket<?> ticket) {
@@ -63,7 +65,7 @@ public final class Ticket<T> implements Comparable<Ticket<?>> {
     }
 
     protected boolean func_223182_a(long p_223182_1_) {
-        long j = this.field_219480_a.func_223184_b();
+        long j = delayUnloadBy; // Paper
 
         return j != 0L && p_223182_1_ - this.field_219483_d > j;
     }
diff --git a/src/main/java/net/minecraft/world/server/TicketManager.java b/src/main/java/net/minecraft/world/server/TicketManager.java
index c88a65e0f4d3900f9ef6dec57a1b686ffce4109c..21038e525abee3c02b500627bb8214f087f44831 100644
--- a/src/main/java/net/minecraft/world/server/TicketManager.java
+++ b/src/main/java/net/minecraft/world/server/TicketManager.java
@@ -188,6 +188,27 @@ public abstract class TicketManager {
         boolean removed = false; // CraftBukkit
         if (arraysetsorted.remove(ticket)) {
             removed = true; // CraftBukkit
+            // Paper start - delay chunk unloads for player tickets
+            long delayChunkUnloadsBy = chunkMap.field_219255_i.paperConfig.delayChunkUnloadsBy;
+            if (ticket.func_219479_a() == TicketType.field_219490_c && delayChunkUnloadsBy > 0) {
+                boolean hasPlayer = false;
+                for (Ticket<?> ticket1 : arraysetsorted) {
+                    if (ticket1.func_219479_a() == TicketType.field_219490_c) {
+                        hasPlayer = true;
+                        break;
+                    }
+                }
+                ChunkHolder playerChunk = chunkMap.func_219220_a(i);
+                if (!hasPlayer && playerChunk != null && playerChunk.isFullChunkReady()) {
+                    Ticket<Long> delayUnload = new Ticket<Long>(TicketType.DELAY_UNLOAD, 33, i);
+                    delayUnload.delayUnloadBy = delayChunkUnloadsBy;
+                    delayUnload.setCurrentTick(this.field_219389_q);
+                    arraysetsorted.remove(delayUnload);
+                    // refresh ticket
+                    arraysetsorted.add(delayUnload);
+                }
+            }
+            // Paper end
         }
 
         if (arraysetsorted.isEmpty()) {
diff --git a/src/main/java/net/minecraft/world/server/TicketType.java b/src/main/java/net/minecraft/world/server/TicketType.java
index ce7145f48b4f3e907c413825c114aeb2bfddbd9d..66c8cff8ae4c49f696c4397eee090cb531155343 100644
--- a/src/main/java/net/minecraft/world/server/TicketType.java
+++ b/src/main/java/net/minecraft/world/server/TicketType.java
@@ -30,6 +30,7 @@ public class TicketType<T> {
     public static final TicketType<Long> ASYNC_LOAD = func_219484_a("async_load", Long::compareTo); // Paper
     public static final TicketType<ChunkPos> PRIORITY = func_223183_a("priority", Comparator.comparingLong(ChunkPos::func_201841_a), 300); // Paper
     public static final TicketType<ChunkPos> URGENT = func_223183_a("urgent", Comparator.comparingLong(ChunkPos::func_201841_a), 300); // Paper
+    public static final TicketType<Long> DELAY_UNLOAD = func_223183_a("delay_unload", Long::compareTo, 300); // Paper
 
     public static <T> TicketType<T> func_219484_a(String p_219484_0_, Comparator<T> p_219484_1_) {
         return new TicketType<>(p_219484_0_, p_219484_1_, 0L);
