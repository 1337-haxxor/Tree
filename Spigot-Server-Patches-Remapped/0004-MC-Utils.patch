From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Mon, 28 Mar 2016 20:55:47 -0400
Subject: [PATCH] MC Utils


diff --git a/src/main/java/com/destroystokyo/paper/util/concurrent/WeakSeqLock.java b/src/main/java/com/destroystokyo/paper/util/concurrent/WeakSeqLock.java
new file mode 100644
index 0000000000000000000000000000000000000000..4029dc68cf35d63aa70c4a76c35bf65a7fc6358f
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/concurrent/WeakSeqLock.java
@@ -0,0 +1,68 @@
+package com.destroystokyo.paper.util.concurrent;
+
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * copied from https://github.com/Spottedleaf/ConcurrentUtil/blob/master/src/main/java/ca/spottedleaf/concurrentutil/lock/WeakSeqLock.java
+ * @author Spottedleaf
+ */
+public final class WeakSeqLock {
+    // TODO when the switch to J11 is made, nuke this class from orbit
+
+    protected final AtomicLong lock = new AtomicLong();
+
+    public WeakSeqLock() {
+        //VarHandle.storeStoreFence(); // warn: usages must be checked to ensure this behaviour isn't needed
+    }
+
+    public void acquireWrite() {
+        // must be release-type write
+        this.lock.lazySet(this.lock.get() + 1);
+    }
+
+    public boolean canRead(final long read) {
+        return (read & 1) == 0;
+    }
+
+    public boolean tryAcquireWrite() {
+        this.acquireWrite();
+        return true;
+    }
+
+    public void releaseWrite() {
+        // must be acquire-type write
+        final long lock = this.lock.get(); // volatile here acts as store-store
+        this.lock.lazySet(lock + 1);
+    }
+
+    public void abortWrite() {
+        // must be acquire-type write
+        final long lock = this.lock.get(); // volatile here acts as store-store
+        this.lock.lazySet(lock ^ 1);
+    }
+
+    public long acquireRead() {
+        int failures = 0;
+        long curr;
+
+        for (curr = this.lock.get(); !this.canRead(curr); curr = this.lock.get()) {
+            // without j11, our only backoff is the yield() call...
+
+            if (++failures > 5_000) { /* TODO determine a threshold */
+                Thread.yield();
+            }
+            /* Better waiting is beyond the scope of this lock; if it is needed the lock is being misused */
+        }
+
+        //VarHandle.loadLoadFence(); // volatile acts as the load-load barrier
+        return curr;
+    }
+
+    public boolean tryReleaseRead(final long read) {
+        return this.lock.get() == read; // volatile acts as the load-load barrier
+    }
+
+    public long getSequentialCounter() {
+        return this.lock.get();
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Int.java b/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Int.java
new file mode 100644
index 0000000000000000000000000000000000000000..59868f37d14bbc0ece0836095cdad148778995e6
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Int.java
@@ -0,0 +1,162 @@
+package com.destroystokyo.paper.util.map;
+
+import com.destroystokyo.paper.util.concurrent.WeakSeqLock;
+import it.unimi.dsi.fastutil.longs.Long2IntMap;
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+
+/**
+ * @author Spottedleaf
+ */
+public class QueuedChangesMapLong2Int {
+
+    protected final Long2IntOpenHashMap updatingMap;
+    protected final Long2IntOpenHashMap visibleMap;
+    protected final Long2IntOpenHashMap queuedPuts;
+    protected final LongOpenHashSet queuedRemove;
+
+    protected int queuedDefaultReturnValue;
+
+    // we use a seqlock as writes are not common.
+    protected final WeakSeqLock updatingMapSeqLock = new WeakSeqLock();
+
+    public QueuedChangesMapLong2Int() {
+        this(16, 0.75f);
+    }
+
+    public QueuedChangesMapLong2Int(final int capacity, final float loadFactor) {
+        this.updatingMap = new Long2IntOpenHashMap(capacity, loadFactor);
+        this.visibleMap = new Long2IntOpenHashMap(capacity, loadFactor);
+        this.queuedPuts = new Long2IntOpenHashMap();
+        this.queuedRemove = new LongOpenHashSet();
+    }
+
+    public void queueDefaultReturnValue(final int dfl) {
+        this.queuedDefaultReturnValue = dfl;
+        this.updatingMap.defaultReturnValue(dfl);
+    }
+
+    public int queueUpdate(final long k, final int v) {
+        this.queuedRemove.remove(k);
+        this.queuedPuts.put(k, v);
+
+        return this.updatingMap.put(k, v);
+    }
+
+    public int queueRemove(final long k) {
+        this.queuedPuts.remove(k);
+        this.queuedRemove.add(k);
+
+        return this.updatingMap.remove(k);
+    }
+
+    public int getUpdating(final long k) {
+        return this.updatingMap.get(k);
+    }
+
+    public int getVisible(final long k) {
+        return this.visibleMap.get(k);
+    }
+
+    public int getVisibleAsync(final long k) {
+        long readlock;
+        int ret = 0;
+
+        do {
+            readlock = this.updatingMapSeqLock.acquireRead();
+            try {
+                ret = this.visibleMap.get(k);
+            } catch (final Throwable thr) {
+                if (thr instanceof ThreadDeath) {
+                    throw (ThreadDeath)thr;
+                }
+                // ignore...
+                continue;
+            }
+
+        } while (!this.updatingMapSeqLock.tryReleaseRead(readlock));
+
+        return ret;
+    }
+
+    public boolean performUpdates() {
+        this.updatingMapSeqLock.acquireWrite();
+        this.visibleMap.defaultReturnValue(this.queuedDefaultReturnValue);
+        this.updatingMapSeqLock.releaseWrite();
+
+        if (this.queuedPuts.isEmpty() && this.queuedRemove.isEmpty()) {
+            return false;
+        }
+
+        // update puts
+        final ObjectIterator<Long2IntMap.Entry> iterator0 = this.queuedPuts.long2IntEntrySet().fastIterator();
+        while (iterator0.hasNext()) {
+            final Long2IntMap.Entry entry = iterator0.next();
+            final long key = entry.getLongKey();
+            final int val = entry.getIntValue();
+
+            this.updatingMapSeqLock.acquireWrite();
+            try {
+                this.visibleMap.put(key, val);
+            } finally {
+                this.updatingMapSeqLock.releaseWrite();
+            }
+        }
+
+        this.queuedPuts.clear();
+
+        final LongIterator iterator1 = this.queuedRemove.iterator();
+        while (iterator1.hasNext()) {
+            final long key = iterator1.nextLong();
+
+            this.updatingMapSeqLock.acquireWrite();
+            try {
+                this.visibleMap.remove(key);
+            } finally {
+                this.updatingMapSeqLock.releaseWrite();
+            }
+        }
+
+        this.queuedRemove.clear();
+
+        return true;
+    }
+
+    public boolean performUpdatesLockMap() {
+        this.updatingMapSeqLock.acquireWrite();
+        try {
+            this.visibleMap.defaultReturnValue(this.queuedDefaultReturnValue);
+
+            if (this.queuedPuts.isEmpty() && this.queuedRemove.isEmpty()) {
+                return false;
+            }
+
+            // update puts
+            final ObjectIterator<Long2IntMap.Entry> iterator0 = this.queuedPuts.long2IntEntrySet().fastIterator();
+            while (iterator0.hasNext()) {
+                final Long2IntMap.Entry entry = iterator0.next();
+                final long key = entry.getLongKey();
+                final int val = entry.getIntValue();
+
+                this.visibleMap.put(key, val);
+            }
+
+            this.queuedPuts.clear();
+
+            final LongIterator iterator1 = this.queuedRemove.iterator();
+            while (iterator1.hasNext()) {
+                final long key = iterator1.nextLong();
+
+                this.visibleMap.remove(key);
+            }
+
+            this.queuedRemove.clear();
+
+            return true;
+        } finally {
+            this.updatingMapSeqLock.releaseWrite();
+        }
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java b/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java
new file mode 100644
index 0000000000000000000000000000000000000000..7bab31a312463cc963d9621cdc543a281459bd32
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java
@@ -0,0 +1,202 @@
+package com.destroystokyo.paper.util.map;
+
+import com.destroystokyo.paper.util.concurrent.WeakSeqLock;
+import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * @author Spottedleaf
+ */
+public class QueuedChangesMapLong2Object<V> {
+
+    protected static final Object REMOVED = new Object();
+
+    protected final Long2ObjectLinkedOpenHashMap<V> updatingMap;
+    protected final Long2ObjectLinkedOpenHashMap<V> visibleMap;
+    protected final Long2ObjectLinkedOpenHashMap<Object> queuedChanges;
+
+    // we use a seqlock as writes are not common.
+    protected final WeakSeqLock updatingMapSeqLock = new WeakSeqLock();
+
+    public QueuedChangesMapLong2Object() {
+        this(16, 0.75f); // dfl for fastutil
+    }
+
+    public QueuedChangesMapLong2Object(final int capacity, final float loadFactor) {
+        this.updatingMap = new Long2ObjectLinkedOpenHashMap<>(capacity, loadFactor);
+        this.visibleMap = new Long2ObjectLinkedOpenHashMap<>(capacity, loadFactor);
+        this.queuedChanges = new Long2ObjectLinkedOpenHashMap<>();
+    }
+
+    public V queueUpdate(final long k, final V value) {
+        this.queuedChanges.put(k, value);
+        return this.updatingMap.put(k, value);
+    }
+
+    public V queueRemove(final long k) {
+        this.queuedChanges.put(k, REMOVED);
+        return this.updatingMap.remove(k);
+    }
+
+    public V getUpdating(final long k) {
+        return this.updatingMap.get(k);
+    }
+
+    public boolean updatingContainsKey(final long k) {
+        return this.updatingMap.containsKey(k);
+    }
+
+    public V getVisible(final long k) {
+        return this.visibleMap.get(k);
+    }
+
+    public boolean visibleContainsKey(final long k) {
+        return this.visibleMap.containsKey(k);
+    }
+
+    public V getVisibleAsync(final long k) {
+        long readlock;
+        V ret = null;
+
+        do {
+            readlock = this.updatingMapSeqLock.acquireRead();
+
+            try {
+                ret = this.visibleMap.get(k);
+            } catch (final Throwable thr) {
+                if (thr instanceof ThreadDeath) {
+                    throw (ThreadDeath)thr;
+                }
+                // ignore...
+                continue;
+            }
+
+        } while (!this.updatingMapSeqLock.tryReleaseRead(readlock));
+
+        return ret;
+    }
+
+    public boolean visibleContainsKeyAsync(final long k) {
+        long readlock;
+        boolean ret = false;
+
+        do {
+            readlock = this.updatingMapSeqLock.acquireRead();
+
+            try {
+                ret = this.visibleMap.containsKey(k);
+            } catch (final Throwable thr) {
+                if (thr instanceof ThreadDeath) {
+                    throw (ThreadDeath)thr;
+                }
+                // ignore...
+                continue;
+            }
+
+        } while (!this.updatingMapSeqLock.tryReleaseRead(readlock));
+
+        return ret;
+    }
+
+    public Long2ObjectLinkedOpenHashMap<V> getVisibleMap() {
+        return this.visibleMap;
+    }
+
+    public Long2ObjectLinkedOpenHashMap<V> getUpdatingMap() {
+        return this.updatingMap;
+    }
+
+    public int getVisibleSize() {
+        return this.visibleMap.size();
+    }
+
+    public int getVisibleSizeAsync() {
+        long readlock;
+        int ret;
+
+        do {
+            readlock = this.updatingMapSeqLock.acquireRead();
+            ret = this.visibleMap.size();
+        } while (!this.updatingMapSeqLock.tryReleaseRead(readlock));
+
+        return ret;
+    }
+
+    // unlike mojang's impl this cannot be used async since it's not a view of an immutable map
+    public Collection<V> getUpdatingValues() {
+        return this.updatingMap.values();
+    }
+
+    public List<V> getUpdatingValuesCopy() {
+        return new ArrayList<>(this.updatingMap.values());
+    }
+
+    // unlike mojang's impl this cannot be used async since it's not a view of an immutable map
+    public Collection<V> getVisibleValues() {
+        return this.visibleMap.values();
+    }
+
+    public List<V> getVisibleValuesCopy() {
+        return new ArrayList<>(this.visibleMap.values());
+    }
+
+    public boolean performUpdates() {
+        if (this.queuedChanges.isEmpty()) {
+            return false;
+        }
+
+        final ObjectBidirectionalIterator<Long2ObjectMap.Entry<Object>> iterator = this.queuedChanges.long2ObjectEntrySet().fastIterator();
+        while (iterator.hasNext()) {
+            final Long2ObjectMap.Entry<Object> entry = iterator.next();
+            final long key = entry.getLongKey();
+            final Object val = entry.getValue();
+
+            this.updatingMapSeqLock.acquireWrite();
+            try {
+                if (val == REMOVED) {
+                    this.visibleMap.remove(key);
+                } else {
+                    this.visibleMap.put(key, (V)val);
+                }
+            } finally {
+                this.updatingMapSeqLock.releaseWrite();
+            }
+        }
+
+        this.queuedChanges.clear();
+        return true;
+    }
+
+    public boolean performUpdatesLockMap() {
+        if (this.queuedChanges.isEmpty()) {
+            return false;
+        }
+
+        final ObjectBidirectionalIterator<Long2ObjectMap.Entry<Object>> iterator = this.queuedChanges.long2ObjectEntrySet().fastIterator();
+
+        try {
+            this.updatingMapSeqLock.acquireWrite();
+
+            while (iterator.hasNext()) {
+                final Long2ObjectMap.Entry<Object> entry = iterator.next();
+                final long key = entry.getLongKey();
+                final Object val = entry.getValue();
+
+                if (val == REMOVED) {
+                    this.visibleMap.remove(key);
+                } else {
+                    this.visibleMap.put(key, (V)val);
+                }
+            }
+        } finally {
+            this.updatingMapSeqLock.releaseWrite();
+        }
+
+        this.queuedChanges.clear();
+        return true;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/ChunkList.java b/src/main/java/com/destroystokyo/paper/util/maplist/ChunkList.java
new file mode 100644
index 0000000000000000000000000000000000000000..c458c08cb05de5f61857ba79c7771a5422fdcc83
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/ChunkList.java
@@ -0,0 +1,129 @@
+package com.destroystokyo.paper.util.maplist;
+
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
+import net.minecraft.server.MCUtil;
+import net.minecraft.world.chunk.Chunk;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+// list with O(1) remove & contains
+/**
+ * @author Spottedleaf
+ */
+public final class ChunkList implements Iterable<Chunk> {
+
+    protected final Long2IntOpenHashMap chunkToIndex = new Long2IntOpenHashMap(2, 0.8f);
+    {
+        this.chunkToIndex.defaultReturnValue(Integer.MIN_VALUE);
+    }
+
+    protected static final Chunk[] EMPTY_LIST = new Chunk[0];
+
+    protected Chunk[] chunks = EMPTY_LIST;
+    protected int count;
+
+    public int size() {
+        return this.count;
+    }
+
+    public boolean contains(final Chunk chunk) {
+        return this.chunkToIndex.containsKey(chunk.coordinateKey);
+    }
+
+    public boolean remove(final Chunk chunk) {
+        final int index = this.chunkToIndex.remove(chunk.coordinateKey);
+        if (index == Integer.MIN_VALUE) {
+            return false;
+        }
+
+        // move the entity at the end to this index
+        final int endIndex = --this.count;
+        final Chunk end = this.chunks[endIndex];
+        if (index != endIndex) {
+            // not empty after this call
+            this.chunkToIndex.put(end.coordinateKey, index); // update index
+        }
+        this.chunks[index] = end;
+        this.chunks[endIndex] = null;
+
+        return true;
+    }
+
+    public boolean add(final Chunk chunk) {
+        final int count = this.count;
+        final int currIndex = this.chunkToIndex.putIfAbsent(chunk.coordinateKey, count);
+
+        if (currIndex != Integer.MIN_VALUE) {
+            return false; // already in this list
+        }
+
+        Chunk[] list = this.chunks;
+
+        if (list.length == count) {
+            // resize required
+            list = this.chunks = Arrays.copyOf(list, (int)Math.max(4L, count * 2L)); // overflow results in negative
+        }
+
+        list[count] = chunk;
+        this.count = count + 1;
+
+        return true;
+    }
+
+    public Chunk getChecked(final int index) {
+        if (index < 0 || index >= this.count) {
+            throw new IndexOutOfBoundsException("Index: " + index + " is out of bounds, size: " + this.count);
+        }
+        return this.chunks[index];
+    }
+
+    public Chunk getUnchecked(final int index) {
+        return this.chunks[index];
+    }
+
+    public Chunk[] getRawData() {
+        return this.chunks;
+    }
+
+    public void clear() {
+        this.chunkToIndex.clear();
+        Arrays.fill(this.chunks, 0, this.count, null);
+        this.count = 0;
+    }
+
+    @Override
+    public Iterator<Chunk> iterator() {
+        return new Iterator<Chunk>() {
+
+            Chunk lastRet;
+            int current;
+
+            @Override
+            public boolean hasNext() {
+                return this.current < ChunkList.this.count;
+            }
+
+            @Override
+            public Chunk next() {
+                if (this.current >= ChunkList.this.count) {
+                    throw new NoSuchElementException();
+                }
+                return this.lastRet = ChunkList.this.chunks[this.current++];
+            }
+
+            @Override
+            public void remove() {
+                final Chunk lastRet = this.lastRet;
+
+                if (lastRet == null) {
+                    throw new IllegalStateException();
+                }
+                this.lastRet = null;
+
+                ChunkList.this.remove(lastRet);
+                --this.current;
+            }
+        };
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
new file mode 100644
index 0000000000000000000000000000000000000000..486a0c50d9d846113fd9f0850f64a997b65da45f
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
@@ -0,0 +1,128 @@
+package com.destroystokyo.paper.util.maplist;
+
+import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import net.minecraft.entity.Entity;
+
+// list with O(1) remove & contains
+/**
+ * @author Spottedleaf
+ */
+public final class EntityList implements Iterable<Entity> {
+
+    protected final Int2IntOpenHashMap entityToIndex = new Int2IntOpenHashMap(2, 0.8f);
+    {
+        this.entityToIndex.defaultReturnValue(Integer.MIN_VALUE);
+    }
+
+    protected static final Entity[] EMPTY_LIST = new Entity[0];
+
+    protected Entity[] entities = EMPTY_LIST;
+    protected int count;
+
+    public int size() {
+        return this.count;
+    }
+
+    public boolean contains(final Entity entity) {
+        return this.entityToIndex.containsKey(entity.func_145782_y());
+    }
+
+    public boolean remove(final Entity entity) {
+        final int index = this.entityToIndex.remove(entity.func_145782_y());
+        if (index == Integer.MIN_VALUE) {
+            return false;
+        }
+
+        // move the entity at the end to this index
+        final int endIndex = --this.count;
+        final Entity end = this.entities[endIndex];
+        if (index != endIndex) {
+            // not empty after this call
+            this.entityToIndex.put(end.func_145782_y(), index); // update index
+        }
+        this.entities[index] = end;
+        this.entities[endIndex] = null;
+
+        return true;
+    }
+
+    public boolean add(final Entity entity) {
+        final int count = this.count;
+        final int currIndex = this.entityToIndex.putIfAbsent(entity.func_145782_y(), count);
+
+        if (currIndex != Integer.MIN_VALUE) {
+            return false; // already in this list
+        }
+
+        Entity[] list = this.entities;
+
+        if (list.length == count) {
+            // resize required
+            list = this.entities = Arrays.copyOf(list, (int)Math.max(4L, count * 2L)); // overflow results in negative
+        }
+
+        list[count] = entity;
+        this.count = count + 1;
+
+        return true;
+    }
+
+    public Entity getChecked(final int index) {
+        if (index < 0 || index >= this.count) {
+            throw new IndexOutOfBoundsException("Index: " + index + " is out of bounds, size: " + this.count);
+        }
+        return this.entities[index];
+    }
+
+    public Entity getUnchecked(final int index) {
+        return this.entities[index];
+    }
+
+    public Entity[] getRawData() {
+        return this.entities;
+    }
+
+    public void clear() {
+        this.entityToIndex.clear();
+        Arrays.fill(this.entities, 0, this.count, null);
+        this.count = 0;
+    }
+
+    @Override
+    public Iterator<Entity> iterator() {
+        return new Iterator<Entity>() {
+
+            Entity lastRet;
+            int current;
+
+            @Override
+            public boolean hasNext() {
+                return this.current < EntityList.this.count;
+            }
+
+            @Override
+            public Entity next() {
+                if (this.current >= EntityList.this.count) {
+                    throw new NoSuchElementException();
+                }
+                return this.lastRet = EntityList.this.entities[this.current++];
+            }
+
+            @Override
+            public void remove() {
+                final Entity lastRet = this.lastRet;
+
+                if (lastRet == null) {
+                    throw new IllegalStateException();
+                }
+                this.lastRet = null;
+
+                EntityList.this.remove(lastRet);
+                --this.current;
+            }
+        };
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java b/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
new file mode 100644
index 0000000000000000000000000000000000000000..89c59c8c830171da0d69f7b6fd39cdce0bce6f3c
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
@@ -0,0 +1,128 @@
+package com.destroystokyo.paper.util.maplist;
+
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.shorts.Short2LongOpenHashMap;
+import java.util.Arrays;
+import net.minecraft.block.BlockState;
+import net.minecraft.util.palette.IdentityPalette;
+import net.minecraft.world.chunk.ChunkSection;
+
+/**
+ * @author Spottedleaf
+ */
+public final class IBlockDataList {
+
+    static final IdentityPalette<BlockState> GLOBAL_PALETTE = (IdentityPalette)ChunkSection.field_205512_a;
+
+    // map of location -> (index | (location << 16) | (palette id << 32))
+    private final Short2LongOpenHashMap map = new Short2LongOpenHashMap(2, 0.8f);
+    {
+        this.map.defaultReturnValue(Long.MAX_VALUE);
+    }
+
+    private static final long[] EMPTY_LIST = new long[0];
+
+    private long[] byIndex = EMPTY_LIST;
+    private int size;
+
+    public static int getLocationKey(final int x, final int y, final int z) {
+        return (x & 15) | (((z & 15) << 4)) | ((y & 255) << (4 + 4));
+    }
+
+    public static BlockState getBlockDataFromRaw(final long raw) {
+        return GLOBAL_PALETTE.getObject((int)(raw >>> 32));
+    }
+
+    public static int getIndexFromRaw(final long raw) {
+        return (int)(raw & 0xFFFF);
+    }
+
+    public static int getLocationFromRaw(final long raw) {
+        return (int)((raw >>> 16) & 0xFFFF);
+    }
+
+    public static long getRawFromValues(final int index, final int location, final BlockState data) {
+        return (long)index | ((long)location << 16) | (((long)GLOBAL_PALETTE.getOrCreateIdFor(data)) << 32);
+    }
+
+    public static long setIndexRawValues(final long value, final int index) {
+        return value & ~(0xFFFF) | (index);
+    }
+
+    public long add(final int x, final int y, final int z, final BlockState data) {
+        return this.add(getLocationKey(x, y, z), data);
+    }
+
+    public long add(final int location, final BlockState data) {
+        final long curr = this.map.get((short)location);
+
+        if (curr == Long.MAX_VALUE) {
+            final int index = this.size++;
+            final long raw = getRawFromValues(index, location, data);
+            this.map.put((short)location, raw);
+
+            if (index >= this.byIndex.length) {
+                this.byIndex = Arrays.copyOf(this.byIndex, (int)Math.max(4L, this.byIndex.length * 2L));
+            }
+
+            this.byIndex[index] = raw;
+            return raw;
+        } else {
+            final int index = getIndexFromRaw(curr);
+            final long raw = this.byIndex[index] = getRawFromValues(index, location, data);
+
+            this.map.put((short)location, raw);
+
+            return raw;
+        }
+    }
+
+    public long remove(final int x, final int y, final int z) {
+        return this.remove(getLocationKey(x, y, z));
+    }
+
+    public long remove(final int location) {
+        final long ret = this.map.remove((short)location);
+        final int index = getIndexFromRaw(ret);
+        if (ret == Long.MAX_VALUE) {
+            return ret;
+        }
+
+        // move the entry at the end to this index
+        final int endIndex = --this.size;
+        final long end = this.byIndex[endIndex];
+        if (index != endIndex) {
+            // not empty after this call
+            this.map.put((short)getLocationFromRaw(end), setIndexRawValues(end, index));
+        }
+        this.byIndex[index] = end;
+        this.byIndex[endIndex] = 0L;
+
+        return ret;
+    }
+
+    public int size() {
+        return this.size;
+    }
+
+    public long getRaw(final int index) {
+        return this.byIndex[index];
+    }
+
+    public int getLocation(final int index) {
+        return getLocationFromRaw(this.getRaw(index));
+    }
+
+    public BlockState getData(final int index) {
+        return getBlockDataFromRaw(this.getRaw(index));
+    }
+
+    public void clear() {
+        this.size = 0;
+        this.map.clear();
+    }
+
+    public LongIterator getRawIterator() {
+        return this.map.values().iterator();
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/math/IntegerUtil.java b/src/main/java/com/destroystokyo/paper/util/math/IntegerUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..c3b936f54b3fff418c265639ef223292ccc89356
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/math/IntegerUtil.java
@@ -0,0 +1,230 @@
+package com.destroystokyo.paper.util.math;
+
+/**
+ * @author Spottedleaf <Spottedleaf@users.noreply.github.com>
+ */
+public final class IntegerUtil {
+
+    public static final int HIGH_BIT_U32 = Integer.MIN_VALUE;
+    public static final long HIGH_BIT_U64 = Long.MIN_VALUE;
+
+    public static int ceilLog2(final int value) {
+        return Integer.SIZE - Integer.numberOfLeadingZeros(value - 1); // see doc of numberOfLeadingZeros
+    }
+
+    public static long ceilLog2(final long value) {
+        return Long.SIZE - Long.numberOfLeadingZeros(value - 1); // see doc of numberOfLeadingZeros
+    }
+
+    public static int floorLog2(final int value) {
+        // xor is optimized subtract for 2^n -1
+        // note that (2^n -1) - k = (2^n -1) ^ k for k <= (2^n - 1)
+        return (Integer.SIZE - 1) ^ Integer.numberOfLeadingZeros(value); // see doc of numberOfLeadingZeros
+    }
+
+    public static int floorLog2(final long value) {
+        // xor is optimized subtract for 2^n -1
+        // note that (2^n -1) - k = (2^n -1) ^ k for k <= (2^n - 1)
+        return (Long.SIZE - 1) ^ Long.numberOfLeadingZeros(value); // see doc of numberOfLeadingZeros
+    }
+
+    public static int roundCeilLog2(final int value) {
+        // optimized variant of 1 << (32 - leading(val - 1))
+        // given
+        // 1 << n = HIGH_BIT_32 >>> (31 - n) for n [0, 32)
+        // 1 << (32 - leading(val - 1)) = HIGH_BIT_32 >>> (31 - (32 - leading(val - 1)))
+        // HIGH_BIT_32 >>> (31 - (32 - leading(val - 1)))
+        // HIGH_BIT_32 >>> (31 - 32 + leading(val - 1))
+        // HIGH_BIT_32 >>> (-1 + leading(val - 1))
+        return HIGH_BIT_U32 >>> (Integer.numberOfLeadingZeros(value - 1) - 1);
+    }
+
+    public static long roundCeilLog2(final long value) {
+        // see logic documented above
+        return HIGH_BIT_U64 >>> (Long.numberOfLeadingZeros(value - 1) - 1);
+    }
+
+    public static int roundFloorLog2(final int value) {
+        // optimized variant of 1 << (31 - leading(val))
+        // given
+        // 1 << n = HIGH_BIT_32 >>> (31 - n) for n [0, 32)
+        // 1 << (31 - leading(val)) = HIGH_BIT_32 >> (31 - (31 - leading(val)))
+        // HIGH_BIT_32 >> (31 - (31 - leading(val)))
+        // HIGH_BIT_32 >> (31 - 31 + leading(val))
+        return HIGH_BIT_U32 >>> Integer.numberOfLeadingZeros(value);
+    }
+
+    public static long roundFloorLog2(final long value) {
+        // see logic documented above
+        return HIGH_BIT_U64 >>> Long.numberOfLeadingZeros(value);
+    }
+
+    public static boolean isPowerOfTwo(final int n) {
+        // 2^n has one bit
+        // note: this rets true for 0 still
+        return IntegerUtil.getTrailingBit(n) == n;
+    }
+
+    public static boolean isPowerOfTwo(final long n) {
+        // 2^n has one bit
+        // note: this rets true for 0 still
+        return IntegerUtil.getTrailingBit(n) == n;
+    }
+
+
+    public static int getTrailingBit(final int n) {
+        return -n & n;
+    }
+
+    public static long getTrailingBit(final long n) {
+        return -n & n;
+    }
+
+    public static int trailingZeros(final int n) {
+        return Integer.numberOfTrailingZeros(n);
+    }
+
+    public static long trailingZeros(final long n) {
+        return Long.numberOfTrailingZeros(n);
+    }
+
+    // from hacker's delight (signed division magic value)
+    public static int getDivisorMultiple(final long numbers) {
+        return (int)(numbers >>> 32);
+    }
+
+    // from hacker's delight (signed division magic value)
+    public static int getDivisorShift(final long numbers) {
+        return (int)numbers;
+    }
+
+    // copied from hacker's delight (signed division magic value)
+    // http://www.hackersdelight.org/hdcodetxt/magic.c.txt
+    public static long getDivisorNumbers(final int d) {
+        final int ad = IntegerUtil.branchlessAbs(d);
+
+        if (ad < 2) {
+            throw new IllegalArgumentException("|number| must be in [2, 2^31 -1], not: " + d);
+        }
+
+        final int two31 = 0x80000000;
+        final long mask = 0xFFFFFFFFL; // mask for enforcing unsigned behaviour
+
+        int p = 31;
+
+        // all these variables are UNSIGNED!
+        int t = two31 + (d >>> 31);
+        int anc = t - 1 - t%ad;
+        int q1 = (int)((two31 & mask)/(anc & mask));
+        int r1 = two31 - q1*anc;
+        int q2 = (int)((two31 & mask)/(ad & mask));
+        int r2 = two31 - q2*ad;
+        int delta;
+
+        do {
+            p = p + 1;
+            q1 = 2*q1;                        // Update q1 = 2**p/|nc|.
+            r1 = 2*r1;                        // Update r1 = rem(2**p, |nc|).
+            if ((r1 & mask) >= (anc & mask)) {// (Must be an unsigned comparison here)
+                q1 = q1 + 1;
+                r1 = r1 - anc;
+            }
+            q2 = 2*q2;                       // Update q2 = 2**p/|d|.
+            r2 = 2*r2;                       // Update r2 = rem(2**p, |d|).
+            if ((r2 & mask) >= (ad & mask)) {// (Must be an unsigned comparison here)
+                q2 = q2 + 1;
+                r2 = r2 - ad;
+            }
+            delta = ad - r2;
+        } while ((q1 & mask) < (delta & mask) || (q1 == delta && r1 == 0));
+
+        int magicNum = q2 + 1;
+        if (d < 0) {
+            magicNum = -magicNum;
+        }
+        int shift = p - 32;
+        return ((long)magicNum << 32) | shift;
+    }
+
+    public static int branchlessAbs(final int val) {
+        // -n = -1 ^ n + 1
+        final int mask = val >> (Integer.SIZE - 1); // -1 if < 0, 0 if >= 0
+        return (mask ^ val) - mask; // if val < 0, then (0 ^ val) - 0 else (-1 ^ val) + 1
+    }
+
+    public static long branchlessAbs(final long val) {
+        // -n = -1 ^ n + 1
+        final long mask = val >> (Long.SIZE - 1); // -1 if < 0, 0 if >= 0
+        return (mask ^ val) - mask; // if val < 0, then (0 ^ val) - 0 else (-1 ^ val) + 1
+    }
+
+    //https://github.com/skeeto/hash-prospector for hash functions
+
+    //score = ~590.47984224483832
+    public static int hash0(int x) {
+        x *= 0x36935555;
+        x ^= x >>> 16;
+        return x;
+    }
+
+    //score = ~310.01596637036749
+    public static int hash1(int x) {
+        x ^= x >>> 15;
+        x *= 0x356aaaad;
+        x ^= x >>> 17;
+        return x;
+    }
+
+    public static int hash2(int x) {
+        x ^= x >>> 16;
+        x *= 0x7feb352d;
+        x ^= x >>> 15;
+        x *= 0x846ca68b;
+        x ^= x >>> 16;
+        return x;
+    }
+
+    public static int hash3(int x) {
+        x ^= x >>> 17;
+        x *= 0xed5ad4bb;
+        x ^= x >>> 11;
+        x *= 0xac4c1b51;
+        x ^= x >>> 15;
+        x *= 0x31848bab;
+        x ^= x >>> 14;
+        return x;
+    }
+
+    //score = ~365.79959673201887
+    public static long hash1(long x) {
+        x ^= x >>> 27;
+        x *= 0xb24924b71d2d354bL;
+        x ^= x >>> 28;
+        return x;
+    }
+
+    //h2 hash
+    public static long hash2(long x) {
+        x ^= x >>> 32;
+        x *= 0xd6e8feb86659fd93L;
+        x ^= x >>> 32;
+        x *= 0xd6e8feb86659fd93L;
+        x ^= x >>> 32;
+        return x;
+    }
+
+    public static long hash3(long x) {
+        x ^= x >>> 45;
+        x *= 0xc161abe5704b6c79L;
+        x ^= x >>> 41;
+        x *= 0xe3e5389aedbc90f7L;
+        x ^= x >>> 56;
+        x *= 0x1f9aba75a52db073L;
+        x ^= x >>> 53;
+        return x;
+    }
+
+    private IntegerUtil() {
+        throw new RuntimeException();
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..f86c314c5501faa7c3d60ef38acc6ebb35555c7f
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
@@ -0,0 +1,453 @@
+package com.destroystokyo.paper.util.misc;
+
+import com.destroystokyo.paper.util.math.IntegerUtil;
+import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.util.math.ChunkPos;
+import javax.annotation.Nullable;
+import java.util.Iterator;
+
+/** @author Spottedleaf */
+public abstract class AreaMap<E> {
+
+    /* Tested via https://gist.github.com/Spottedleaf/520419c6f41ef348fe9926ce674b7217 */
+
+    protected final Object2LongOpenHashMap<E> objectToLastCoordinate = new Object2LongOpenHashMap<>();
+    protected final Object2IntOpenHashMap<E> objectToViewDistance = new Object2IntOpenHashMap<>();
+
+    {
+        this.objectToViewDistance.defaultReturnValue(-1);
+        this.objectToLastCoordinate.defaultReturnValue(Long.MIN_VALUE);
+    }
+
+    // we use linked for better iteration.
+    // map of: coordinate to set of objects in coordinate
+    protected final Long2ObjectOpenHashMap<PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E>> areaMap = new Long2ObjectOpenHashMap<>(1024, 0.7f);
+    protected final PooledLinkedHashSets<E> pooledHashSets;
+
+    protected final ChangeCallback<E> addCallback;
+    protected final ChangeCallback<E> removeCallback;
+    protected final ChangeSourceCallback<E> changeSourceCallback;
+
+    public AreaMap() {
+        this(new PooledLinkedHashSets<>());
+    }
+
+    // let users define a "global" or "shared" pooled sets if they wish
+    public AreaMap(final PooledLinkedHashSets<E> pooledHashSets) {
+        this(pooledHashSets, null, null);
+    }
+
+    public AreaMap(final PooledLinkedHashSets<E> pooledHashSets, final ChangeCallback<E> addCallback, final ChangeCallback<E> removeCallback) {
+        this(pooledHashSets, addCallback, removeCallback, null);
+    }
+    public AreaMap(final PooledLinkedHashSets<E> pooledHashSets, final ChangeCallback<E> addCallback, final ChangeCallback<E> removeCallback, final ChangeSourceCallback<E> changeSourceCallback) {
+        this.pooledHashSets = pooledHashSets;
+        this.addCallback = addCallback;
+        this.removeCallback = removeCallback;
+        this.changeSourceCallback = changeSourceCallback;
+    }
+
+    @Nullable
+    public final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> getObjectsInRange(final long key) {
+        return this.areaMap.get(key);
+    }
+
+    @Nullable
+    public final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> getObjectsInRange(final ChunkPos chunkPos) {
+        return this.areaMap.get(MCUtil.getCoordinateKey(chunkPos));
+    }
+
+    @Nullable
+    public final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> getObjectsInRange(final int chunkX, final int chunkZ) {
+        return this.areaMap.get(MCUtil.getCoordinateKey(chunkX, chunkZ));
+    }
+
+    // Long.MIN_VALUE indicates the object is not mapped
+    public final long getLastCoordinate(final E object) {
+        return this.objectToLastCoordinate.getOrDefault(object, Long.MIN_VALUE);
+    }
+
+    // -1 indicates the object is not mapped
+    public final int getLastViewDistance(final E object) {
+        return this.objectToViewDistance.getOrDefault(object, -1);
+    }
+
+    // returns the total number of mapped chunks
+    public final int size() {
+        return this.areaMap.size();
+    }
+
+    public final void addOrUpdate(final E object, final int chunkX, final int chunkZ, final int viewDistance) {
+        final int oldViewDistance = this.objectToViewDistance.put(object, viewDistance);
+        final long newPos = MCUtil.getCoordinateKey(chunkX, chunkZ);
+        final long oldPos = this.objectToLastCoordinate.put(object, newPos);
+
+        if (oldViewDistance == -1) {
+            this.addObject(object, chunkX, chunkZ, Integer.MIN_VALUE, Integer.MIN_VALUE, viewDistance);
+            this.addObjectCallback(object, chunkX, chunkZ, viewDistance);
+        } else {
+            this.updateObject(object, oldPos, newPos, oldViewDistance, viewDistance);
+            this.updateObjectCallback(object, oldPos, newPos, oldViewDistance, viewDistance);
+        }
+        //this.validate(object, viewDistance);
+    }
+
+    public final boolean update(final E object, final int chunkX, final int chunkZ, final int viewDistance) {
+        final int oldViewDistance = this.objectToViewDistance.replace(object, viewDistance);
+        if (oldViewDistance == -1) {
+            return false;
+        } else {
+            final long newPos = MCUtil.getCoordinateKey(chunkX, chunkZ);
+            final long oldPos = this.objectToLastCoordinate.put(object, newPos);
+            this.updateObject(object, oldPos, newPos, oldViewDistance, viewDistance);
+            this.updateObjectCallback(object, oldPos, newPos, oldViewDistance, viewDistance);
+        }
+        //this.validate(object, viewDistance);
+        return true;
+    }
+
+    // called after the distance map updates
+    protected void updateObjectCallback(final E Object, final long oldPosition, final long newPosition, final int oldViewDistance, final int newViewDistance) {
+        if (newPosition != oldPosition && this.changeSourceCallback != null) {
+            this.changeSourceCallback.accept(Object, oldPosition, newPosition);
+        }
+    }
+
+    public final boolean add(final E object, final int chunkX, final int chunkZ, final int viewDistance) {
+        final int oldViewDistance = this.objectToViewDistance.putIfAbsent(object, viewDistance);
+        if (oldViewDistance != -1) {
+            return false;
+        }
+
+        final long newPos = MCUtil.getCoordinateKey(chunkX, chunkZ);
+        this.objectToLastCoordinate.put(object, newPos);
+        this.addObject(object, chunkX, chunkZ, Integer.MIN_VALUE, Integer.MIN_VALUE, viewDistance);
+        this.addObjectCallback(object, chunkX, chunkZ, viewDistance);
+
+        //this.validate(object, viewDistance);
+
+        return true;
+    }
+
+    // called after the distance map updates
+    protected void addObjectCallback(final E object, final int chunkX, final int chunkZ, final int viewDistance) {}
+
+    public final boolean remove(final E object) {
+        final long position = this.objectToLastCoordinate.removeLong(object);
+        final int viewDistance = this.objectToViewDistance.removeInt(object);
+
+        if (viewDistance == -1) {
+            return false;
+        }
+
+        final int currentX = MCUtil.getCoordinateX(position);
+        final int currentZ = MCUtil.getCoordinateZ(position);
+
+        this.removeObject(object, currentX, currentZ, currentX, currentZ, viewDistance);
+        this.removeObjectCallback(object, currentX, currentZ, viewDistance);
+        //this.validate(object, -1);
+        return true;
+    }
+
+    // called after the distance map updates
+    protected void removeObjectCallback(final E object, final int chunkX, final int chunkZ, final int viewDistance) {}
+
+    protected abstract PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> getEmptySetFor(final E object);
+
+    // expensive op, only for debug
+    protected void validate(final E object, final int viewDistance) {
+        int entiesGot = 0;
+        int expectedEntries = (2 * viewDistance + 1);
+        expectedEntries *= expectedEntries;
+        if (viewDistance < 0) {
+            expectedEntries = 0;
+        }
+
+        final long currPosition = this.objectToLastCoordinate.getLong(object);
+
+        final int centerX = MCUtil.getCoordinateX(currPosition);
+        final int centerZ = MCUtil.getCoordinateZ(currPosition);
+
+        for (Iterator<Long2ObjectLinkedOpenHashMap.Entry<PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E>>> iterator = this.areaMap.long2ObjectEntrySet().fastIterator();
+             iterator.hasNext();) {
+
+            final Long2ObjectLinkedOpenHashMap.Entry<PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E>> entry = iterator.next();
+            final long key = entry.getLongKey();
+            final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> map = entry.getValue();
+
+            if (map.referenceCount == 0) {
+                throw new IllegalStateException("Invalid map");
+            }
+
+            if (map.contains(object)) {
+                ++entiesGot;
+
+                final int chunkX = MCUtil.getCoordinateX(key);
+                final int chunkZ = MCUtil.getCoordinateZ(key);
+
+                final int dist = Math.max(IntegerUtil.branchlessAbs(chunkX - centerX), IntegerUtil.branchlessAbs(chunkZ - centerZ));
+
+                if (dist > viewDistance) {
+                    throw new IllegalStateException("Expected view distance " + viewDistance + ", got " + dist);
+                }
+            }
+        }
+
+        if (entiesGot != expectedEntries) {
+            throw new IllegalStateException("Expected " + expectedEntries + ", got " + entiesGot);
+        }
+    }
+
+    private void addObjectTo(final E object, final int chunkX, final int chunkZ, final int currChunkX,
+                             final int currChunkZ, final int prevChunkX, final int prevChunkZ) {
+        final long key = MCUtil.getCoordinateKey(chunkX, chunkZ);
+
+        PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> empty = this.getEmptySetFor(object);
+        PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> current = this.areaMap.putIfAbsent(key, empty);
+
+        if (current != null) {
+            PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> next = this.pooledHashSets.findMapWith(current, object);
+            if (next == current) {
+                throw new IllegalStateException("Expected different map: got " + next.toString());
+            }
+            this.areaMap.put(key, next);
+
+            current = next;
+            // fall through to callback
+        } else {
+            current = empty;
+        }
+
+        if (this.addCallback != null) {
+            try {
+                this.addCallback.accept(object, chunkX, chunkZ, currChunkX, currChunkZ, prevChunkX, prevChunkZ, current);
+            } catch (final Throwable ex) {
+                if (ex instanceof ThreadDeath) {
+                    throw (ThreadDeath)ex;
+                }
+                MinecraftServer.field_147145_h.error("Add callback for map threw exception ", ex);
+            }
+        }
+    }
+
+    private void removeObjectFrom(final E object, final int chunkX, final int chunkZ, final int currChunkX,
+                                  final int currChunkZ, final int prevChunkX, final int prevChunkZ) {
+        final long key = MCUtil.getCoordinateKey(chunkX, chunkZ);
+
+        PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> current = this.areaMap.get(key);
+
+        if (current == null) {
+            throw new IllegalStateException("Current map may not be null for " + object + ", (" + chunkX + "," + chunkZ + ")");
+        }
+
+        PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> next = this.pooledHashSets.findMapWithout(current, object);
+
+        if (next == current) {
+            throw new IllegalStateException("Current map [" + next.toString() + "] should have contained " + object + ", (" + chunkX + "," + chunkZ + ")");
+        }
+
+        if (next != null) {
+            this.areaMap.put(key, next);
+        } else {
+            this.areaMap.remove(key);
+        }
+
+        if (this.removeCallback != null) {
+            try {
+                this.removeCallback.accept(object, chunkX, chunkZ, currChunkX, currChunkZ, prevChunkX, prevChunkZ, next);
+            } catch (final Throwable ex) {
+                if (ex instanceof ThreadDeath) {
+                    throw (ThreadDeath)ex;
+                }
+                MinecraftServer.field_147145_h.error("Remove callback for map threw exception ", ex);
+            }
+        }
+    }
+
+    private void addObject(final E object, final int chunkX, final int chunkZ, final int prevChunkX, final int prevChunkZ, final int viewDistance) {
+        final int maxX = chunkX + viewDistance;
+        final int maxZ = chunkZ + viewDistance;
+        final int minX = chunkX - viewDistance;
+        final int minZ = chunkZ - viewDistance;
+        for (int x = minX; x <= maxX; ++x) {
+            for (int z = minZ; z <= maxZ; ++z) {
+                this.addObjectTo(object, x, z, chunkX, chunkZ, prevChunkX, prevChunkZ);
+            }
+        }
+    }
+
+    private void removeObject(final E object, final int chunkX, final int chunkZ, final int currentChunkX, final int currentChunkZ, final int viewDistance) {
+        final int maxX = chunkX + viewDistance;
+        final int maxZ = chunkZ + viewDistance;
+        final int minX = chunkX - viewDistance;
+        final int minZ = chunkZ - viewDistance;
+        for (int x = minX; x <= maxX; ++x) {
+            for (int z = minZ; z <= maxZ; ++z) {
+                this.removeObjectFrom(object, x, z, currentChunkX, currentChunkZ, chunkX, chunkZ);
+            }
+        }
+    }
+
+    /* math sign function except 0 returns 1 */
+    protected static int sign(int val) {
+        return 1 | (val >> (Integer.SIZE - 1));
+    }
+
+    private void updateObject(final E object, final long oldPosition, final long newPosition, final int oldViewDistance, final int newViewDistance) {
+        final int toX = MCUtil.getCoordinateX(newPosition);
+        final int toZ = MCUtil.getCoordinateZ(newPosition);
+        final int fromX = MCUtil.getCoordinateX(oldPosition);
+        final int fromZ = MCUtil.getCoordinateZ(oldPosition);
+
+        final int dx = toX - fromX;
+        final int dz = toZ - fromZ;
+
+        final int totalX = IntegerUtil.branchlessAbs(fromX - toX);
+        final int totalZ = IntegerUtil.branchlessAbs(fromZ - toZ);
+
+        if (Math.max(totalX, totalZ) > (2 * Math.max(newViewDistance, oldViewDistance))) {
+            // teleported?
+            this.removeObject(object, fromX, fromZ, fromX, fromZ, oldViewDistance);
+            this.addObject(object, toX, toZ, fromX, fromZ, newViewDistance);
+            return;
+        }
+
+        if (oldViewDistance != newViewDistance) {
+            // remove loop
+
+            final int oldMinX = fromX - oldViewDistance;
+            final int oldMinZ = fromZ - oldViewDistance;
+            final int oldMaxX = fromX + oldViewDistance;
+            final int oldMaxZ = fromZ + oldViewDistance;
+            for (int currX = oldMinX; currX <= oldMaxX; ++currX) {
+                for (int currZ = oldMinZ; currZ <= oldMaxZ; ++currZ) {
+
+                    // only remove if we're outside the new view distance...
+                    if (Math.max(IntegerUtil.branchlessAbs(currX - toX), IntegerUtil.branchlessAbs(currZ - toZ)) > newViewDistance) {
+                        this.removeObjectFrom(object, currX, currZ, toX, toZ, fromX, fromZ);
+                    }
+                }
+            }
+
+            // add loop
+
+            final int newMinX = toX - newViewDistance;
+            final int newMinZ = toZ - newViewDistance;
+            final int newMaxX = toX + newViewDistance;
+            final int newMaxZ = toZ + newViewDistance;
+            for (int currX = newMinX; currX <= newMaxX; ++currX) {
+                for (int currZ = newMinZ; currZ <= newMaxZ; ++currZ) {
+
+                    // only add if we're outside the old view distance...
+                    if (Math.max(IntegerUtil.branchlessAbs(currX - fromX), IntegerUtil.branchlessAbs(currZ - fromZ)) > oldViewDistance) {
+                        this.addObjectTo(object, currX, currZ, toX, toZ, fromX, fromZ);
+                    }
+                }
+            }
+
+            return;
+        }
+
+        // x axis is width
+        // z axis is height
+        // right refers to the x axis of where we moved
+        // top refers to the z axis of where we moved
+
+        // same view distance
+
+        // used for relative positioning
+        final int up = sign(dz); // 1 if dz >= 0, -1 otherwise
+        final int right = sign(dx); // 1 if dx >= 0, -1 otherwise
+
+        // The area excluded by overlapping the two view distance squares creates four rectangles:
+        // Two on the left, and two on the right. The ones on the left we consider the "removed" section
+        // and on the right the "added" section.
+        // https://i.imgur.com/MrnOBgI.png is a reference image. Note that the outside border is not actually
+        // exclusive to the regions they surround.
+
+        // 4 points of the rectangle
+        int maxX; // exclusive
+        int minX; // inclusive
+        int maxZ; // exclusive
+        int minZ; // inclusive
+
+        if (dx != 0) {
+            // handle right addition
+
+            maxX = toX + (oldViewDistance * right) + right; // exclusive
+            minX = fromX + (oldViewDistance * right) + right; // inclusive
+            maxZ = fromZ + (oldViewDistance * up) + up; // exclusive
+            minZ = toZ - (oldViewDistance * up); // inclusive
+
+            for (int currX = minX; currX != maxX; currX += right) {
+                for (int currZ = minZ; currZ != maxZ; currZ += up) {
+                    this.addObjectTo(object, currX, currZ, toX, toZ, fromX, fromZ);
+                }
+            }
+        }
+
+        if (dz != 0) {
+            // handle up addition
+
+            maxX = toX + (oldViewDistance * right) + right; // exclusive
+            minX = toX - (oldViewDistance * right); // inclusive
+            maxZ = toZ + (oldViewDistance * up) + up; // exclusive
+            minZ = fromZ + (oldViewDistance * up) + up; // inclusive
+
+            for (int currX = minX; currX != maxX; currX += right) {
+                for (int currZ = minZ; currZ != maxZ; currZ += up) {
+                    this.addObjectTo(object, currX, currZ, toX, toZ, fromX, fromZ);
+                }
+            }
+        }
+
+        if (dx != 0) {
+            // handle left removal
+
+            maxX = toX - (oldViewDistance * right); // exclusive
+            minX = fromX - (oldViewDistance * right); // inclusive
+            maxZ = fromZ + (oldViewDistance * up) + up; // exclusive
+            minZ = toZ - (oldViewDistance * up); // inclusive
+
+            for (int currX = minX; currX != maxX; currX += right) {
+                for (int currZ = minZ; currZ != maxZ; currZ += up) {
+                    this.removeObjectFrom(object, currX, currZ, toX, toZ, fromX, fromZ);
+                }
+            }
+        }
+
+        if (dz != 0) {
+            // handle down removal
+
+            maxX = fromX + (oldViewDistance * right) + right; // exclusive
+            minX = fromX - (oldViewDistance * right); // inclusive
+            maxZ = toZ - (oldViewDistance * up); // exclusive
+            minZ = fromZ - (oldViewDistance * up); // inclusive
+
+            for (int currX = minX; currX != maxX; currX += right) {
+                for (int currZ = minZ; currZ != maxZ; currZ += up) {
+                    this.removeObjectFrom(object, currX, currZ, toX, toZ, fromX, fromZ);
+                }
+            }
+        }
+    }
+
+    @FunctionalInterface
+    public static interface ChangeCallback<E> {
+
+        // if there is no previous position, then prevPos = Integer.MIN_VALUE
+        void accept(final E object, final int rangeX, final int rangeZ, final int currPosX, final int currPosZ, final int prevPosX, final int prevPosZ,
+                    final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> newState);
+
+    }
+
+    @FunctionalInterface
+    public static interface ChangeSourceCallback<E> {
+        void accept(final E object, final long prevPos, final long newPos);
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/DistanceTrackingAreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/DistanceTrackingAreaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..c1ac604afd9bed239d0dfc3f0c40bfacb0e76841
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/misc/DistanceTrackingAreaMap.java
@@ -0,0 +1,175 @@
+package com.destroystokyo.paper.util.misc;
+
+import com.destroystokyo.paper.util.math.IntegerUtil;
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
+import net.minecraft.server.MCUtil;
+import net.minecraft.util.math.ChunkPos;
+
+/** @author Spottedleaf */
+public abstract class DistanceTrackingAreaMap<E> extends AreaMap<E> {
+
+    // use this map only if you need distance tracking, the tracking here is obviously going to hit harder.
+
+    protected final Long2IntOpenHashMap chunkToNearestDistance = new Long2IntOpenHashMap(1024, 0.7f);
+    {
+        this.chunkToNearestDistance.defaultReturnValue(-1);
+    }
+
+    protected final DistanceChangeCallback<E> distanceChangeCallback;
+
+    public DistanceTrackingAreaMap() {
+        this(new PooledLinkedHashSets<>());
+    }
+
+    // let users define a "global" or "shared" pooled sets if they wish
+    public DistanceTrackingAreaMap(final PooledLinkedHashSets<E> pooledHashSets) {
+        this(pooledHashSets, null, null, null);
+    }
+
+    public DistanceTrackingAreaMap(final PooledLinkedHashSets<E> pooledHashSets, final ChangeCallback<E> addCallback, final ChangeCallback<E> removeCallback,
+                                   final DistanceChangeCallback<E> distanceChangeCallback) {
+        super(pooledHashSets, addCallback, removeCallback);
+        this.distanceChangeCallback = distanceChangeCallback;
+    }
+
+    // ret -1 if there is nothing mapped
+    public final int getNearestObjectDistance(final long key) {
+        return this.chunkToNearestDistance.get(key);
+    }
+
+    // ret -1 if there is nothing mapped
+    public final int getNearestObjectDistance(final ChunkPos chunkPos) {
+        return this.chunkToNearestDistance.get(MCUtil.getCoordinateKey(chunkPos));
+    }
+
+    // ret -1 if there is nothing mapped
+    public final int getNearestObjectDistance(final int chunkX, final int chunkZ) {
+        return this.chunkToNearestDistance.get(MCUtil.getCoordinateKey(chunkX, chunkZ));
+    }
+
+    protected final void recalculateDistance(final int chunkX, final int chunkZ) {
+        final long key = MCUtil.getCoordinateKey(chunkX, chunkZ);
+        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> state = this.areaMap.get(key);
+        if (state == null) {
+            final int oldDistance = this.chunkToNearestDistance.remove(key);
+            // nothing here.
+            if (oldDistance == -1) {
+                // nothing was here previously
+                return;
+            }
+            if (this.distanceChangeCallback != null) {
+                this.distanceChangeCallback.accept(chunkX, chunkZ, oldDistance, -1, null);
+            }
+            return;
+        }
+
+        int newDistance = Integer.MAX_VALUE;
+
+        final Object[] rawData = state.getBackingSet();
+        for (int i = 0, len = rawData.length; i < len; ++i) {
+            final Object raw = rawData[i];
+
+            if (raw == null) {
+                continue;
+            }
+
+            final E object = (E)raw;
+            final long location = this.objectToLastCoordinate.getLong(object);
+
+            final int distance = Math.max(IntegerUtil.branchlessAbs(chunkX - MCUtil.getCoordinateX(location)), IntegerUtil.branchlessAbs(chunkZ - MCUtil.getCoordinateZ(location)));
+
+            if (distance < newDistance) {
+                newDistance = distance;
+            }
+        }
+
+        final int oldDistance = this.chunkToNearestDistance.put(key, newDistance);
+
+        if (oldDistance != newDistance) {
+            if (this.distanceChangeCallback != null) {
+                this.distanceChangeCallback.accept(chunkX, chunkZ, oldDistance, newDistance, state);
+            }
+        }
+    }
+
+    @Override
+    protected void addObjectCallback(final E object, final int chunkX, final int chunkZ, final int viewDistance) {
+        final int maxX = chunkX + viewDistance;
+        final int maxZ = chunkZ + viewDistance;
+        final int minX = chunkX - viewDistance;
+        final int minZ = chunkZ - viewDistance;
+        for (int x = minX; x <= maxX; ++x) {
+            for (int z = minZ; z <= maxZ; ++z) {
+                this.recalculateDistance(x, z);
+            }
+        }
+    }
+
+    @Override
+    protected void removeObjectCallback(final E object, final int chunkX, final int chunkZ, final int viewDistance) {
+        final int maxX = chunkX + viewDistance;
+        final int maxZ = chunkZ + viewDistance;
+        final int minX = chunkX - viewDistance;
+        final int minZ = chunkZ - viewDistance;
+        for (int x = minX; x <= maxX; ++x) {
+            for (int z = minZ; z <= maxZ; ++z) {
+                this.recalculateDistance(x, z);
+            }
+        }
+    }
+
+    @Override
+    protected void updateObjectCallback(final E object, final long oldPosition, final long newPosition, final int oldViewDistance, final int newViewDistance) {
+        if (oldPosition == newPosition && newViewDistance == oldViewDistance) {
+            return;
+        }
+
+        final int toX = MCUtil.getCoordinateX(newPosition);
+        final int toZ = MCUtil.getCoordinateZ(newPosition);
+        final int fromX = MCUtil.getCoordinateX(oldPosition);
+        final int fromZ = MCUtil.getCoordinateZ(oldPosition);
+
+        final int totalX = IntegerUtil.branchlessAbs(fromX - toX);
+        final int totalZ = IntegerUtil.branchlessAbs(fromZ - toZ);
+
+        if (Math.max(totalX, totalZ) > (2 * Math.max(newViewDistance, oldViewDistance))) {
+            // teleported?
+            this.removeObjectCallback(object, fromX, fromZ, oldViewDistance);
+            this.addObjectCallback(object, toX, toZ, newViewDistance);
+            return;
+        }
+
+        final int minX = Math.min(fromX - oldViewDistance, toX - newViewDistance);
+        final int maxX = Math.max(fromX + oldViewDistance, toX + newViewDistance);
+        final int minZ = Math.min(fromZ - oldViewDistance, toZ - newViewDistance);
+        final int maxZ = Math.max(fromZ + oldViewDistance, toZ + newViewDistance);
+
+        for (int x = minX; x <= maxX; ++x) {
+            for (int z = minZ; z <= maxZ; ++z) {
+                final int distXOld = IntegerUtil.branchlessAbs(x - fromX);
+                final int distZOld = IntegerUtil.branchlessAbs(z - fromZ);
+
+                if (Math.max(distXOld, distZOld) <= oldViewDistance) {
+                    this.recalculateDistance(x, z);
+                    continue;
+                }
+
+                final int distXNew = IntegerUtil.branchlessAbs(x - toX);
+                final int distZNew = IntegerUtil.branchlessAbs(z - toZ);
+
+                if (Math.max(distXNew, distZNew) <= newViewDistance) {
+                    this.recalculateDistance(x, z);
+                    continue;
+                }
+            }
+        }
+    }
+
+    @FunctionalInterface
+    public static interface DistanceChangeCallback<E> {
+
+        void accept(final int posX, final int posZ, final int oldNearestDistance, final int newNearestDistance,
+                    final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> state);
+
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..0e957f42b6549d4572fe0f791f763adcd62e8307
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/misc/PlayerAreaMap.java
@@ -0,0 +1,32 @@
+package com.destroystokyo.paper.util.misc;
+
+import net.minecraft.entity.player.ServerPlayerEntity;
+
+/**
+ * @author Spottedleaf
+ */
+public final class PlayerAreaMap extends AreaMap<ServerPlayerEntity> {
+
+    public PlayerAreaMap() {
+        super();
+    }
+
+    public PlayerAreaMap(final PooledLinkedHashSets<ServerPlayerEntity> pooledHashSets) {
+        super(pooledHashSets);
+    }
+
+    public PlayerAreaMap(final PooledLinkedHashSets<ServerPlayerEntity> pooledHashSets, final ChangeCallback<ServerPlayerEntity> addCallback,
+                         final ChangeCallback<ServerPlayerEntity> removeCallback) {
+        this(pooledHashSets, addCallback, removeCallback, null);
+    }
+
+    public PlayerAreaMap(final PooledLinkedHashSets<ServerPlayerEntity> pooledHashSets, final ChangeCallback<ServerPlayerEntity> addCallback,
+                         final ChangeCallback<ServerPlayerEntity> removeCallback, final ChangeSourceCallback<ServerPlayerEntity> changeSourceCallback) {
+        super(pooledHashSets, addCallback, removeCallback, changeSourceCallback);
+    }
+
+    @Override
+    protected PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> getEmptySetFor(final ServerPlayerEntity player) {
+        return player.cachedSingleHashSet;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/PlayerDistanceTrackingAreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/PlayerDistanceTrackingAreaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..1cef15e5482641da12b8c2be03ace73f6b590715
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/misc/PlayerDistanceTrackingAreaMap.java
@@ -0,0 +1,24 @@
+package com.destroystokyo.paper.util.misc;
+
+import net.minecraft.entity.player.ServerPlayerEntity;
+
+public class PlayerDistanceTrackingAreaMap extends DistanceTrackingAreaMap<ServerPlayerEntity> {
+
+    public PlayerDistanceTrackingAreaMap() {
+        super();
+    }
+
+    public PlayerDistanceTrackingAreaMap(final PooledLinkedHashSets<ServerPlayerEntity> pooledHashSets) {
+        super(pooledHashSets);
+    }
+
+    public PlayerDistanceTrackingAreaMap(final PooledLinkedHashSets<ServerPlayerEntity> pooledHashSets, final ChangeCallback<ServerPlayerEntity> addCallback,
+                                         final ChangeCallback<ServerPlayerEntity> removeCallback, final DistanceChangeCallback<ServerPlayerEntity> distanceChangeCallback) {
+        super(pooledHashSets, addCallback, removeCallback, distanceChangeCallback);
+    }
+
+    @Override
+    protected PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> getEmptySetFor(final ServerPlayerEntity player) {
+        return player.cachedSingleHashSet;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java b/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java
new file mode 100644
index 0000000000000000000000000000000000000000..1cada9377a55b9e1d8bf70ade3396c4c2dadce62
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java
@@ -0,0 +1,288 @@
+package com.destroystokyo.paper.util.misc;
+
+import com.destroystokyo.paper.util.misc.PooledLinkedHashSets.RawSetObjectLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
+import java.lang.ref.WeakReference;
+
+/** @author Spottedleaf */
+public class PooledLinkedHashSets<E> {
+
+    /* Tested via https://gist.github.com/Spottedleaf/a93bb7a8993d6ce142d3efc5932bf573 */
+
+    // we really want to avoid that equals() check as much as possible...
+    protected final Object2ObjectOpenHashMap<PooledObjectLinkedOpenHashSet<E>, PooledObjectLinkedOpenHashSet<E>> mapPool = new Object2ObjectOpenHashMap<>(128, 0.25f);
+
+    protected void decrementReferenceCount(final PooledObjectLinkedOpenHashSet<E> current) {
+        if (current.referenceCount == 0) {
+            throw new IllegalStateException("Cannot decrement reference count for " + current);
+        }
+        if (current.referenceCount == -1 || --current.referenceCount > 0) {
+            return;
+        }
+
+        this.mapPool.remove(current);
+        return;
+    }
+
+    public PooledObjectLinkedOpenHashSet<E> findMapWith(final PooledObjectLinkedOpenHashSet<E> current, final E object) {
+        final PooledObjectLinkedOpenHashSet<E> cached = current.getAddCache(object);
+
+        if (cached != null) {
+            decrementReferenceCount(current);
+
+            if (cached.referenceCount == 0) {
+                // bring the map back from the dead
+                PooledObjectLinkedOpenHashSet<E> contending = this.mapPool.putIfAbsent(cached, cached);
+                if (contending != null) {
+                    // a map already exists with the elements we want
+                    if (contending.referenceCount != -1) {
+                        ++contending.referenceCount;
+                    }
+                    current.updateAddCache(object, contending);
+                    return contending;
+                }
+
+                cached.referenceCount = 1;
+            } else if (cached.referenceCount != -1) {
+                ++cached.referenceCount;
+            }
+
+            return cached;
+        }
+
+        if (!current.add(object)) {
+            return current;
+        }
+
+        // we use get/put since we use a different key on put
+        PooledObjectLinkedOpenHashSet<E> ret = this.mapPool.get(current);
+
+        if (ret == null) {
+            ret = new PooledObjectLinkedOpenHashSet<>(current);
+            current.remove(object);
+            this.mapPool.put(ret, ret);
+            ret.referenceCount = 1;
+        } else {
+            if (ret.referenceCount != -1) {
+                ++ret.referenceCount;
+            }
+            current.remove(object);
+        }
+
+        current.updateAddCache(object, ret);
+
+        decrementReferenceCount(current);
+        return ret;
+    }
+
+    // rets null if current.size() == 1
+    public PooledObjectLinkedOpenHashSet<E> findMapWithout(final PooledObjectLinkedOpenHashSet<E> current, final E object) {
+        if (current.set.size() == 1) {
+            decrementReferenceCount(current);
+            return null;
+        }
+
+        final PooledObjectLinkedOpenHashSet<E> cached = current.getRemoveCache(object);
+
+        if (cached != null) {
+            decrementReferenceCount(current);
+
+            if (cached.referenceCount == 0) {
+                // bring the map back from the dead
+                PooledObjectLinkedOpenHashSet<E> contending = this.mapPool.putIfAbsent(cached, cached);
+                if (contending != null) {
+                    // a map already exists with the elements we want
+                    if (contending.referenceCount != -1) {
+                        ++contending.referenceCount;
+                    }
+                    current.updateRemoveCache(object, contending);
+                    return contending;
+                }
+
+                cached.referenceCount = 1;
+            } else if (cached.referenceCount != -1) {
+                ++cached.referenceCount;
+            }
+
+            return cached;
+        }
+
+        if (!current.remove(object)) {
+            return current;
+        }
+
+        // we use get/put since we use a different key on put
+        PooledObjectLinkedOpenHashSet<E> ret = this.mapPool.get(current);
+
+        if (ret == null) {
+            ret = new PooledObjectLinkedOpenHashSet<>(current);
+            current.add(object);
+            this.mapPool.put(ret, ret);
+            ret.referenceCount = 1;
+        } else {
+            if (ret.referenceCount != -1) {
+                ++ret.referenceCount;
+            }
+            current.add(object);
+        }
+
+        current.updateRemoveCache(object, ret);
+
+        decrementReferenceCount(current);
+        return ret;
+    }
+
+    static final class RawSetObjectLinkedOpenHashSet<E> extends ObjectOpenHashSet<E> {
+
+        public RawSetObjectLinkedOpenHashSet() {
+            super();
+        }
+
+        public RawSetObjectLinkedOpenHashSet(final int capacity) {
+            super(capacity);
+        }
+
+        public RawSetObjectLinkedOpenHashSet(final int capacity, final float loadFactor) {
+            super(capacity, loadFactor);
+        }
+
+        @Override
+        public RawSetObjectLinkedOpenHashSet<E> clone() {
+            return (RawSetObjectLinkedOpenHashSet<E>)super.clone();
+        }
+
+        public E[] getRawSet() {
+            return this.key;
+        }
+    }
+
+    public static final class PooledObjectLinkedOpenHashSet<E> {
+
+        private static final WeakReference NULL_REFERENCE = new WeakReference<>(null);
+
+        final RawSetObjectLinkedOpenHashSet<E> set;
+        int referenceCount; // -1 if special
+        int hash; // optimize hashcode
+
+        // add cache
+        WeakReference<E> lastAddObject = NULL_REFERENCE;
+        WeakReference<PooledObjectLinkedOpenHashSet<E>> lastAddMap = NULL_REFERENCE;
+
+        // remove cache
+        WeakReference<E> lastRemoveObject = NULL_REFERENCE;
+        WeakReference<PooledObjectLinkedOpenHashSet<E>> lastRemoveMap = NULL_REFERENCE;
+
+        public PooledObjectLinkedOpenHashSet(final PooledLinkedHashSets<E> pooledSets) {
+            this.set = new RawSetObjectLinkedOpenHashSet<>(2, 0.8f);
+        }
+
+        public PooledObjectLinkedOpenHashSet(final E single) {
+            this((PooledLinkedHashSets<E>)null);
+            this.referenceCount = -1;
+            this.add(single);
+        }
+
+        public PooledObjectLinkedOpenHashSet(final PooledObjectLinkedOpenHashSet<E> other) {
+            this.set = other.set.clone();
+            this.hash = other.hash;
+        }
+
+        // from https://github.com/Spottedleaf/ConcurrentUtil/blob/master/src/main/java/ca/spottedleaf/concurrentutil/util/IntegerUtil.java
+        // generated by https://github.com/skeeto/hash-prospector
+        private static int hash0(int x) {
+            x *= 0x36935555;
+            x ^= x >>> 16;
+            return x;
+        }
+
+        PooledObjectLinkedOpenHashSet<E> getAddCache(final E element) {
+            final E currentAdd = this.lastAddObject.get();
+
+            if (currentAdd == null || !(currentAdd == element || currentAdd.equals(element))) {
+                return null;
+            }
+
+            return this.lastAddMap.get();
+        }
+
+        PooledObjectLinkedOpenHashSet<E> getRemoveCache(final E element) {
+            final E currentRemove = this.lastRemoveObject.get();
+
+            if (currentRemove == null || !(currentRemove == element || currentRemove.equals(element))) {
+                return null;
+            }
+
+            return this.lastRemoveMap.get();
+        }
+
+        void updateAddCache(final E element, final PooledObjectLinkedOpenHashSet<E> map) {
+            this.lastAddObject = new WeakReference<>(element);
+            this.lastAddMap = new WeakReference<>(map);
+        }
+
+        void updateRemoveCache(final E element, final PooledObjectLinkedOpenHashSet<E> map) {
+            this.lastRemoveObject = new WeakReference<>(element);
+            this.lastRemoveMap = new WeakReference<>(map);
+        }
+
+        boolean add(final E element) {
+            boolean added =  this.set.add(element);
+
+            if (added) {
+                this.hash += hash0(element.hashCode());
+            }
+
+            return added;
+        }
+
+        boolean remove(Object element) {
+            boolean removed = this.set.remove(element);
+
+            if (removed) {
+                this.hash -= hash0(element.hashCode());
+            }
+
+            return removed;
+        }
+
+        public boolean contains(final Object element) {
+            return this.set.contains(element);
+        }
+
+        public E[] getBackingSet() {
+            return this.set.getRawSet();
+        }
+
+        public int size() {
+            return this.set.size();
+        }
+
+        @Override
+        public int hashCode() {
+            return this.hash;
+        }
+
+        @Override
+        public boolean equals(final Object other) {
+            if (!(other instanceof PooledObjectLinkedOpenHashSet)) {
+                return false;
+            }
+            if (this.referenceCount == 0) {
+                return other == this;
+            } else {
+                if (other == this) {
+                    // Unfortunately we are never equal to our own instance while in use!
+                    return false;
+                }
+                return this.hash == ((PooledObjectLinkedOpenHashSet)other).hash && this.set.equals(((PooledObjectLinkedOpenHashSet)other).set);
+            }
+        }
+
+        @Override
+        public String toString() {
+            return "PooledHashSet: size: " + this.set.size() + ", reference count: " + this.referenceCount + ", hash: " +
+                this.hashCode() + ", identity: " + System.identityHashCode(this) + " map: " + this.set.toString();
+        }
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/pooled/PooledObjects.java b/src/main/java/com/destroystokyo/paper/util/pooled/PooledObjects.java
new file mode 100644
index 0000000000000000000000000000000000000000..d0c77068e9a53d1b8bbad0f3f6b420d6bc85f8c8
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/pooled/PooledObjects.java
@@ -0,0 +1,85 @@
+package com.destroystokyo.paper.util.pooled;
+
+import net.minecraft.server.MCUtil;
+import org.apache.commons.lang3.mutable.MutableInt;
+
+import java.util.ArrayDeque;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+
+public final class PooledObjects<E> {
+
+    /**
+     * Wrapper for an object that will be have a cleaner registered for it, and may be automatically returned to pool.
+     */
+    public class AutoReleased {
+        private final E object;
+        private final Runnable cleaner;
+
+        public AutoReleased(E object, Runnable cleaner) {
+            this.object = object;
+            this.cleaner = cleaner;
+        }
+
+        public final E getObject() {
+            return object;
+        }
+
+        public final Runnable getCleaner() {
+            return cleaner;
+        }
+    }
+
+    public static final PooledObjects<MutableInt> POOLED_MUTABLE_INTEGERS = new PooledObjects<>(MutableInt::new, 1024);
+
+    private final Supplier<E> creator;
+    private final Consumer<E> releaser;
+    private final int maxPoolSize;
+    private final ArrayDeque<E> queue;
+
+    public PooledObjects(final Supplier<E> creator, int maxPoolSize) {
+        this(creator, maxPoolSize, null);
+    }
+    public PooledObjects(final Supplier<E> creator, int maxPoolSize, Consumer<E> releaser) {
+        if (creator == null) {
+            throw new NullPointerException("Creator must not be null");
+        }
+        if (maxPoolSize <= 0) {
+            throw new IllegalArgumentException("Max pool size must be greater-than 0");
+        }
+
+        this.queue = new ArrayDeque<>(maxPoolSize);
+        this.maxPoolSize = maxPoolSize;
+        this.creator = creator;
+        this.releaser = releaser;
+    }
+
+    public AutoReleased acquireCleaner(Object holder) {
+        return acquireCleaner(holder, this::release);
+    }
+
+    public AutoReleased acquireCleaner(Object holder, Consumer<E> releaser) {
+        E resource = acquire();
+        Runnable cleaner = MCUtil.registerCleaner(holder, resource, releaser);
+        return new AutoReleased(resource, cleaner);
+    }
+
+    public final E acquire() {
+        E value;
+        synchronized (queue) {
+            value = this.queue.pollLast();
+        }
+        return value != null ? value : this.creator.get();
+    }
+
+    public final void release(final E value) {
+        if (this.releaser != null) {
+            this.releaser.accept(value);
+        }
+        synchronized (this.queue) {
+            if (queue.size() < this.maxPoolSize) {
+                this.queue.addLast(value);
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/set/OptimizedSmallEnumSet.java b/src/main/java/com/destroystokyo/paper/util/set/OptimizedSmallEnumSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..9df0006c1a283f77c4d01d9fce9062fc1c9bbb1f
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/set/OptimizedSmallEnumSet.java
@@ -0,0 +1,67 @@
+package com.destroystokyo.paper.util.set;
+
+import java.util.Collection;
+
+/**
+ * @author Spottedleaf <Spottedleaf@users.noreply.github.com>
+ */
+public final class OptimizedSmallEnumSet<E extends Enum<E>> {
+
+    private final Class<E> enumClass;
+    private long backingSet;
+
+    public OptimizedSmallEnumSet(final Class<E> clazz) {
+        if (clazz == null) {
+            throw new IllegalArgumentException("Null class");
+        }
+        if (!clazz.isEnum()) {
+            throw new IllegalArgumentException("Class must be enum, not " + clazz.getCanonicalName());
+        }
+        this.enumClass = clazz;
+    }
+
+    public boolean addUnchecked(final E element) {
+        final int ordinal = element.ordinal();
+        final long key = 1L << ordinal;
+
+        final long prev = this.backingSet;
+        this.backingSet = prev | key;
+
+        return (prev & key) == 0;
+    }
+
+    public boolean removeUnchecked(final E element) {
+        final int ordinal = element.ordinal();
+        final long key = 1L << ordinal;
+
+        final long prev = this.backingSet;
+        this.backingSet = prev & ~key;
+
+        return (prev & key) != 0;
+    }
+
+    public void clear() {
+        this.backingSet = 0L;
+    }
+
+    public int size() {
+        return Long.bitCount(this.backingSet);
+    }
+
+    public void addAllUnchecked(final Collection<E> enums) {
+        for (final E element : enums) {
+            if (element == null) {
+                throw new NullPointerException("Null element");
+            }
+            this.backingSet |= (1L << element.ordinal());
+        }
+    }
+
+    public long getBackingSet() {
+        return this.backingSet;
+    }
+
+    public boolean hasCommonElements(final OptimizedSmallEnumSet<E> other) {
+        return (other.backingSet & this.backingSet) != 0;
+    }
+}
diff --git a/src/main/java/net/minecraft/block/AbstractBlock.java b/src/main/java/net/minecraft/block/AbstractBlock.java
index d887d4fa6161fa316962f7e2d378f6742e9653b8..ece3d5b055b034ab3d00fbd3bf67d69e9aa2377e 100644
--- a/src/main/java/net/minecraft/block/AbstractBlock.java
+++ b/src/main/java/net/minecraft/block/AbstractBlock.java
@@ -679,6 +679,7 @@ public abstract class AbstractBlock {
             return this.field_215707_c != null ? this.field_215707_c.field_225494_j : Block.func_208062_a(this.func_196952_d(p_235785_1_, p_235785_2_));
         }
 
+        public final BlockState getBlockData() { return func_230340_p_(); } // Paper - OBFHELPER
         protected abstract BlockState func_230340_p_();
 
         public boolean func_235783_q_() {
diff --git a/src/main/java/net/minecraft/entity/CreatureEntity.java b/src/main/java/net/minecraft/entity/CreatureEntity.java
index 223264ff477379e518dbf03c18198781f6447678..0f958674e20ea61a55156ea8c86e2ee36c56f0bb 100644
--- a/src/main/java/net/minecraft/entity/CreatureEntity.java
+++ b/src/main/java/net/minecraft/entity/CreatureEntity.java
@@ -13,6 +13,8 @@ import org.bukkit.event.entity.EntityUnleashEvent;
 
 public abstract class CreatureEntity extends MobEntity {
 
+    public org.bukkit.craftbukkit.entity.CraftCreature getBukkitCreature() { return (org.bukkit.craftbukkit.entity.CraftCreature) super.getBukkitEntity(); } // Paper
+
     protected CreatureEntity(EntityType<? extends CreatureEntity> entitytypes, World world) {
         super(entitytypes, world);
     }
diff --git a/src/main/java/net/minecraft/entity/Entity.java b/src/main/java/net/minecraft/entity/Entity.java
index 6dfeb6bc1acceee011c8113d7e63672968d665e1..8013b212307dfdf0a68ad75f39f88d8871007082 100644
--- a/src/main/java/net/minecraft/entity/Entity.java
+++ b/src/main/java/net/minecraft/entity/Entity.java
@@ -1070,8 +1070,9 @@ public abstract class Entity implements INameable, ICommandSource {
 
     }
 
-    @Nullable
-    public AxisAlignedBB func_70046_E() {
+
+    @Nullable public final AxisAlignedBB getCollisionBox(){return func_70046_E();} //Paper - OBFHELPER
+    @Nullable public AxisAlignedBB func_70046_E() {
         return null;
     }
 
@@ -1861,6 +1862,7 @@ public abstract class Entity implements INameable, ICommandSource {
         return ActionResultType.PASS;
     }
 
+    public final AxisAlignedBB getHardCollisionBox(Entity entity){ return func_70114_g(entity);}//Paper - OBFHELPER
     @Nullable
     public AxisAlignedBB func_70114_g(Entity p_70114_1_) {
         return null;
diff --git a/src/main/java/net/minecraft/entity/EntityType.java b/src/main/java/net/minecraft/entity/EntityType.java
index 384f251ed01f8f8e303a2aade36d2cd3a2c561b7..9777305a298659ad6a3314b73fe66b5e4c0277ae 100644
--- a/src/main/java/net/minecraft/entity/EntityType.java
+++ b/src/main/java/net/minecraft/entity/EntityType.java
@@ -3,6 +3,7 @@ package net.minecraft.entity;
 import com.google.common.collect.ImmutableSet;
 import java.util.Optional;
 import java.util.Set; // Paper
+import java.util.Map; // Paper
 import java.util.UUID;
 import java.util.function.Function;
 import java.util.stream.Stream;
@@ -435,8 +436,8 @@ public class EntityType<T extends Entity> {
         return this.field_220359_bi.field_220316_b;
     }
 
-    @Nullable
-    public T func_200721_a(World p_200721_1_) {
+    public T create(World world) { return this.func_200721_a(world); } // Paper - OBFHELPER
+    @Nullable public T func_200721_a(World p_200721_1_) { // Paper - OBFHELPER
         return this.field_200732_aK.create(this, p_200721_1_);
     }
 
diff --git a/src/main/java/net/minecraft/entity/LivingEntity.java b/src/main/java/net/minecraft/entity/LivingEntity.java
index 13c81954030d1a9de2e0aefa88a83206e6a6bc4c..d09e23b183783b316fbd36e82e2e6e4abb6eea55 100644
--- a/src/main/java/net/minecraft/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/entity/LivingEntity.java
@@ -230,6 +230,7 @@ public abstract class LivingEntity extends Entity {
     public boolean collides = true;
     public Set<UUID> collidableExemptions = new HashSet<>();
     public boolean canPickUpLoot;
+    public org.bukkit.craftbukkit.entity.CraftLivingEntity getBukkitLivingEntity() { return (org.bukkit.craftbukkit.entity.CraftLivingEntity) super.getBukkitEntity(); } // Paper
 
     @Override
     public float getBukkitYaw() {
diff --git a/src/main/java/net/minecraft/entity/MobEntity.java b/src/main/java/net/minecraft/entity/MobEntity.java
index 5072341830d1a7b3d90c228b8f9cbf3f43eb1381..127a676a30731e7ae6e2baee40da8e4d1d16b154 100644
--- a/src/main/java/net/minecraft/entity/MobEntity.java
+++ b/src/main/java/net/minecraft/entity/MobEntity.java
@@ -225,6 +225,7 @@ public abstract class MobEntity extends LivingEntity {
         return this.field_70696_bz;
     }
 
+    public org.bukkit.craftbukkit.entity.CraftMob getBukkitMob() { return (org.bukkit.craftbukkit.entity.CraftMob) super.getBukkitEntity(); } // Paper
     public void func_70624_b(@Nullable LivingEntity p_70624_1_) {
         // CraftBukkit start - fire event
         setGoalTarget(p_70624_1_, EntityTargetEvent.TargetReason.UNKNOWN, true);
diff --git a/src/main/java/net/minecraft/entity/monster/MonsterEntity.java b/src/main/java/net/minecraft/entity/monster/MonsterEntity.java
index 1c2c93134d6ace46452dbab2d5dd27844fbb2615..44eddad7c8c26b196d467628839a68a3db5908b5 100644
--- a/src/main/java/net/minecraft/entity/monster/MonsterEntity.java
+++ b/src/main/java/net/minecraft/entity/monster/MonsterEntity.java
@@ -26,6 +26,7 @@ import net.minecraft.world.World;
 
 public abstract class MonsterEntity extends CreatureEntity implements IMob {
 
+    public org.bukkit.craftbukkit.entity.CraftMonster getBukkitMonster() { return (org.bukkit.craftbukkit.entity.CraftMonster) super.getBukkitEntity(); } // Paper
     protected MonsterEntity(EntityType<? extends MonsterEntity> entitytypes, World world) {
         super(entitytypes, world);
         this.field_70728_aV = 5;
diff --git a/src/main/java/net/minecraft/entity/player/PlayerInventory.java b/src/main/java/net/minecraft/entity/player/PlayerInventory.java
index 15f5aff84e5c63cc4b5471cd3ce177a6d6169e79..67c6d3ca80e3418cb118466051057ad591343aa7 100644
--- a/src/main/java/net/minecraft/entity/player/PlayerInventory.java
+++ b/src/main/java/net/minecraft/entity/player/PlayerInventory.java
@@ -37,7 +37,7 @@ public class PlayerInventory implements IInventory, INameable {
     public final NonNullList<ItemStack> field_70462_a;
     public final NonNullList<ItemStack> field_70460_b;
     public final NonNullList<ItemStack> field_184439_c;
-    private final List<NonNullList<ItemStack>> field_184440_g;
+    private final List<NonNullList<ItemStack>> field_184440_g;List<NonNullList<ItemStack>> getComponents() { return field_184440_g; } // Paper - OBFHELPER
     public int field_70461_c;
     public final PlayerEntity field_70458_d;
     private ItemStack field_70457_g;
diff --git a/src/main/java/net/minecraft/entity/player/ServerPlayerEntity.java b/src/main/java/net/minecraft/entity/player/ServerPlayerEntity.java
index 7947e2332a9b1b5a5e1e5e5ca04dca45cdb51cdd..72e6ae45d11266c61f7730572b59bbfd7a71ca15 100644
--- a/src/main/java/net/minecraft/entity/player/ServerPlayerEntity.java
+++ b/src/main/java/net/minecraft/entity/player/ServerPlayerEntity.java
@@ -212,6 +212,8 @@ public class ServerPlayerEntity extends PlayerEntity implements IContainerListen
     public Integer clientViewDistance;
     // CraftBukkit end
 
+    public final com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> cachedSingleHashSet; // Paper
+
     public ServerPlayerEntity(MinecraftServer minecraftserver, ServerWorld worldserver, GameProfile gameprofile, PlayerInteractionManager playerinteractmanager) {
         super(worldserver, worldserver.func_241135_u_(), gameprofile);
         this.field_241137_cq_ = World.field_234918_g_;
@@ -223,6 +225,8 @@ public class ServerPlayerEntity extends PlayerEntity implements IContainerListen
         this.field_70138_W = 1.0F;
         this.func_205734_a(worldserver);
 
+        this.cachedSingleHashSet = new com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<>(this); // Paper
+
         // CraftBukkit start
         this.displayName = this.func_195047_I_();
         this.canPickUpLoot = true;
diff --git a/src/main/java/net/minecraft/item/ItemStack.java b/src/main/java/net/minecraft/item/ItemStack.java
index a29e95265e155971a8ab0e5d9fe89284b4543399..7a7ca5452d61f5920b7fcac06fee5e6c3524f7e7 100644
--- a/src/main/java/net/minecraft/item/ItemStack.java
+++ b/src/main/java/net/minecraft/item/ItemStack.java
@@ -102,7 +102,7 @@ public final class ItemStack {
         })).apply(instance, ItemStack::new);
     });
     private static final Logger field_199558_c = LogManager.getLogger();
-    public static final ItemStack field_190927_a = new ItemStack((Item) null);
+    public static final ItemStack field_190927_a = new ItemStack((Item) null);public static final ItemStack NULL_ITEM = field_190927_a; // Paper - OBFHELPER
     public static final DecimalFormat field_111284_a = (DecimalFormat) Util.func_200696_a((new DecimalFormat("#.##")), (decimalformat) -> { // CraftBukkit - decompile error
         decimalformat.setDecimalFormatSymbols(DecimalFormatSymbols.getInstance(Locale.ROOT));
     });
@@ -659,6 +659,24 @@ public final class ItemStack {
         return this.field_77990_d != null ? this.field_77990_d.func_150295_c("Enchantments", 10) : new ListNBT();
     }
 
+    // Paper start - (this is just a good no conflict location)
+    public org.bukkit.inventory.ItemStack asBukkitMirror() {
+        return CraftItemStack.asCraftMirror(this);
+    }
+    public org.bukkit.inventory.ItemStack asBukkitCopy() {
+        return CraftItemStack.asCraftMirror(this.func_77946_l());
+    }
+    public static ItemStack fromBukkitCopy(org.bukkit.inventory.ItemStack itemstack) {
+        return CraftItemStack.asNMSCopy(itemstack);
+    }
+    private org.bukkit.craftbukkit.inventory.CraftItemStack bukkitStack;
+    public org.bukkit.inventory.ItemStack getBukkitStack() {
+        if (bukkitStack == null || bukkitStack.getHandle() != this) {
+            bukkitStack = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(this);
+        }
+        return bukkitStack;
+    }
+    // Paper end
     public void func_77982_d(@Nullable CompoundNBT p_77982_1_) {
         this.field_77990_d = p_77982_1_;
         if (this.func_77973_b().func_77645_m()) {
@@ -751,6 +769,7 @@ public final class ItemStack {
         return this.field_77990_d != null && this.field_77990_d.func_150297_b("Enchantments", 9) ? !this.field_77990_d.func_150295_c("Enchantments", 10).isEmpty() : false;
     }
 
+    public void getOrCreateTagAndSet(String s, INBT nbtbase) { func_77983_a(s, nbtbase);} // Paper - OBFHELPER
     public void func_77983_a(String p_77983_1_, INBT p_77983_2_) {
         this.func_196082_o().func_218657_a(p_77983_1_, p_77983_2_);
     }
@@ -836,6 +855,7 @@ public final class ItemStack {
     // CraftBukkit start
     @Deprecated
     public void setItem(Item item) {
+        this.bukkitStack = null; // Paper
         this.field_151002_e = item;
     }
     // CraftBukkit end
diff --git a/src/main/java/net/minecraft/nbt/CompoundNBT.java b/src/main/java/net/minecraft/nbt/CompoundNBT.java
index 91c5764f6af9bb5eafc1bbe3e7fbe236390bbc0e..3a5194ad42af8168c772258b42e4625e33d6c534 100644
--- a/src/main/java/net/minecraft/nbt/CompoundNBT.java
+++ b/src/main/java/net/minecraft/nbt/CompoundNBT.java
@@ -76,7 +76,7 @@ public class CompoundNBT implements INBT {
             return "TAG_Compound";
         }
     };
-    private final Map<String, INBT> field_74784_a;
+    public final Map<String, INBT> field_74784_a; // Paper
 
     protected CompoundNBT(Map<String, INBT> p_i226075_1_) {
         this.field_74784_a = p_i226075_1_;
@@ -139,10 +139,14 @@ public class CompoundNBT implements INBT {
         this.field_74784_a.put(p_74772_1_, LongNBT.func_229698_a_(p_74772_2_));
     }
 
+    public void setUUID(String prefix, UUID uuid) { func_186854_a(prefix, uuid); } // Paper - OBFHELPER
     public void func_186854_a(String p_186854_1_, UUID p_186854_2_) {
         this.field_74784_a.put(p_186854_1_, NBTUtil.func_240626_a_(p_186854_2_));
     }
 
+
+    @Nullable public UUID getUUID(String prefix) { return func_186857_a(prefix); } // Paper - OBFHELPER
+    @Nullable
     public UUID func_186857_a(String p_186857_1_) {
         return NBTUtil.func_186860_b(this.func_74781_a(p_186857_1_));
     }
diff --git a/src/main/java/net/minecraft/network/NettyPacketEncoder.java b/src/main/java/net/minecraft/network/NettyPacketEncoder.java
index 47a874e4e0f17db601a5cb05d1cc64458dc0a01e..1e78c81ca95ba300f34ef47097836309a65b3f6e 100644
--- a/src/main/java/net/minecraft/network/NettyPacketEncoder.java
+++ b/src/main/java/net/minecraft/network/NettyPacketEncoder.java
@@ -42,6 +42,7 @@ public class NettyPacketEncoder extends MessageToByteEncoder<IPacket<?>> {
                     packet.func_148840_b(packetdataserializer);
                 } catch (Throwable throwable) {
                     NettyPacketEncoder.field_150798_a.error(throwable);
+                    throwable.printStackTrace(); // Paper - WHAT WAS IT? WHO DID THIS TO YOU? WHAT DID YOU SEE?
                     if (packet.func_211402_a()) {
                         throw new SkipableEncoderException(throwable);
                     } else {
diff --git a/src/main/java/net/minecraft/network/NetworkManager.java b/src/main/java/net/minecraft/network/NetworkManager.java
index 49428c385d95a36726279e26fd77513e22bc58fe..ec5366b12c2852d3707a33735465faa7e1626688 100644
--- a/src/main/java/net/minecraft/network/NetworkManager.java
+++ b/src/main/java/net/minecraft/network/NetworkManager.java
@@ -166,6 +166,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<IPacket<?>> {
 
     }
 
+    private void dispatchPacket(IPacket<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> genericFutureListener) { this.func_150732_b(packet, genericFutureListener); } // Paper - OBFHELPER
     private void func_150732_b(IPacket<?> p_150732_1_, @Nullable GenericFutureListener<? extends Future<? super Void>> p_150732_2_) {
         ProtocolType enumprotocol = ProtocolType.func_150752_a(p_150732_1_);
         ProtocolType enumprotocol1 = (ProtocolType) this.field_150746_k.attr(NetworkManager.field_150739_c).get();
@@ -206,6 +207,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<IPacket<?>> {
 
     }
 
+    private void sendPacketQueue() { this.func_150733_h(); } // Paper - OBFHELPER
     private void func_150733_h() {
         if (this.field_150746_k != null && this.field_150746_k.isOpen()) {
             Queue queue = this.field_150745_j;
@@ -334,9 +336,9 @@ public class NetworkManager extends SimpleChannelInboundHandler<IPacket<?>> {
 
     static class QueuedPacket {
 
-        private final IPacket<?> field_150774_a;
+        private final IPacket<?> field_150774_a; private final IPacket<?> getPacket() { return this.field_150774_a; } // Paper - OBFHELPER
         @Nullable
-        private final GenericFutureListener<? extends Future<? super Void>> field_201049_b;
+        private final GenericFutureListener<? extends Future<? super Void>> field_201049_b; private final GenericFutureListener<? extends Future<? super Void>> getGenericFutureListener() { return this.field_201049_b; } // Paper - OBFHELPER
 
         public QueuedPacket(IPacket<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> genericfuturelistener) {
             this.field_150774_a = packet;
diff --git a/src/main/java/net/minecraft/network/PacketBuffer.java b/src/main/java/net/minecraft/network/PacketBuffer.java
index 7ebef791b0dbbefe7d48740dfd38c3e2d738f3e8..62ac92f4ea7cba43c1129cc94ed0e556b2045fd6 100644
--- a/src/main/java/net/minecraft/network/PacketBuffer.java
+++ b/src/main/java/net/minecraft/network/PacketBuffer.java
@@ -48,6 +48,7 @@ public class PacketBuffer extends ByteBuf {
         this.field_150794_a = p_i45154_1_;
     }
 
+    public static int countBytes(int i) { return PacketBuffer.func_150790_a(i); } // Paper - OBFHELPER
     public static int func_150790_a(int p_150790_0_) {
         for (int j = 1; j < 5; ++j) {
             if ((p_150790_0_ & -1 << j * 7) == 0) {
diff --git a/src/main/java/net/minecraft/network/play/ServerPlayNetHandler.java b/src/main/java/net/minecraft/network/play/ServerPlayNetHandler.java
index 6f3600c7bf02c95aab228287628bcf52b6fa86f3..8da28147008a207bc5e32ec6fcccd6da19b3ad19 100644
--- a/src/main/java/net/minecraft/network/play/ServerPlayNetHandler.java
+++ b/src/main/java/net/minecraft/network/play/ServerPlayNetHandler.java
@@ -208,9 +208,9 @@ public class ServerPlayNetHandler implements IServerPlayNetHandler {
     private final MinecraftServer field_147367_d;
     public ServerPlayerEntity field_147369_b;
     private int field_147368_e;
-    private long field_194402_f;
-    private boolean field_194403_g;
-    private long field_194404_h;
+    private long field_194402_f; private void setLastPing(long lastPing) { this.field_194402_f = lastPing;}; private long getLastPing() { return this.field_194402_f;}; // Paper - OBFHELPER
+    private boolean field_194403_g; private void setPendingPing(boolean isPending) { this.field_194403_g = isPending;}; private boolean isPendingPing() { return this.field_194403_g;}; // Paper - OBFHELPER
+    private long field_194404_h; private void setKeepAliveID(long keepAliveID) { this.field_194404_h = keepAliveID;}; private long getKeepAliveID() {return this.field_194404_h; };  // Paper - OBFHELPER
     // CraftBukkit start - multithreaded fields
     private volatile int field_147374_l;
     private static final AtomicIntegerFieldUpdater chatSpamField = AtomicIntegerFieldUpdater.newUpdater(ServerPlayNetHandler.class, "chatThrottle");
diff --git a/src/main/java/net/minecraft/network/play/server/SChunkDataPacket.java b/src/main/java/net/minecraft/network/play/server/SChunkDataPacket.java
index e8a8d03e47e1a5f6d3657cf512d75601a8d5b4c1..6a0bb6a11ebcdd3b2ab769181a2c127793ecb8c0 100644
--- a/src/main/java/net/minecraft/network/play/server/SChunkDataPacket.java
+++ b/src/main/java/net/minecraft/network/play/server/SChunkDataPacket.java
@@ -29,7 +29,7 @@ public class SChunkDataPacket implements IPacket<IClientPlayNetHandler> {
     private CompoundNBT field_218711_d;
     @Nullable
     private BiomeContainer field_229738_e_;
-    private byte[] field_186949_d;
+    private byte[] field_186949_d; private byte[] getData() { return this.field_186949_d; } // Paper - OBFHELPER
     private List<CompoundNBT> field_189557_e;
     private boolean field_149279_g;
     private boolean field_241781_i_;
@@ -145,6 +145,7 @@ public class SChunkDataPacket implements IPacket<IClientPlayNetHandler> {
         return bytebuf;
     }
 
+    public int writeChunk(PacketBuffer packetDataSerializer, Chunk chunk, int chunkSectionSelector) { return this.func_218708_a(packetDataSerializer, chunk, chunkSectionSelector); } // Paper - OBFHELPER
     public int func_218708_a(PacketBuffer p_218708_1_, Chunk p_218708_2_, int p_218708_3_) {
         int j = 0;
         ChunkSection[] achunksection = p_218708_2_.func_76587_i();
diff --git a/src/main/java/net/minecraft/potion/PotionUtils.java b/src/main/java/net/minecraft/potion/PotionUtils.java
index f4b2722100fc94d30b9e35ba4b4cb5c450962172..2dc63f5653b2eecc11e69fcefb9ca3e935387934 100644
--- a/src/main/java/net/minecraft/potion/PotionUtils.java
+++ b/src/main/java/net/minecraft/potion/PotionUtils.java
@@ -115,6 +115,7 @@ public class PotionUtils {
         return p_185187_0_ == null ? Potions.field_185229_a : Potion.func_185168_a(p_185187_0_.func_74779_i("Potion"));
     }
 
+    public static ItemStack addPotionToItemStack(ItemStack itemstack, Potion potionregistry) { return func_185188_a(itemstack, potionregistry); } // Paper - OBFHELPER
     public static ItemStack func_185188_a(ItemStack p_185188_0_, Potion p_185188_1_) {
         ResourceLocation minecraftkey = Registry.field_212621_j.func_177774_c(p_185188_1_);
 
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..ca1374b3851e4b50fdf6819c3b56b87892c857f2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -0,0 +1,509 @@
+package net.minecraft.server;
+
+import com.destroystokyo.paper.block.TargetBlockInfo;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import org.apache.commons.lang.exception.ExceptionUtils;
+import org.bukkit.Location;
+import org.bukkit.block.BlockFace;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.util.Waitable;
+import org.spigotmc.AsyncCatcher;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import net.minecraft.entity.Entity;
+import net.minecraft.util.Direction;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.math.RayTraceContext;
+import net.minecraft.world.World;
+import net.minecraft.world.server.ServerWorld;
+import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.BiConsumer;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+
+public final class MCUtil {
+    public static final ThreadPoolExecutor asyncExecutor = new ThreadPoolExecutor(
+        0, 2, 60L, TimeUnit.SECONDS,
+        new LinkedBlockingQueue<Runnable>(),
+        new ThreadFactoryBuilder().setNameFormat("Paper Async Task Handler Thread - %1$d").build()
+    );
+    public static final ThreadPoolExecutor cleanerExecutor = new ThreadPoolExecutor(
+        1, 1, 0L, TimeUnit.SECONDS,
+        new LinkedBlockingQueue<Runnable>(),
+        new ThreadFactoryBuilder().setNameFormat("Paper Object Cleaner").build()
+    );
+
+    public static final long INVALID_CHUNK_KEY = getCoordinateKey(Integer.MAX_VALUE, Integer.MAX_VALUE);
+
+
+    public static Runnable once(Runnable run) {
+        AtomicBoolean ran = new AtomicBoolean(false);
+        return () -> {
+            if (ran.compareAndSet(false, true)) {
+                run.run();
+            }
+        };
+    }
+
+    public static <T> Runnable once(List<T> list, Consumer<T> cb) {
+        return once(() -> {
+            list.forEach(cb);
+        });
+    }
+
+    private static Runnable makeCleanerCallback(Runnable run) {
+        return once(() -> cleanerExecutor.execute(run));
+    }
+
+    /**
+     * DANGER WILL ROBINSON: Be sure you do not use a lambda that lives in the object being monitored, or leaky leaky!
+     * @param obj
+     * @param run
+     * @return
+     */
+    public static Runnable registerCleaner(Object obj, Runnable run) {
+        // Wrap callback in its own method above or the lambda will leak object
+        Runnable cleaner = makeCleanerCallback(run);
+        co.aikar.cleaner.Cleaner.register(obj, cleaner);
+        return cleaner;
+    }
+
+    /**
+     * DANGER WILL ROBINSON: Be sure you do not use a lambda that lives in the object being monitored, or leaky leaky!
+     * @param obj
+     * @param list
+     * @param cleaner
+     * @param <T>
+     * @return
+     */
+    public static <T> Runnable registerListCleaner(Object obj, List<T> list, Consumer<T> cleaner) {
+        return registerCleaner(obj, () -> {
+            list.forEach(cleaner);
+            list.clear();
+        });
+    }
+
+    /**
+     * DANGER WILL ROBINSON: Be sure you do not use a lambda that lives in the object being monitored, or leaky leaky!
+     * @param obj
+     * @param resource
+     * @param cleaner
+     * @param <T>
+     * @return
+     */
+    public static <T> Runnable registerCleaner(Object obj, T resource, java.util.function.Consumer<T> cleaner) {
+        return registerCleaner(obj, () -> cleaner.accept(resource));
+    }
+
+    public static List<ChunkPos> getSpiralOutChunks(BlockPos blockposition, int radius) {
+        List<ChunkPos> list = com.google.common.collect.Lists.newArrayList();
+
+        list.add(new ChunkPos(blockposition.func_177958_n() >> 4, blockposition.func_177952_p() >> 4));
+        for (int r = 1; r <= radius; r++) {
+            int x = -r;
+            int z = r;
+
+            // Iterates the edge of half of the box; then negates for other half.
+            while (x <= r && z > -r) {
+                list.add(new ChunkPos((blockposition.func_177958_n() + (x << 4)) >> 4, (blockposition.func_177952_p() + (z << 4)) >> 4));
+                list.add(new ChunkPos((blockposition.func_177958_n() - (x << 4)) >> 4, (blockposition.func_177952_p() - (z << 4)) >> 4));
+
+                if (x < r) {
+                    x++;
+                } else {
+                    z--;
+                }
+            }
+        }
+        return list;
+    }
+
+    public static int fastFloor(double x) {
+        int truncated = (int)x;
+        return x < (double)truncated ? truncated - 1 : truncated;
+    }
+
+    public static int fastFloor(float x) {
+        int truncated = (int)x;
+        return x < (double)truncated ? truncated - 1 : truncated;
+    }
+
+    public static float normalizeYaw(float f) {
+        float f1 = f % 360.0F;
+
+        if (f1 >= 180.0F) {
+            f1 -= 360.0F;
+        }
+
+        if (f1 < -180.0F) {
+            f1 += 360.0F;
+        }
+
+        return f1;
+    }
+
+    /**
+     * Quickly generate a stack trace for current location
+     *
+     * @return Stacktrace
+     */
+    public static String stack() {
+        return ExceptionUtils.getFullStackTrace(new Throwable());
+    }
+
+    /**
+     * Quickly generate a stack trace for current location with message
+     *
+     * @param str
+     * @return Stacktrace
+     */
+    public static String stack(String str) {
+        return ExceptionUtils.getFullStackTrace(new Throwable(str));
+    }
+
+    public static long getCoordinateKey(final BlockPos blockPos) {
+        return ((long)(blockPos.func_177952_p() >> 4) << 32) | ((blockPos.func_177958_n() >> 4) & 0xFFFFFFFFL);
+    }
+
+    public static long getCoordinateKey(final Entity entity) {
+        return ((long)(MCUtil.fastFloor(entity.func_226281_cx_()) >> 4) << 32) | ((MCUtil.fastFloor(entity.func_226277_ct_()) >> 4) & 0xFFFFFFFFL);
+    }
+
+    public static long getCoordinateKey(final ChunkPos pair) {
+        return ((long)pair.field_77275_b << 32) | (pair.field_77276_a & 0xFFFFFFFFL);
+    }
+
+    public static long getCoordinateKey(final int x, final int z) {
+        return ((long)z << 32) | (x & 0xFFFFFFFFL);
+    }
+
+    public static int getCoordinateX(final long key) {
+        return (int)key;
+    }
+
+    public static int getCoordinateZ(final long key) {
+        return (int)(key >>> 32);
+    }
+
+    public static int getChunkCoordinate(final double coordinate) {
+        return MCUtil.fastFloor(coordinate) >> 4;
+    }
+
+    public static int getBlockCoordinate(final double coordinate) {
+        return MCUtil.fastFloor(coordinate);
+    }
+
+    public static long getBlockKey(final int x, final int y, final int z) {
+        return ((long)x & 0x7FFFFFF) | (((long)z & 0x7FFFFFF) << 27) | ((long)y << 54);
+    }
+
+    public static long getBlockKey(final BlockPos pos) {
+        return ((long)pos.func_177958_n() & 0x7FFFFFF) | (((long)pos.func_177952_p() & 0x7FFFFFF) << 27) | ((long)pos.func_177956_o() << 54);
+    }
+
+    public static long getBlockKey(final Entity entity) {
+        return getBlockKey(getBlockCoordinate(entity.func_226277_ct_()), getBlockCoordinate(entity.func_226278_cu_()), getBlockCoordinate(entity.func_226281_cx_()));
+    }
+
+    // assumes the sets have the same comparator, and if this comparator is null then assume T is Comparable
+    public static <T> void mergeSortedSets(final java.util.function.Consumer<T> consumer, final java.util.Comparator<? super T> comparator, final java.util.SortedSet<T>...sets) {
+        final it.unimi.dsi.fastutil.objects.ObjectRBTreeSet<T> all = new it.unimi.dsi.fastutil.objects.ObjectRBTreeSet<>(comparator);
+        // note: this is done in log(n!) ~ nlogn time. It could be improved if it were to mimic what mergesort does.
+        for (java.util.SortedSet<T> set : sets) {
+            if (set != null) {
+                all.addAll(set);
+            }
+        }
+        all.forEach(consumer);
+    }
+
+    private MCUtil() {}
+
+    public static final java.util.concurrent.Executor MAIN_EXECUTOR = (run) -> {
+        if (!isMainThread()) {
+            MinecraftServer.getServer().execute(run);
+        } else {
+            run.run();
+        }
+    };
+
+    public static <T> CompletableFuture<T> ensureMain(CompletableFuture<T> future) {
+        return future.thenApplyAsync(r -> r, MAIN_EXECUTOR);
+    }
+
+    public static <T> void thenOnMain(CompletableFuture<T> future, Consumer<T> consumer) {
+        future.thenAcceptAsync(consumer, MAIN_EXECUTOR);
+    }
+    public static <T> void thenOnMain(CompletableFuture<T> future, BiConsumer<T, Throwable> consumer) {
+        future.whenCompleteAsync(consumer, MAIN_EXECUTOR);
+    }
+
+    public static boolean isMainThread() {
+        return MinecraftServer.getServer().bf();
+    }
+
+    public static org.bukkit.scheduler.BukkitTask scheduleTask(int ticks, Runnable runnable) {
+        return scheduleTask(ticks, runnable, null);
+    }
+
+    public static org.bukkit.scheduler.BukkitTask scheduleTask(int ticks, Runnable runnable, String taskName) {
+        return MinecraftServer.getServer().server.getScheduler().scheduleInternalTask(runnable, ticks, taskName);
+    }
+
+    public static void processQueue() {
+        Runnable runnable;
+        Queue<Runnable> processQueue = getProcessQueue();
+        while ((runnable = processQueue.poll()) != null) {
+            try {
+                runnable.run();
+            } catch (Exception e) {
+                MinecraftServer.field_147145_h.error("Error executing task", e);
+            }
+        }
+    }
+    public static <T> T processQueueWhileWaiting(CompletableFuture <T> future) {
+        try {
+            if (isMainThread()) {
+                while (!future.isDone()) {
+                    try {
+                        return future.get(1, TimeUnit.MILLISECONDS);
+                    } catch (TimeoutException ignored) {
+                        processQueue();
+                    }
+                }
+            }
+            return future.get();
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void ensureMain(Runnable run) {
+        ensureMain(null, run);
+    }
+    /**
+     * Ensures the target code is running on the main thread
+     * @param reason
+     * @param run
+     * @return
+     */
+    public static void ensureMain(String reason, Runnable run) {
+        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().field_175590_aa) {
+            if (reason != null) {
+                new IllegalStateException("Asynchronous " + reason + "!").printStackTrace();
+            }
+            getProcessQueue().add(run);
+            return;
+        }
+        run.run();
+    }
+
+    private static Queue<Runnable> getProcessQueue() {
+        return MinecraftServer.getServer().processQueue;
+    }
+
+    public static <T> T ensureMain(Supplier<T> run) {
+        return ensureMain(null, run);
+    }
+    /**
+     * Ensures the target code is running on the main thread
+     * @param reason
+     * @param run
+     * @param <T>
+     * @return
+     */
+    public static <T> T ensureMain(String reason, Supplier<T> run) {
+        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().field_175590_aa) {
+            if (reason != null) {
+                new IllegalStateException("Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
+            }
+            Waitable<T> wait = new Waitable<T>() {
+                @Override
+                protected T evaluate() {
+                    return run.get();
+                }
+            };
+            getProcessQueue().add(wait);
+            try {
+                return wait.get();
+            } catch (InterruptedException | ExecutionException e) {
+                e.printStackTrace();
+            }
+            return null;
+        }
+        return run.get();
+    }
+
+    /**
+     * Calculates distance between 2 entities
+     * @param e1
+     * @param e2
+     * @return
+     */
+    public static double distance(Entity e1, Entity e2) {
+        return Math.sqrt(distanceSq(e1, e2));
+    }
+
+
+    /**
+     * Calculates distance between 2 block positions
+     * @param e1
+     * @param e2
+     * @return
+     */
+    public static double distance(BlockPos e1, BlockPos e2) {
+        return Math.sqrt(distanceSq(e1, e2));
+    }
+
+    /**
+     * Gets the distance between 2 positions
+     * @param x1
+     * @param y1
+     * @param z1
+     * @param x2
+     * @param y2
+     * @param z2
+     * @return
+     */
+    public static double distance(double x1, double y1, double z1, double x2, double y2, double z2) {
+        return Math.sqrt(distanceSq(x1, y1, z1, x2, y2, z2));
+    }
+
+    /**
+     * Get's the distance squared between 2 entities
+     * @param e1
+     * @param e2
+     * @return
+     */
+    public static double distanceSq(Entity e1, Entity e2) {
+        return distanceSq(e1.func_226277_ct_(),e1.func_226278_cu_(),e1.func_226281_cx_(), e2.func_226277_ct_(),e2.func_226278_cu_(),e2.func_226281_cx_());
+    }
+
+    /**
+     * Gets the distance sqaured between 2 block positions
+     * @param pos1
+     * @param pos2
+     * @return
+     */
+    public static double distanceSq(BlockPos pos1, BlockPos pos2) {
+        return distanceSq(pos1.func_177958_n(), pos1.func_177956_o(), pos1.func_177952_p(), pos2.func_177958_n(), pos2.func_177956_o(), pos2.func_177952_p());
+    }
+
+    /**
+     * Gets the distance squared between 2 positions
+     * @param x1
+     * @param y1
+     * @param z1
+     * @param x2
+     * @param y2
+     * @param z2
+     * @return
+     */
+    public static double distanceSq(double x1, double y1, double z1, double x2, double y2, double z2) {
+        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2);
+    }
+
+    /**
+     * Converts a NMS World/BlockPosition to Bukkit Location
+     * @param world
+     * @param x
+     * @param y
+     * @param z
+     * @return
+     */
+    public static Location toLocation(World world, double x, double y, double z) {
+        return new Location(world.getWorld(), x, y, z);
+    }
+
+    /**
+     * Converts a NMS World/BlockPosition to Bukkit Location
+     * @param world
+     * @param pos
+     * @return
+     */
+    public static Location toLocation(World world, BlockPos pos) {
+        return new Location(world.getWorld(), pos.func_177958_n(), pos.func_177956_o(), pos.func_177952_p());
+    }
+
+    /**
+     * Converts an NMS entity's current location to a Bukkit Location
+     * @param entity
+     * @return
+     */
+    public static Location toLocation(Entity entity) {
+        return new Location(entity.func_130014_f_().getWorld(), entity.func_226277_ct_(), entity.func_226278_cu_(), entity.func_226281_cx_());
+    }
+
+    public static org.bukkit.block.Block toBukkitBlock(World world, BlockPos pos) {
+        return world.getWorld().getBlockAt(pos.func_177958_n(), pos.func_177956_o(), pos.func_177952_p());
+    }
+
+    public static BlockPos toBlockPosition(Location loc) {
+        return new BlockPos(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ());
+    }
+
+    public static boolean isEdgeOfChunk(BlockPos pos) {
+        final int modX = pos.func_177958_n() & 15;
+        final int modZ = pos.func_177952_p() & 15;
+        return (modX == 0 || modX == 15 || modZ == 0 || modZ == 15);
+    }
+
+    /**
+     * Posts a task to be executed asynchronously
+     * @param run
+     */
+    public static void scheduleAsyncTask(Runnable run) {
+        asyncExecutor.execute(run);
+    }
+
+    @Nonnull
+    public static ServerWorld getNMSWorld(@Nonnull org.bukkit.World world) {
+        return ((CraftWorld) world).getHandle();
+    }
+
+    public static ServerWorld getNMSWorld(@Nonnull org.bukkit.entity.Entity entity) {
+        return getNMSWorld(entity.getWorld());
+    }
+
+    public static RayTraceContext.FluidMode getNMSFluidCollisionOption(TargetBlockInfo.FluidMode fluidMode) {
+        if (fluidMode == TargetBlockInfo.FluidMode.NEVER) {
+            return RayTraceContext.FluidMode.NONE;
+        }
+        if (fluidMode == TargetBlockInfo.FluidMode.SOURCE_ONLY) {
+            return RayTraceContext.FluidMode.SOURCE_ONLY;
+        }
+        if (fluidMode == TargetBlockInfo.FluidMode.ALWAYS) {
+            return RayTraceContext.FluidMode.ANY;
+        }
+        return null;
+    }
+
+    public static BlockFace toBukkitBlockFace(Direction enumDirection) {
+        switch (enumDirection) {
+            case DOWN:
+                return BlockFace.DOWN;
+            case UP:
+                return BlockFace.UP;
+            case NORTH:
+                return BlockFace.NORTH;
+            case SOUTH:
+                return BlockFace.SOUTH;
+            case WEST:
+                return BlockFace.WEST;
+            case EAST:
+                return BlockFace.EAST;
+            default:
+                return null;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 589f3cb90402d52b14947c023eca1e455914b937..93babd4376bb5e9027cf8f3c1be1a5f97ed5dcd5 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -872,6 +872,9 @@ public abstract class MinecraftServer extends RecursiveEventLoop<TickDelayedTask
             MinecraftServer.field_147145_h.error("Failed to unlock level {}", this.field_71310_m.func_237282_a_(), ioexception1);
         }
         // Spigot start
+        MCUtil.asyncExecutor.shutdown(); // Paper
+        try { MCUtil.asyncExecutor.awaitTermination(30, java.util.concurrent.TimeUnit.SECONDS); // Paper
+        } catch (java.lang.InterruptedException ignored) {} // Paper
         if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
             field_147145_h.info("Saving usercache.json");
             this.func_152358_ax().func_152658_c();
diff --git a/src/main/java/net/minecraft/util/BitArray.java b/src/main/java/net/minecraft/util/BitArray.java
index bc7fcebce14cb8770e119f41ca228f13c89e979a..4cd803b7ca8d772033394e016489b0c71c8b44b0 100644
--- a/src/main/java/net/minecraft/util/BitArray.java
+++ b/src/main/java/net/minecraft/util/BitArray.java
@@ -83,6 +83,7 @@ public class BitArray {
         return (int) (k >> l & this.field_188147_c);
     }
 
+    public final long[] getDataBits() { return this.func_188143_a(); } // Paper - OBFHELPER
     public long[] func_188143_a() {
         return this.field_188145_a;
     }
diff --git a/src/main/java/net/minecraft/util/ObjectIntIdentityMap.java b/src/main/java/net/minecraft/util/ObjectIntIdentityMap.java
index d5b3f7073e3090c429bcc6431432e19558f658a2..c03fe4eba34fab087fef42add2070f2b5a905dd1 100644
--- a/src/main/java/net/minecraft/util/ObjectIntIdentityMap.java
+++ b/src/main/java/net/minecraft/util/ObjectIntIdentityMap.java
@@ -57,6 +57,7 @@ public class ObjectIntIdentityMap<T> implements IObjectIntIterable<T> {
         return Iterators.filter(this.field_148748_b.iterator(), Predicates.notNull());
     }
 
+    public int size() { return this.func_186804_a(); } // Paper - OBFHELPER
     public int func_186804_a() {
         return this.field_148749_a.size();
     }
diff --git a/src/main/java/net/minecraft/util/Util.java b/src/main/java/net/minecraft/util/Util.java
index ff3b62c99aff908dd2e3bc7e1e3c76078cb3f566..cc391e7130f6e574bd66931abe5f21856e145036 100644
--- a/src/main/java/net/minecraft/util/Util.java
+++ b/src/main/java/net/minecraft/util/Util.java
@@ -73,7 +73,7 @@ public class Util {
     }
 
     public static long func_211178_c() {
-        return Util.field_211180_a.getAsLong();
+        return System.nanoTime(); // Paper
     }
 
     public static long func_211179_d() {
diff --git a/src/main/java/net/minecraft/util/concurrent/ThreadTaskExecutor.java b/src/main/java/net/minecraft/util/concurrent/ThreadTaskExecutor.java
index 304ff2bbff193b79a913c7eba3046d082e755099..59c9e2aacdf870e3af39805619313cab50735364 100644
--- a/src/main/java/net/minecraft/util/concurrent/ThreadTaskExecutor.java
+++ b/src/main/java/net/minecraft/util/concurrent/ThreadTaskExecutor.java
@@ -68,6 +68,15 @@ public abstract class ThreadTaskExecutor<R extends Runnable> implements ITaskExe
 
     }
 
+    // Paper start
+    public void scheduleOnMain(Runnable r0) {
+        // postToMainThread does not work the same as older versions of mc
+        // This method is actually used to create a TickTask, which can then be posted onto main
+        this.addTask(this.func_212875_d_(r0));
+    }
+    // Paper end
+
+    public final void addTask(R r0) { func_212871_a_(r0); }; // Paper - OBFHELPER
     public void func_212871_a_(R p_212871_1_) {
         this.field_213173_d.add(p_212871_1_);
         LockSupport.unpark(this.func_213170_ax());
diff --git a/src/main/java/net/minecraft/util/math/AxisAlignedBB.java b/src/main/java/net/minecraft/util/math/AxisAlignedBB.java
index a95d298cffdaf3dae7e3ca0f047044dbbfcb1972..5f14897cfd276554c8b0b388bbca863868791209 100644
--- a/src/main/java/net/minecraft/util/math/AxisAlignedBB.java
+++ b/src/main/java/net/minecraft/util/math/AxisAlignedBB.java
@@ -192,10 +192,12 @@ public class AxisAlignedBB {
         return this.func_72317_d(p_191194_1_.field_72450_a, p_191194_1_.field_72448_b, p_191194_1_.field_72449_c);
     }
 
+    public final boolean intersects(AxisAlignedBB axisalignedbb) { return this.func_72326_a(axisalignedbb); } // Paper - OBFHELPER
     public boolean func_72326_a(AxisAlignedBB p_72326_1_) {
         return this.func_186668_a(p_72326_1_.field_72340_a, p_72326_1_.field_72338_b, p_72326_1_.field_72339_c, p_72326_1_.field_72336_d, p_72326_1_.field_72337_e, p_72326_1_.field_72334_f);
     }
 
+    public final boolean intersects(double d0, double d1, double d2, double d3, double d4, double d5) { return func_186668_a(d0, d1, d2, d3, d4, d5); } // Paper - OBFHELPER
     public boolean func_186668_a(double p_186668_1_, double p_186668_2_, double p_186668_3_, double p_186668_4_, double p_186668_5_, double p_186668_6_) {
         return this.field_72340_a < p_186668_4_ && this.field_72336_d > p_186668_1_ && this.field_72338_b < p_186668_5_ && this.field_72337_e > p_186668_2_ && this.field_72339_c < p_186668_6_ && this.field_72334_f > p_186668_3_;
     }
@@ -208,6 +210,7 @@ public class AxisAlignedBB {
         return p_197744_1_ >= this.field_72340_a && p_197744_1_ < this.field_72336_d && p_197744_2_ >= this.field_72338_b && p_197744_2_ < this.field_72337_e && p_197744_3_ >= this.field_72339_c && p_197744_3_ < this.field_72334_f;
     }
 
+    public final double getAverageSideLength(){return func_72320_b();} // Paper - OBFHELPER
     public double func_72320_b() {
         double d0 = this.func_216364_b();
         double d1 = this.func_216360_c();
diff --git a/src/main/java/net/minecraft/util/math/BlockPos.java b/src/main/java/net/minecraft/util/math/BlockPos.java
index b485af1bed686721b4fb1b2a623e8ef86570488a..edc4e53c42ee00656e7490899bd90706ec18c1c4 100644
--- a/src/main/java/net/minecraft/util/math/BlockPos.java
+++ b/src/main/java/net/minecraft/util/math/BlockPos.java
@@ -105,6 +105,7 @@ public class BlockPos extends Vector3i {
         return p_177963_1_ == 0.0D && p_177963_2_ == 0.0D && p_177963_3_ == 0.0D ? this : new BlockPos((double) this.func_177958_n() + p_177963_1_, (double) this.func_177956_o() + p_177963_2_, (double) this.func_177952_p() + p_177963_3_);
     }
 
+    public final BlockPos add(int i, int j, int k) {return func_177982_a(i, j, k);} // Paper - OBFHELPER
     public BlockPos func_177982_a(int p_177982_1_, int p_177982_2_, int p_177982_3_) {
         return p_177982_1_ == 0 && p_177982_2_ == 0 && p_177982_3_ == 0 ? this : new BlockPos(this.func_177958_n() + p_177982_1_, this.func_177956_o() + p_177982_2_, this.func_177952_p() + p_177982_3_);
     }
@@ -375,6 +376,7 @@ public class BlockPos extends Vector3i {
             return super.func_190942_a(p_190942_1_).func_185334_h();
         }
 
+        public final BlockPos.Mutable setValues(int i, int j, int k) { return func_181079_c(i, j, k);} // Paper - OBFHELPER
         public BlockPos.Mutable func_181079_c(int p_181079_1_, int p_181079_2_, int p_181079_3_) {
             this.func_223471_o(p_181079_1_);
             this.func_185336_p(p_181079_2_);
@@ -382,6 +384,7 @@ public class BlockPos extends Vector3i {
             return this;
         }
 
+        public final BlockPos.Mutable setValues(double d0, double d1, double d2) { return func_189532_c(d0, d1, d2);} // Paper - OBFHELPER
         public BlockPos.Mutable func_189532_c(double p_189532_1_, double p_189532_2_, double p_189532_3_) {
             return this.func_181079_c(MathHelper.func_76128_c(p_189532_1_), MathHelper.func_76128_c(p_189532_2_), MathHelper.func_76128_c(p_189532_3_));
         }
@@ -431,20 +434,21 @@ public class BlockPos extends Vector3i {
             }
         }
 
+        /* // Paper start - comment out useless overrides @Override
         @Override
-        public void func_223471_o(int p_223471_1_) {
-            super.func_223471_o(p_223471_1_);
+        public void o(int i) {
+            super.o(i);
         }
 
         @Override
-        public void func_185336_p(int p_185336_1_) {
-            super.func_185336_p(p_185336_1_);
+        public void p(int i) {
+            super.p(i);
         }
 
-        @Override
-        public void func_223472_q(int p_223472_1_) {
-            super.func_223472_q(p_223472_1_);
+        public void q(int i) {
+            super.q(i);
         }
+        */ // Paper end
 
         @Override
         public BlockPos func_185334_h() {
diff --git a/src/main/java/net/minecraft/util/math/ChunkPos.java b/src/main/java/net/minecraft/util/math/ChunkPos.java
index 52f85468135eb01cdb9fe6f6cf6a3e54f2b70a37..cef413dd74b405bac51a5a3844891df1ce20d56d 100644
--- a/src/main/java/net/minecraft/util/math/ChunkPos.java
+++ b/src/main/java/net/minecraft/util/math/ChunkPos.java
@@ -11,27 +11,32 @@ public class ChunkPos {
     public static final long field_222244_a = func_77272_a(1875016, 1875016);
     public final int field_77276_a;
     public final int field_77275_b;
+    public final long longKey; // Paper
 
     public ChunkPos(int p_i1947_1_, int p_i1947_2_) {
         this.field_77276_a = p_i1947_1_;
         this.field_77275_b = p_i1947_2_;
+        this.longKey = func_77272_a(this.field_77276_a, this.field_77275_b); // Paper
     }
 
     public ChunkPos(BlockPos blockposition) {
         this.field_77276_a = blockposition.func_177958_n() >> 4;
         this.field_77275_b = blockposition.func_177952_p() >> 4;
+        this.longKey = func_77272_a(this.field_77276_a, this.field_77275_b); // Paper
     }
 
     public ChunkPos(long p_i48713_1_) {
         this.field_77276_a = (int) p_i48713_1_;
         this.field_77275_b = (int) (p_i48713_1_ >> 32);
+        this.longKey = func_77272_a(this.field_77276_a, this.field_77275_b); // Paper
     }
 
     public long func_201841_a() {
-        return func_77272_a(this.field_77276_a, this.field_77275_b);
+        return longKey; // Paper
     }
 
-    public static long func_77272_a(int p_77272_0_, int p_77272_1_) {
+    public static long pair(final BlockPos pos) { return func_77272_a(pos.func_177958_n() >> 4, pos.func_177952_p() >> 4); } // Paper - OBFHELPER
+        public static long func_77272_a(int p_77272_0_, int p_77272_1_) {
         return (long) p_77272_0_ & 4294967295L | ((long) p_77272_1_ & 4294967295L) << 32;
     }
 
diff --git a/src/main/java/net/minecraft/util/math/shapes/VoxelShapes.java b/src/main/java/net/minecraft/util/math/shapes/VoxelShapes.java
index ad28e1bc8569eb4ec2f5b5cf76913f19c7171479..e51c98de7807762e3a23360162dafcc4865e72be 100644
--- a/src/main/java/net/minecraft/util/math/shapes/VoxelShapes.java
+++ b/src/main/java/net/minecraft/util/math/shapes/VoxelShapes.java
@@ -31,10 +31,12 @@ public final class VoxelShapes {
     public static final VoxelShape field_216389_a = func_197873_a(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
     private static final VoxelShape field_197886_a = new VoxelShapeArray(new BitSetVoxelShapePart(0, 0, 0), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}), new DoubleArrayList(new double[]{0.0D}));
 
+    public static final VoxelShape empty() {return func_197880_a();} // Paper - OBFHELPER
     public static VoxelShape func_197880_a() {
         return VoxelShapes.field_197886_a;
     }
 
+    public static final VoxelShape fullCube() {return func_197868_b();} // Paper - OBFHELPER
     public static VoxelShape func_197868_b() {
         return VoxelShapes.field_197887_b;
     }
diff --git a/src/main/java/net/minecraft/util/math/vector/Vector3i.java b/src/main/java/net/minecraft/util/math/vector/Vector3i.java
index 077348077b4d133e16edf8a061d07dba8dadbfcc..26bece5bfd0cbe8cf4fac9dd006c48937d083254 100644
--- a/src/main/java/net/minecraft/util/math/vector/Vector3i.java
+++ b/src/main/java/net/minecraft/util/math/vector/Vector3i.java
@@ -20,9 +20,9 @@ public class Vector3i implements Comparable<Vector3i> {
         return IntStream.of(new int[]{baseblockposition.func_177958_n(), baseblockposition.func_177956_o(), baseblockposition.func_177952_p()});
     });
     public static final Vector3i field_177959_e = new Vector3i(0, 0, 0);
-    private int field_177962_a;
-    private int field_177960_b;
-    private int field_177961_c;
+    private int field_177962_a;public final void setX(final int x) { this.field_177962_a = x; } // Paper - OBFHELPER
+    private int field_177960_b;public final void setY(final int y) { this.field_177960_b = y; } // Paper - OBFHELPER
+    private int field_177961_c;public final void setZ(final int z) { this.field_177961_c = z; } // Paper - OBFHELPER
 
     public Vector3i(int p_i46007_1_, int p_i46007_2_, int p_i46007_3_) {
         this.field_177962_a = p_i46007_1_;
@@ -102,6 +102,7 @@ public class Vector3i implements Comparable<Vector3i> {
         return this.func_218140_a(p_218137_1_.func_82615_a(), p_218137_1_.func_82617_b(), p_218137_1_.func_82616_c(), true) < p_218137_2_ * p_218137_2_;
     }
 
+    public final double distanceSquared(Vector3i baseblockposition) { return func_177951_i(baseblockposition); } // Paper - OBFHELPER
     public double func_177951_i(Vector3i p_177951_1_) {
         return this.func_218140_a((double) p_177951_1_.func_177958_n(), (double) p_177951_1_.func_177956_o(), (double) p_177951_1_.func_177952_p(), true);
     }
diff --git a/src/main/java/net/minecraft/util/palette/IPalette.java b/src/main/java/net/minecraft/util/palette/IPalette.java
index 0f6e14e35360037a07d483a31efafbcdc9c0e3a2..c3896dbc5053b9a8f7d0ab567b41b0bb93c59eb1 100644
--- a/src/main/java/net/minecraft/util/palette/IPalette.java
+++ b/src/main/java/net/minecraft/util/palette/IPalette.java
@@ -7,10 +7,12 @@ import net.minecraft.network.PacketBuffer;
 
 public interface IPalette<T> {
 
+    default int getOrCreateIdFor(T object) { return this.func_186041_a(object); } // Paper - OBFHELPER
     int func_186041_a(T p_186041_1_);
 
     boolean func_230341_a_(Predicate<T> p_230341_1_);
 
+    @Nullable default T getObject(int dataBits) { return this.func_186039_a(dataBits); } // Paper - OBFHELPER
     @Nullable
     T func_186039_a(int p_186039_1_);
 
diff --git a/src/main/java/net/minecraft/util/palette/PalettedContainer.java b/src/main/java/net/minecraft/util/palette/PalettedContainer.java
index f7edc9e94b1a2df56996dab512a457df75174799..446fa09f0fc174e5076e8a4fd3edc2be006da019 100644
--- a/src/main/java/net/minecraft/util/palette/PalettedContainer.java
+++ b/src/main/java/net/minecraft/util/palette/PalettedContainer.java
@@ -19,7 +19,7 @@ import net.minecraft.util.math.MathHelper;
 
 public class PalettedContainer<T> implements IResizeCallback<T> {
 
-    private final IPalette<T> field_205521_b;
+    private final IPalette<T> field_205521_b; private final IPalette<T> getDataPaletteGlobal() { return this.field_205521_b; } // Paper - OBFHELPER
     private final IResizeCallback<T> field_205522_c = (i, object) -> {
         return 0;
     };
@@ -27,9 +27,9 @@ public class PalettedContainer<T> implements IResizeCallback<T> {
     private final Function<CompoundNBT, T> field_205524_e;
     private final Function<T, CompoundNBT> field_205525_f;
     private final T field_205526_g;
-    protected BitArray field_186021_b;
-    private IPalette<T> field_186022_c;
-    private int field_186024_e;
+    protected BitArray field_186021_b; public final BitArray getDataBits() { return this.field_186021_b; } // Paper - OBFHELPER
+    private IPalette<T> field_186022_c; private IPalette<T> getDataPalette() { return this.field_186022_c; } // Paper - OBFHELPER
+    private int field_186024_e; private int getBitsPerObject() { return this.field_186024_e; } // Paper - OBFHELPER
     private final ReentrantLock field_210461_j = new ReentrantLock();
 
     public void func_210459_b() {
@@ -64,6 +64,7 @@ public class PalettedContainer<T> implements IResizeCallback<T> {
         return p_186011_1_ << 8 | p_186011_2_ << 4 | p_186011_0_;
     }
 
+    private void initialize(int bitsPerObject) { this.func_186012_b(bitsPerObject); } // Paper - OBFHELPER
     private void func_186012_b(int p_186012_1_) {
         if (p_186012_1_ != this.field_186024_e) {
             this.field_186024_e = p_186012_1_;
@@ -141,6 +142,7 @@ public class PalettedContainer<T> implements IResizeCallback<T> {
         return t0 == null ? this.field_205526_g : t0;
     }
 
+    public void writeDataPaletteBlock(PacketBuffer packetDataSerializer) { this.func_186009_b(packetDataSerializer); } // Paper - OBFHELPER
     public void func_186009_b(PacketBuffer p_186009_1_) {
         this.func_210459_b();
         p_186009_1_.writeByte(this.field_186024_e);
diff --git a/src/main/java/net/minecraft/world/EmptyBlockReader.java b/src/main/java/net/minecraft/world/EmptyBlockReader.java
index c57d6b4fc70ac0e7667b4d4eace3f96a0d4aabb8..79ede1d1d80efc76d4be37aba9f725f6268f083d 100644
--- a/src/main/java/net/minecraft/world/EmptyBlockReader.java
+++ b/src/main/java/net/minecraft/world/EmptyBlockReader.java
@@ -20,6 +20,18 @@ public enum EmptyBlockReader implements IBlockReader {
         return null;
     }
 
+    // Paper start - If loaded util
+    @Override
+    public FluidState getFluidIfLoaded(BlockPos blockposition) {
+        return this.func_204610_c(blockposition);
+    }
+
+    @Override
+    public BlockState getTypeIfLoaded(BlockPos blockposition) {
+        return this.func_180495_p(blockposition);
+    }
+    // Paper end
+
     @Override
     public BlockState func_180495_p(BlockPos p_180495_1_) {
         return Blocks.field_150350_a.func_176223_P();
diff --git a/src/main/java/net/minecraft/world/IBlockReader.java b/src/main/java/net/minecraft/world/IBlockReader.java
index bc21b10cabc6c2b23e939c5d92a63631fa3c833e..3bd09c42fd8ed75700ddeede4a9c1e03a224151d 100644
--- a/src/main/java/net/minecraft/world/IBlockReader.java
+++ b/src/main/java/net/minecraft/world/IBlockReader.java
@@ -4,7 +4,9 @@ import java.util.function.BiFunction;
 import java.util.function.Function;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+import net.minecraft.block.Block;
 import net.minecraft.block.BlockState;
+import net.minecraft.block.material.Material;
 import net.minecraft.fluid.FluidState;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.util.Direction;
@@ -21,10 +23,24 @@ public interface IBlockReader {
     @Nullable
     TileEntity func_175625_s(BlockPos p_175625_1_);
 
+    BlockState getTypeIfLoaded(BlockPos blockposition); // Paper - if loaded util
     BlockState func_180495_p(BlockPos p_180495_1_);
 
+    FluidState getFluidIfLoaded(BlockPos blockposition); // Paper - if loaded util
     FluidState func_204610_c(BlockPos p_204610_1_);
 
+    // Paper start - if loaded util
+    default Material getMaterialIfLoaded(BlockPos blockposition) {
+        BlockState type = this.getTypeIfLoaded(blockposition);
+        return type == null ? null : type.func_185904_a();
+    }
+
+    default Block getBlockIfLoaded(BlockPos blockposition) {
+        BlockState type = this.getTypeIfLoaded(blockposition);
+        return type == null ? null : type.func_177230_c();
+    }
+    // Paper end
+
     default int func_217298_h(BlockPos p_217298_1_) {
         return this.func_180495_p(p_217298_1_).func_185906_d();
     }
diff --git a/src/main/java/net/minecraft/world/IWorldReader.java b/src/main/java/net/minecraft/world/IWorldReader.java
index 2e429a63aa37db17b48b0cf17123e8060bb26bc0..3ae4b89d1890372a8fcd8bcb1bf240f0b237592e 100644
--- a/src/main/java/net/minecraft/world/IWorldReader.java
+++ b/src/main/java/net/minecraft/world/IWorldReader.java
@@ -17,6 +17,7 @@ import net.minecraft.world.gen.Heightmap;
 
 public interface IWorldReader extends IBlockDisplayReader, ICollisionReader, BiomeManager.IBiomeReader {
 
+    @Nullable IChunk getChunkIfLoadedImmediately(int x, int z); // Paper - ifLoaded api (we need this since current impl blocks if the chunk is loading)
     @Nullable
     IChunk func_217353_a(int p_217353_1_, int p_217353_2_, ChunkStatus p_217353_3_, boolean p_217353_4_);
 
diff --git a/src/main/java/net/minecraft/world/Region.java b/src/main/java/net/minecraft/world/Region.java
index 3fd39093336b9699c0561469a91175377c20c68b..db4e38b02cd30e46bdf29b8176b5b454bb7195f6 100644
--- a/src/main/java/net/minecraft/world/Region.java
+++ b/src/main/java/net/minecraft/world/Region.java
@@ -17,6 +17,7 @@ import net.minecraft.world.border.WorldBorder;
 import net.minecraft.world.chunk.AbstractChunkProvider;
 import net.minecraft.world.chunk.EmptyChunk;
 import net.minecraft.world.chunk.IChunk;
+import net.minecraft.world.server.ServerWorld;
 
 public class Region implements IBlockReader, ICollisionReader {
 
@@ -24,7 +25,7 @@ public class Region implements IBlockReader, ICollisionReader {
     protected final int field_72816_b;
     protected final IChunk[][] field_72817_c;
     protected boolean field_72814_d;
-    protected final World field_72815_e;
+    protected final World field_72815_e; protected final World getWorld() { return field_72815_e; } // Paper - OBFHELPER
 
     public Region(World world, BlockPos blockposition, BlockPos blockposition1) {
         this.field_72815_e = world;
@@ -43,7 +44,7 @@ public class Region implements IBlockReader, ICollisionReader {
 
         for (k = this.field_72818_a; k <= i; ++k) {
             for (l = this.field_72816_b; l <= j; ++l) {
-                this.field_72817_c[k - this.field_72818_a][l - this.field_72816_b] = ichunkprovider.func_225313_a(k, l);
+                this.field_72817_c[k - this.field_72818_a][l - this.field_72816_b] = ((ServerWorld)world).E().getChunkAtIfLoadedMainThreadNoCache(k, l); // Paper
             }
         }
 
@@ -68,7 +69,7 @@ public class Region implements IBlockReader, ICollisionReader {
         int k = p_226702_1_ - this.field_72818_a;
         int l = p_226702_2_ - this.field_72816_b;
 
-        if (k >= 0 && k < this.field_72817_c.length && l >= 0 && l < this.field_72817_c[k].length) {
+        if (k >= 0 && k < this.field_72817_c.length && l >= 0 && l < this.field_72817_c[k].length) { // Paper - if this changes, update getChunkIfLoaded below
             IChunk ichunkaccess = this.field_72817_c[k][l];
 
             return (IChunk) (ichunkaccess != null ? ichunkaccess : new EmptyChunk(this.field_72815_e, new ChunkPos(p_226702_1_, p_226702_2_)));
@@ -87,6 +88,29 @@ public class Region implements IBlockReader, ICollisionReader {
         return this.func_226702_a_(p_225522_1_, p_225522_2_);
     }
 
+    // Paper start - if loaded util
+    private IChunk getChunkIfLoaded(int x, int z) {
+        int k = x - this.field_72818_a;
+        int l = z - this.field_72816_b;
+
+        if (k >= 0 && k < this.field_72817_c.length && l >= 0 && l < this.field_72817_c[k].length) {
+            return this.field_72817_c[k][l];
+        }
+        return null;
+    }
+    @Override
+    public FluidState getFluidIfLoaded(BlockPos blockposition) {
+        IChunk chunk = getChunkIfLoaded(blockposition.func_177958_n() >> 4, blockposition.func_177952_p() >> 4);
+        return chunk == null ? null : chunk.func_204610_c(blockposition);
+    }
+
+    @Override
+    public BlockState getTypeIfLoaded(BlockPos blockposition) {
+        IChunk chunk = getChunkIfLoaded(blockposition.func_177958_n() >> 4, blockposition.func_177952_p() >> 4);
+        return chunk == null ? null : chunk.func_180495_p(blockposition);
+    }
+    // Paper end
+
     @Nullable
     @Override
     public TileEntity func_175625_s(BlockPos p_175625_1_) {
diff --git a/src/main/java/net/minecraft/world/World.java b/src/main/java/net/minecraft/world/World.java
index 38469b027cc6cc73f35b6a36f846091e0238d091..9a046d80519ff72c96093322dfd2f0cf1ffa4107 100644
--- a/src/main/java/net/minecraft/world/World.java
+++ b/src/main/java/net/minecraft/world/World.java
@@ -75,6 +75,7 @@ import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.block.CapturedBlockState;
+import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.event.block.BlockPhysicsEvent;
 // CraftBukkit end
@@ -300,6 +301,39 @@ public abstract class World implements IWorld, AutoCloseable {
         return (Chunk) this.func_217348_a(p_212866_1_, p_212866_2_, ChunkStatus.field_222617_m);
     }
 
+    // Paper start - if loaded
+    @Nullable
+    @Override
+    public IChunk getChunkIfLoadedImmediately(int x, int z) {
+        return ((ServerWorld)this).field_241102_C_.getChunkAtIfLoadedImmediately(x, z);
+    }
+
+    @Override
+    public BlockState getTypeIfLoaded(BlockPos blockposition) {
+        // CraftBukkit start - tree generation
+        if (captureTreeGeneration) {
+            CraftBlockState previous = capturedBlockStates.get(blockposition);
+            if (previous != null) {
+                return previous.getHandle();
+            }
+        }
+        // CraftBukkit end
+        if (!func_175701_a(blockposition)) {
+            return Blocks.field_150350_a.func_176223_P();
+        }
+        IChunk chunk = this.getChunkIfLoadedImmediately(blockposition.func_177958_n() >> 4, blockposition.func_177952_p() >> 4);
+
+        return chunk == null ? null : chunk.func_180495_p(blockposition);
+    }
+
+    @Override
+    public FluidState getFluidIfLoaded(BlockPos blockposition) {
+        IChunk chunk = this.getChunkIfLoadedImmediately(blockposition.func_177958_n() >> 4, blockposition.func_177952_p() >> 4);
+
+        return chunk == null ? null : chunk.func_204610_c(blockposition);
+    }
+    // Paper end
+
     @Override
     public IChunk func_217353_a(int p_217353_1_, int p_217353_2_, ChunkStatus p_217353_3_, boolean p_217353_4_) {
         IChunk ichunkaccess = this.func_72863_F().func_212849_a_(p_217353_1_, p_217353_2_, p_217353_3_, p_217353_4_);
@@ -458,8 +492,9 @@ public abstract class World implements IWorld, AutoCloseable {
 
     public void func_217393_a(BlockPos p_217393_1_, BlockState p_217393_2_, BlockState p_217393_3_) {}
 
-    @Override
-    public boolean func_217377_a(BlockPos p_217377_1_, boolean p_217377_2_) {
+    public boolean setAir(BlockPos blockposition) { return this.func_217377_a(blockposition, false); } // Paper - OBFHELPER
+    public boolean setAir(BlockPos blockposition, boolean moved) { return this.func_217377_a(blockposition, moved); } // Paper - OBFHELPER
+    @Override public boolean func_217377_a(BlockPos p_217377_1_, boolean p_217377_2_) { // Paper - OBFHELPER
         FluidState fluid = this.func_204610_c(p_217377_1_);
 
         return this.func_180501_a(p_217377_1_, fluid.func_206883_i(), 3 | (p_217377_2_ ? 64 : 0));
diff --git a/src/main/java/net/minecraft/world/border/WorldBorder.java b/src/main/java/net/minecraft/world/border/WorldBorder.java
index c0f1f377d39076daf7fd4f1f990b9fbebc31bf72..5bc2b8a43fbb433cc79e68274d5983d6df7b4310 100644
--- a/src/main/java/net/minecraft/world/border/WorldBorder.java
+++ b/src/main/java/net/minecraft/world/border/WorldBorder.java
@@ -48,6 +48,7 @@ public class WorldBorder {
         return this.func_177729_b(p_177745_1_.func_226277_ct_(), p_177745_1_.func_226281_cx_());
     }
 
+    public final VoxelShape asVoxelShape(){ return func_222521_a();} // Paper - OBFHELPER
     public VoxelShape func_222521_a() {
         return this.field_212674_i.func_222517_m();
     }
diff --git a/src/main/java/net/minecraft/world/chunk/Chunk.java b/src/main/java/net/minecraft/world/chunk/Chunk.java
index 6d6daaa2cbbc1ba644c33ec3f1ff1cd59da10049..1d547dcd855b5da26ce3711ef93d88fc4c4f3f3f 100644
--- a/src/main/java/net/minecraft/world/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/chunk/Chunk.java
@@ -35,6 +35,7 @@ import net.minecraft.fluid.Fluid;
 import net.minecraft.fluid.FluidState;
 import net.minecraft.fluid.Fluids;
 import net.minecraft.nbt.CompoundNBT;
+import net.minecraft.server.MCUtil;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.util.math.AxisAlignedBB;
 import net.minecraft.util.math.BlockPos;
@@ -54,6 +55,7 @@ import net.minecraft.world.gen.feature.structure.Structure;
 import net.minecraft.world.gen.feature.structure.StructureStart;
 import net.minecraft.world.lighting.WorldLightManager;
 import net.minecraft.world.server.ChunkHolder;
+import net.minecraft.world.server.ServerChunkProvider;
 import net.minecraft.world.server.ServerWorld;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -62,7 +64,7 @@ public class Chunk implements IChunk {
 
     private static final Logger field_150817_t = LogManager.getLogger();
     @Nullable
-    public static final ChunkSection field_186036_a = null;
+    public static final ChunkSection field_186036_a = null; public static final ChunkSection EMPTY_CHUNK_SECTION = field_186036_a; // Paper - OBFHELPER
     private final ChunkSection[] field_76652_q;
     private BiomeContainer field_76651_r;
     private final Map<BlockPos, CompoundNBT> field_201618_i;
@@ -85,7 +87,7 @@ public class Chunk implements IChunk {
     private Supplier<ChunkHolder.LocationType> field_217329_u;
     @Nullable
     private Consumer<Chunk> field_217330_v;
-    private final ChunkPos field_212816_F;
+    private final ChunkPos field_212816_F; public final long coordinateKey; // Paper - cache coordinate key
     private volatile boolean field_217331_x;
 
     public Chunk(World world, ChunkPos chunkcoordintpair, BiomeContainer biomestorage) {
@@ -102,7 +104,7 @@ public class Chunk implements IChunk {
         this.field_201622_t = new ShortList[16];
         this.field_76645_j = (List[]) (new List[16]); // Spigot
         this.field_76637_e = (ServerWorld) world; // CraftBukkit - type
-        this.field_212816_F = chunkcoordintpair;
+        this.field_212816_F = chunkcoordintpair; this.coordinateKey = MCUtil.getCoordinateKey(chunkcoordintpair); // Paper - cache coordinate key
         this.field_196967_n = chunkconverter;
         Heightmap.Type[] aheightmap_type = Heightmap.Type.values();
         int j = aheightmap_type.length;
@@ -145,6 +147,110 @@ public class Chunk implements IChunk {
     public boolean needsDecoration;
     // CraftBukkit end
 
+    // Paper start
+    public final com.destroystokyo.paper.util.maplist.EntityList entities = new com.destroystokyo.paper.util.maplist.EntityList();
+    public ChunkHolder playerChunk;
+
+    static final int NEIGHBOUR_CACHE_RADIUS = 3;
+    public static int getNeighbourCacheRadius() {
+        return NEIGHBOUR_CACHE_RADIUS;
+    }
+
+    boolean loadedTicketLevel;
+    private long neighbourChunksLoadedBitset;
+    private final Chunk[] loadedNeighbourChunks = new Chunk[(NEIGHBOUR_CACHE_RADIUS * 2 + 1) * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)];
+
+    private static int getNeighbourIndex(final int relativeX, final int relativeZ) {
+        // index = (relativeX + NEIGHBOUR_CACHE_RADIUS) + (relativeZ + NEIGHBOUR_CACHE_RADIUS) * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)
+        // optimised variant of the above by moving some of the ops to compile time
+        return relativeX + (relativeZ * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)) + (NEIGHBOUR_CACHE_RADIUS + NEIGHBOUR_CACHE_RADIUS * ((NEIGHBOUR_CACHE_RADIUS * 2 + 1)));
+    }
+
+    public final Chunk getRelativeNeighbourIfLoaded(final int relativeX, final int relativeZ) {
+        return this.loadedNeighbourChunks[getNeighbourIndex(relativeX, relativeZ)];
+    }
+
+    public final boolean isNeighbourLoaded(final int relativeX, final int relativeZ) {
+        return (this.neighbourChunksLoadedBitset & (1L << getNeighbourIndex(relativeX, relativeZ))) != 0;
+    }
+
+    public final void setNeighbourLoaded(final int relativeX, final int relativeZ, final Chunk chunk) {
+        if (chunk == null) {
+            throw new IllegalArgumentException("Chunk must be non-null, neighbour: (" + relativeX + "," + relativeZ + "), chunk: " + this.field_212816_F);
+        }
+        final long before = this.neighbourChunksLoadedBitset;
+        final int index = getNeighbourIndex(relativeX, relativeZ);
+        this.loadedNeighbourChunks[index] = chunk;
+        this.neighbourChunksLoadedBitset |= (1L << index);
+        this.onNeighbourChange(before, this.neighbourChunksLoadedBitset);
+    }
+
+    public final void setNeighbourUnloaded(final int relativeX, final int relativeZ) {
+        final long before = this.neighbourChunksLoadedBitset;
+        final int index = getNeighbourIndex(relativeX, relativeZ);
+        this.loadedNeighbourChunks[index] = null;
+        this.neighbourChunksLoadedBitset &= ~(1L << index);
+        this.onNeighbourChange(before, this.neighbourChunksLoadedBitset);
+    }
+
+    public final void resetNeighbours() {
+        final long before = this.neighbourChunksLoadedBitset;
+        this.neighbourChunksLoadedBitset = 0L;
+        java.util.Arrays.fill(this.loadedNeighbourChunks, null);
+        this.onNeighbourChange(before, 0L);
+    }
+
+    protected void onNeighbourChange(final long bitsetBefore, final long bitsetAfter) {
+
+    }
+
+    public final boolean isAnyNeighborsLoaded() {
+        return neighbourChunksLoadedBitset != 0;
+    }
+    public final boolean areNeighboursLoaded(final int radius) {
+        return Chunk.areNeighboursLoaded(this.neighbourChunksLoadedBitset, radius);
+    }
+
+    public static boolean areNeighboursLoaded(final long bitset, final int radius) {
+        // index = relativeX + (relativeZ * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)) + (NEIGHBOUR_CACHE_RADIUS + NEIGHBOUR_CACHE_RADIUS * ((NEIGHBOUR_CACHE_RADIUS * 2 + 1)))
+        switch (radius) {
+            case 0: {
+                return (bitset & (1L << getNeighbourIndex(0, 0))) != 0;
+            }
+            case 1: {
+                long mask = 0L;
+                for (int dx = -1; dx <= 1; ++dx) {
+                    for (int dz = -1; dz <= 1; ++dz) {
+                        mask |= (1L << getNeighbourIndex(dx, dz));
+                    }
+                }
+                return (bitset & mask) == mask;
+            }
+            case 2: {
+                long mask = 0L;
+                for (int dx = -2; dx <= 2; ++dx) {
+                    for (int dz = -2; dz <= 2; ++dz) {
+                        mask |= (1L << getNeighbourIndex(dx, dz));
+                    }
+                }
+                return (bitset & mask) == mask;
+            }
+            case 3: {
+                long mask = 0L;
+                for (int dx = -3; dx <= 3; ++dx) {
+                    for (int dz = -3; dz <= 3; ++dz) {
+                        mask |= (1L << getNeighbourIndex(dx, dz));
+                    }
+                }
+                return (bitset & mask) == mask;
+            }
+
+            default:
+                throw new IllegalArgumentException("Radius not recognized: " + radius);
+        }
+    }
+    // Paper end
+
     public Chunk(World world, ChunkPrimer protochunk) {
         this(world, protochunk.func_76632_l(), protochunk.func_225549_i_(), protochunk.func_196966_y(), protochunk.func_205218_i_(), protochunk.func_212247_j(), protochunk.func_177416_w(), protochunk.func_76587_i(), (Consumer) null);
         Iterator iterator = protochunk.func_201652_l().iterator();
@@ -250,6 +356,18 @@ public class Chunk implements IChunk {
         }
     }
 
+    // Paper start - If loaded util
+    @Override
+    public FluidState getFluidIfLoaded(BlockPos blockposition) {
+        return this.func_204610_c(blockposition);
+    }
+
+    @Override
+    public BlockState getTypeIfLoaded(BlockPos blockposition) {
+        return this.func_180495_p(blockposition);
+    }
+    // Paper end
+
     @Override
     public FluidState func_204610_c(BlockPos p_204610_1_) {
         return this.func_205751_b(p_204610_1_.func_177958_n(), p_204610_1_.func_177956_o(), p_204610_1_.func_177952_p());
@@ -389,6 +507,7 @@ public class Chunk implements IChunk {
         p_76612_1_.field_70176_ah = this.field_212816_F.field_77276_a;
         p_76612_1_.field_70162_ai = k;
         p_76612_1_.field_70164_aj = this.field_212816_F.field_77275_b;
+        this.entities.add(p_76612_1_); // Paper - per chunk entity list
         this.field_76645_j[k].add(p_76612_1_);
     }
 
@@ -411,6 +530,7 @@ public class Chunk implements IChunk {
         }
 
         this.field_76645_j[p_76608_2_].remove(p_76608_1_);
+        this.entities.remove(p_76608_1_); // Paper
     }
 
     @Override
@@ -432,6 +552,7 @@ public class Chunk implements IChunk {
         return this.func_177424_a(p_175625_1_, Chunk.CreateEntityType.CHECK);
     }
 
+    @Nullable public final TileEntity getTileEntityImmediately(BlockPos pos) { return this.func_177424_a(pos, CreateEntityType.IMMEDIATE); } // Paper - OBFHELPER
     @Nullable
     public TileEntity func_177424_a(BlockPos p_177424_1_, Chunk.CreateEntityType p_177424_2_) {
         // CraftBukkit start
@@ -543,7 +664,25 @@ public class Chunk implements IChunk {
 
     // CraftBukkit start
     public void loadCallback() {
+        // Paper start - neighbour cache
+        int chunkX = this.field_212816_F.field_77276_a;
+        int chunkZ = this.field_212816_F.field_77275_b;
+        ServerChunkProvider chunkProvider = ((ServerWorld)this.field_76637_e).E();
+        for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {
+            for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {
+                Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);
+                if (neighbour != null) {
+                    neighbour.setNeighbourLoaded(-dx, -dz, this);
+                    // should be in cached already
+                    this.setNeighbourLoaded(dx, dz, neighbour);
+                }
+            }
+        }
+        this.setNeighbourLoaded(0, 0, this);
+        this.loadedTicketLevel = true;
+        // Paper end - neighbour cache
         org.bukkit.Server server = this.field_76637_e.getServer();
+        ((ServerWorld)this.field_76637_e).E().addLoadedChunk(this); // Paper
         if (server != null) {
             /*
              * If it's a new world, the first few chunks are generated inside
@@ -582,6 +721,22 @@ public class Chunk implements IChunk {
         server.getPluginManager().callEvent(unloadEvent);
         // note: saving can be prevented, but not forced if no saving is actually required
         this.mustNotSave = !unloadEvent.isSaveChunk();
+        ((ServerWorld)this.field_76637_e).E().removeLoadedChunk(this); // Paper
+        // Paper start - neighbour cache
+        int chunkX = this.field_212816_F.field_77276_a;
+        int chunkZ = this.field_212816_F.field_77275_b;
+        ServerChunkProvider chunkProvider = ((ServerWorld)this.field_76637_e).E();
+        for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {
+            for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {
+                Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);
+                if (neighbour != null) {
+                    neighbour.setNeighbourUnloaded(-dx, -dz);
+                }
+            }
+        }
+        this.loadedTicketLevel = false;
+        this.resetNeighbours();
+        // Paper end
     }
     // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/world/chunk/ChunkPrimer.java b/src/main/java/net/minecraft/world/chunk/ChunkPrimer.java
index 06f28389854c424469875db8e75d64d8f6d18fc5..ad3f642d9b21e88850ff83c275369caec17a16f7 100644
--- a/src/main/java/net/minecraft/world/chunk/ChunkPrimer.java
+++ b/src/main/java/net/minecraft/world/chunk/ChunkPrimer.java
@@ -101,6 +101,18 @@ public class ChunkPrimer implements IChunk {
 
     }
 
+    // Paper start - If loaded util
+    @Override
+    public FluidState getFluidIfLoaded(BlockPos blockposition) {
+        return this.func_204610_c(blockposition);
+    }
+
+    @Override
+    public BlockState getTypeIfLoaded(BlockPos blockposition) {
+        return this.func_180495_p(blockposition);
+    }
+    // Paper end
+
     @Override
     public BlockState func_180495_p(BlockPos p_180495_1_) {
         int i = p_180495_1_.func_177956_o();
diff --git a/src/main/java/net/minecraft/world/chunk/ChunkSection.java b/src/main/java/net/minecraft/world/chunk/ChunkSection.java
index 96014b3dce3cdf6e98d48e3b6d15f8dc55f5749c..58cb2bb64104be1d9acbe5e4f3cfb1bf3f5bcaf8 100644
--- a/src/main/java/net/minecraft/world/chunk/ChunkSection.java
+++ b/src/main/java/net/minecraft/world/chunk/ChunkSection.java
@@ -142,6 +142,7 @@ public class ChunkSection {
         return this.field_177488_d;
     }
 
+    public void writeChunkSection(PacketBuffer packetDataSerializer) { this.func_222630_b(packetDataSerializer); } // Paper - OBFHELPER
     public void func_222630_b(PacketBuffer p_222630_1_) {
         p_222630_1_.writeShort(this.field_76682_b);
         this.field_177488_d.func_186009_b(p_222630_1_);
diff --git a/src/main/java/net/minecraft/world/chunk/storage/IOWorker.java b/src/main/java/net/minecraft/world/chunk/storage/IOWorker.java
index 29704995d818029df3c7d063cb857fa19f48a032..76ad1c450b83412671ea6c84b1871c1ddc3d35ae 100644
--- a/src/main/java/net/minecraft/world/chunk/storage/IOWorker.java
+++ b/src/main/java/net/minecraft/world/chunk/storage/IOWorker.java
@@ -27,7 +27,7 @@ public class IOWorker implements AutoCloseable {
     private static final Logger field_227080_a_ = LogManager.getLogger();
     private final AtomicBoolean field_227082_c_ = new AtomicBoolean();
     private final DelegatedTaskExecutor<ITaskQueue.RunnableWithPriority> field_235969_c_;
-    private final RegionFileCache field_227084_e_;
+    private final RegionFileCache field_227084_e_;public RegionFileCache getRegionFileCache() { return field_227084_e_; } // Paper - OBFHELPER
     private final Map<ChunkPos, IOWorker.Entry> field_227085_f_ = Maps.newLinkedHashMap();
 
     protected IOWorker(File p_i231890_1_, boolean p_i231890_2_, String p_i231890_3_) {
diff --git a/src/main/java/net/minecraft/world/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/chunk/storage/RegionFile.java
index 7a728445a38e9f4b4c83b5b6582e7d5f4896266d..fa3bc0ec1d31368997ae4344ab75f3ceb6c98ee9 100644
--- a/src/main/java/net/minecraft/world/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/chunk/storage/RegionFile.java
@@ -95,6 +95,7 @@ public class RegionFile implements AutoCloseable {
         return this.field_227124_d_.resolve(s);
     }
 
+    @Nullable public synchronized DataInputStream getReadStream(ChunkPos chunkCoordIntPair) throws IOException { return func_222666_a(chunkCoordIntPair);} // Paper - OBFHELPER
     @Nullable
     public synchronized DataInputStream func_222666_a(ChunkPos p_222666_1_) throws IOException {
         int i = this.func_222660_e(p_222666_1_);
diff --git a/src/main/java/net/minecraft/world/gen/WorldGenRegion.java b/src/main/java/net/minecraft/world/gen/WorldGenRegion.java
index 60ab2e9fcb8007a17191c0b0a8f6370a55a44c5d..5f1e7c837a944f41241b9c09a041a73aa60d204e 100644
--- a/src/main/java/net/minecraft/world/gen/WorldGenRegion.java
+++ b/src/main/java/net/minecraft/world/gen/WorldGenRegion.java
@@ -134,6 +134,26 @@ public class WorldGenRegion implements ISeedReader {
         return p_217354_1_ >= this.field_241160_n_.field_77276_a && p_217354_1_ <= this.field_241161_o_.field_77276_a && p_217354_2_ >= this.field_241160_n_.field_77275_b && p_217354_2_ <= this.field_241161_o_.field_77275_b;
     }
 
+    // Paper start - if loaded util
+    @Nullable
+    @Override
+    public IChunk getChunkIfLoadedImmediately(int x, int z) {
+        return this.func_217353_a(x, z, ChunkStatus.field_222617_m, false);
+    }
+
+    @Override
+    public BlockState getTypeIfLoaded(BlockPos blockposition) {
+        IChunk chunk = this.getChunkIfLoadedImmediately(blockposition.func_177958_n() >> 4, blockposition.func_177952_p() >> 4);
+        return chunk == null ? null : chunk.func_180495_p(blockposition);
+    }
+
+    @Override
+    public FluidState getFluidIfLoaded(BlockPos blockposition) {
+        IChunk chunk = this.getChunkIfLoadedImmediately(blockposition.func_177958_n() >> 4, blockposition.func_177952_p() >> 4);
+        return chunk == null ? null : chunk.func_204610_c(blockposition);
+    }
+    // Paper end
+
     @Override
     public BlockState func_180495_p(BlockPos p_180495_1_) {
         return this.func_212866_a_(p_180495_1_.func_177958_n() >> 4, p_180495_1_.func_177952_p() >> 4).func_180495_p(p_180495_1_);
diff --git a/src/main/java/net/minecraft/world/server/ChunkHolder.java b/src/main/java/net/minecraft/world/server/ChunkHolder.java
index 16e144f33f1b7e245a6aa397366640781b754e3a..8cb6196d8fef82d65d9c7b021cb59a9d2a85b573 100644
--- a/src/main/java/net/minecraft/world/server/ChunkHolder.java
+++ b/src/main/java/net/minecraft/world/server/ChunkHolder.java
@@ -40,9 +40,9 @@ public class ChunkHolder {
     private static final List<ChunkStatus> field_219310_e = ChunkStatus.func_222582_a();
     private static final ChunkHolder.LocationType[] field_219311_f = ChunkHolder.LocationType.values();
     private final AtomicReferenceArray<CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>>> field_219312_g;
-    private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> field_222983_h;
-    private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> field_219313_h;
-    private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> field_219314_i;
+    private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> field_222983_h; private int fullChunkCreateCount; private volatile boolean isFullChunkReady; // Paper - cache chunk ticking stage
+    private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> field_219313_h; private volatile boolean isTickingReady; // Paper - cache chunk ticking stage
+    private volatile CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> field_219314_i; private volatile boolean isEntityTickingReady; // Paper - cache chunk ticking stage
     private CompletableFuture<IChunk> field_219315_j;
     public int field_219316_k;
     private int field_219317_l;
@@ -58,6 +58,8 @@ public class ChunkHolder {
     public final ChunkHolder.IPlayerProvider field_219328_w;
     private boolean field_219329_x;
 
+    private final ChunkManager chunkMap; // Paper
+
     public ChunkHolder(ChunkPos chunkcoordintpair, int i, WorldLightManager lightengine, ChunkHolder.IListener playerchunk_c, ChunkHolder.IPlayerProvider playerchunk_d) {
         this.field_219312_g = new AtomicReferenceArray(ChunkHolder.field_219310_e.size());
         this.field_222983_h = ChunkHolder.field_219309_d;
@@ -73,8 +75,47 @@ public class ChunkHolder {
         this.field_219317_l = this.field_219316_k;
         this.field_219318_m = this.field_219316_k;
         this.func_219292_a(i);
+        this.chunkMap = (ChunkManager)playerchunk_d; // Paper
+    }
+
+    // Paper start
+    @Nullable
+    public final Chunk getEntityTickingChunk() {
+        CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> completablefuture = this.field_219314_i;
+        Either<Chunk, ChunkHolder.IChunkLoadingError> either = completablefuture.getNow(null);
+
+        return either == null ? null : either.left().orElse(null);
+    }
+
+    @Nullable
+    public final Chunk getTickingChunk() {
+        CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> completablefuture = this.field_219313_h;
+        Either<Chunk, ChunkHolder.IChunkLoadingError> either = completablefuture.getNow(null);
+
+        return either == null ? null : either.left().orElse(null);
+    }
+
+    @Nullable
+    public final Chunk getFullReadyChunk() {
+        CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> completablefuture = this.field_222983_h;
+        Either<Chunk, ChunkHolder.IChunkLoadingError> either = completablefuture.getNow(null);
+
+        return either == null ? null : either.left().orElse(null);
+    }
+
+    public final boolean isEntityTickingReady() {
+        return this.isEntityTickingReady;
     }
 
+    public final boolean isTickingReady() {
+        return this.isTickingReady;
+    }
+
+    public final boolean isFullChunkReady() {
+        return this.isFullChunkReady;
+    }
+    // Paper end
+
     // CraftBukkit start
     public Chunk getFullChunk() {
         if (!func_219286_c(this.field_219316_k).func_219065_a(ChunkHolder.LocationType.BORDER)) return null; // note: using oldTicketLevel for isLoaded checks
@@ -83,6 +124,14 @@ public class ChunkHolder {
         return either == null ? null : (Chunk) either.left().orElse(null);
     }
     // CraftBukkit end
+    // Paper start - "real" get full chunk immediately
+    public Chunk getFullChunkIfCached() {
+        // Note: Copied from above without ticket level check
+        CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> statusFuture = this.func_219301_a(ChunkStatus.field_222617_m);
+        Either<IChunk, ChunkHolder.IChunkLoadingError> either = (Either<IChunk, ChunkHolder.IChunkLoadingError>) statusFuture.getNow(null);
+        return either == null ? null : (Chunk) either.left().orElse(null);
+    }
+    // Paper end
 
     public CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> func_219301_a(ChunkStatus p_219301_1_) {
         CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> completablefuture = (CompletableFuture) this.field_219312_g.get(p_219301_1_.func_222584_c());
@@ -94,14 +143,17 @@ public class ChunkHolder {
         return func_219278_b(this.field_219317_l).func_209003_a(p_225410_1_) ? this.func_219301_a(p_225410_1_) : ChunkHolder.field_219307_b;
     }
 
+    public final CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> getTickingFuture() { return this.func_219296_a(); } // Paper - OBFHELPER
     public CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> func_219296_a() {
         return this.field_219313_h;
     }
 
+    public final CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> getEntityTickingFuture() { return this.func_219297_b(); } // Paper - OBFHELPER
     public CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> func_219297_b() {
         return this.field_219314_i;
     }
 
+    public final CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> getFullChunkFuture() { return this.func_223492_c(); } // Paper - OBFHELPER
     public CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> func_223492_c() {
         return this.field_222983_h;
     }
@@ -343,13 +395,27 @@ public class ChunkHolder {
 
         this.field_219329_x |= flag3;
         if (!flag2 && flag3) {
-            this.field_222983_h = p_219291_1_.func_222961_b(this);
+            // Paper start - cache ticking ready status
+            int expectCreateCount = ++this.fullChunkCreateCount;
+            this.field_222983_h = p_219291_1_.func_222961_b(this); this.field_222983_h.thenAccept((either) -> {
+                if (either.left().isPresent() && ChunkHolder.this.fullChunkCreateCount == expectCreateCount) {
+                    // note: Here is a very good place to add callbacks to logic waiting on this.
+                    Chunk fullChunk = either.left().get();
+                    ChunkHolder.this.isFullChunkReady = true;
+                    fullChunk.playerChunk = ChunkHolder.this;
+
+
+                }
+            });
+            // Paper end
             this.func_219284_a(this.field_222983_h);
         }
 
         if (flag2 && !flag3) {
             completablefuture = this.field_222983_h;
             this.field_222983_h = ChunkHolder.field_219309_d;
+            ++this.fullChunkCreateCount; // Paper - cache ticking ready status
+            this.isFullChunkReady = false; // Paper - cache ticking ready status
             this.func_219284_a(((CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>>) completablefuture).thenApply((either1) -> { // CraftBukkit - decompile error
                 p_219291_1_.getClass();
                 return either1.ifLeft(p_219291_1_::func_222973_a);
@@ -360,12 +426,24 @@ public class ChunkHolder {
         boolean flag5 = playerchunk_state1.func_219065_a(ChunkHolder.LocationType.TICKING);
 
         if (!flag4 && flag5) {
-            this.field_219313_h = p_219291_1_.func_219179_a(this);
+            // Paper start - cache ticking ready status
+            this.field_219313_h = p_219291_1_.func_219179_a(this); this.field_219313_h.thenAccept((either) -> {
+                if (either.left().isPresent()) {
+                    // note: Here is a very good place to add callbacks to logic waiting on this.
+                    Chunk tickingChunk = either.left().get();
+                    ChunkHolder.this.isTickingReady = true;
+
+
+
+
+                }
+            });
+            // Paper end
             this.func_219284_a(this.field_219313_h);
         }
 
         if (flag4 && !flag5) {
-            this.field_219313_h.complete(ChunkHolder.field_219308_c);
+            this.field_219313_h.complete(ChunkHolder.field_219308_c); this.isTickingReady = false; // Paper - cache chunk ticking stage
             this.field_219313_h = ChunkHolder.field_219309_d;
         }
 
@@ -377,12 +455,24 @@ public class ChunkHolder {
                 throw (IllegalStateException) Util.func_229757_c_(new IllegalStateException());
             }
 
-            this.field_219314_i = p_219291_1_.func_219188_b(this.field_219319_n);
+            // Paper start - cache ticking ready status
+            this.field_219314_i = p_219291_1_.func_219188_b(this.field_219319_n); this.field_219314_i.thenAccept((either) -> {
+                if (either.left().isPresent()) {
+                    // note: Here is a very good place to add callbacks to logic waiting on this.
+                    Chunk entityTickingChunk = either.left().get();
+                    ChunkHolder.this.isEntityTickingReady = true;
+
+
+
+
+                }
+            });
+            // Paper end
             this.func_219284_a(this.field_219314_i);
         }
 
         if (flag6 && !flag7) {
-            this.field_219314_i.complete(ChunkHolder.field_219308_c);
+            this.field_219314_i.complete(ChunkHolder.field_219308_c); this.isEntityTickingReady = false; // Paper - cache chunk ticking stage
             this.field_219314_i = ChunkHolder.field_219309_d;
         }
 
diff --git a/src/main/java/net/minecraft/world/server/ChunkManager.java b/src/main/java/net/minecraft/world/server/ChunkManager.java
index 1f3b61e27a6574bc0b3beeea5caabc8b4a84b03b..45f4011f500257881cb60a8d48c704b0d94924dc 100644
--- a/src/main/java/net/minecraft/world/server/ChunkManager.java
+++ b/src/main/java/net/minecraft/world/server/ChunkManager.java
@@ -60,6 +60,7 @@ import net.minecraft.network.play.server.SSetPassengersPacket;
 import net.minecraft.network.play.server.SUpdateChunkPositionPacket;
 import net.minecraft.network.play.server.SUpdateLightPacket;
 import net.minecraft.profiler.IProfiler;
+import net.minecraft.server.MCUtil;
 import net.minecraft.util.CSVWriter;
 import net.minecraft.util.Util;
 import net.minecraft.util.concurrent.DelegatedTaskExecutor;
@@ -150,6 +151,26 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
     };
     // CraftBukkit end
 
+    // Paper start - distance maps
+    private final com.destroystokyo.paper.util.misc.PooledLinkedHashSets<ServerPlayerEntity> pooledLinkedPlayerHashSets = new com.destroystokyo.paper.util.misc.PooledLinkedHashSets<>();
+
+    void addPlayerToDistanceMaps(ServerPlayerEntity player) {
+        int chunkX = MCUtil.getChunkCoordinate(player.func_226277_ct_());
+        int chunkZ = MCUtil.getChunkCoordinate(player.func_226281_cx_());
+        // Note: players need to be explicitly added to distance maps before they can be updated
+    }
+
+    void removePlayerFromDistanceMaps(ServerPlayerEntity player) {
+
+    }
+
+    void updateMaps(ServerPlayerEntity player) {
+        int chunkX = MCUtil.getChunkCoordinate(player.func_226277_ct_());
+        int chunkZ = MCUtil.getChunkCoordinate(player.func_226281_cx_());
+        // Note: players need to be explicitly added to distance maps before they can be updated
+    }
+    // Paper end
+
     public ChunkManager(ServerWorld worldserver, SaveFormat.LevelSave convertable_conversionsession, DataFixer datafixer, TemplateManager definedstructuremanager, Executor executor, ThreadTaskExecutor<Runnable> iasynctaskhandler, IChunkLightProvider ilightaccess, ChunkGenerator chunkgenerator, IChunkStatusListener worldloadlistener, Supplier<DimensionSavedDataManager> supplier, int i, boolean flag) {
         super(new File(convertable_conversionsession.func_237291_a_(worldserver.func_234923_W_()), "region"), datafixer, flag);
         this.field_219252_f = this.field_219251_e.clone();
@@ -239,6 +260,14 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
         };
     }
 
+    // Paper start
+    public final int getEffectiveViewDistance() {
+        // TODO this needs to be checked on update
+        // Mojang currently sets it to +1 of the configured view distance. So subtract one to get the one we really want.
+        return this.field_219247_A - 1;
+    }
+    // Paper end
+
     private CompletableFuture<Either<List<IChunk>, ChunkHolder.IChunkLoadingError>> func_219236_a(ChunkPos p_219236_1_, int p_219236_2_, IntFunction<ChunkStatus> p_219236_3_) {
         List<CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>>> list = Lists.newArrayList();
         int j = p_219236_1_.field_77276_a;
@@ -949,6 +978,7 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
             if (!flag1) {
                 this.field_219267_u.func_219341_a(SectionPos.func_218157_a((Entity) p_219234_1_), p_219234_1_);
             }
+            this.addPlayerToDistanceMaps(p_219234_1_); // Paper - distance maps
         } else {
             SectionPos sectionposition = p_219234_1_.func_213842_M();
 
@@ -956,6 +986,7 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
             if (!flag2) {
                 this.field_219267_u.func_219367_b(sectionposition, p_219234_1_);
             }
+            this.removePlayerFromDistanceMaps(p_219234_1_); // Paper - distance maps
         }
 
         for (int k = i - this.field_219247_A; k <= i + this.field_219247_A; ++k) {
@@ -1066,6 +1097,8 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
             }
         }
 
+        this.updateMaps(p_219183_1_); // Paper - distance maps
+
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/server/ServerChunkProvider.java b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
index 4c7f3ff749137b607bdcf7b9edad993707eaaa01..99aab094b5956b2cff43d7c3d0fed67c50d1bfd1 100644
--- a/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
+++ b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
@@ -21,6 +21,8 @@ import net.minecraft.entity.Entity;
 import net.minecraft.entity.player.ServerPlayerEntity;
 import net.minecraft.network.IPacket;
 import net.minecraft.profiler.IProfiler;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.Util;
 import net.minecraft.util.concurrent.ThreadTaskExecutor;
 import net.minecraft.util.math.BlockPos;
@@ -50,7 +52,7 @@ public class ServerChunkProvider extends AbstractChunkProvider {
     private final TicketManager field_217240_d;
     public final ChunkGenerator field_186029_c;
     private final ServerWorld field_73251_h;
-    private final Thread field_217241_g;
+    public final Thread field_217241_g; // Paper - private -> public
     private final ServerWorldLightManager field_217242_h;
     private final ServerChunkProvider.ChunkExecutor field_217243_i;
     public final ChunkManager field_217237_a;
@@ -63,6 +65,167 @@ public class ServerChunkProvider extends AbstractChunkProvider {
     private final IChunk[] field_222877_p = new IChunk[4];
     @Nullable
     private WorldEntitySpawner.EntityDensityManager field_241097_p_;
+    // Paper start
+    final com.destroystokyo.paper.util.concurrent.WeakSeqLock loadedChunkMapSeqLock = new com.destroystokyo.paper.util.concurrent.WeakSeqLock();
+    final it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<Chunk> loadedChunkMap = new it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap<>(8192, 0.5f);
+
+    private final Chunk[] lastLoadedChunks = new Chunk[4 * 4];
+    private final long[] lastLoadedChunkKeys = new long[4 * 4];
+
+    {
+        java.util.Arrays.fill(this.lastLoadedChunkKeys, MCUtil.INVALID_CHUNK_KEY);
+    }
+
+    private static int getCacheKey(int x, int z) {
+        return x & 3 | ((z & 3) << 2);
+    }
+
+    void addLoadedChunk(Chunk chunk) {
+        this.loadedChunkMapSeqLock.acquireWrite();
+        try {
+            this.loadedChunkMap.put(chunk.coordinateKey, chunk);
+        } finally {
+            this.loadedChunkMapSeqLock.releaseWrite();
+        }
+
+        // rewrite cache if we have to
+        // we do this since we also cache null chunks
+        int cacheKey = getCacheKey(chunk.func_76632_l().field_77276_a, chunk.func_76632_l().field_77275_b);
+
+        long cachedKey = this.lastLoadedChunkKeys[cacheKey];
+        if (cachedKey == chunk.coordinateKey) {
+            this.lastLoadedChunks[cacheKey] = chunk;
+        }
+    }
+
+    void removeLoadedChunk(Chunk chunk) {
+        this.loadedChunkMapSeqLock.acquireWrite();
+        try {
+            this.loadedChunkMap.remove(chunk.coordinateKey);
+        } finally {
+            this.loadedChunkMapSeqLock.releaseWrite();
+        }
+
+        // rewrite cache if we have to
+        // we do this since we also cache null chunks
+        int cacheKey = getCacheKey(chunk.func_76632_l().field_77276_a, chunk.func_76632_l().field_77275_b);
+
+        long cachedKey = this.lastLoadedChunkKeys[cacheKey];
+        if (cachedKey == chunk.coordinateKey) {
+            this.lastLoadedChunks[cacheKey] = null;
+        }
+    }
+
+    public Chunk getChunkAtIfLoadedMainThread(int x, int z) {
+        int cacheKey = getCacheKey(x, z);
+        long chunkKey = MCUtil.getCoordinateKey(x, z);
+
+        long cachedKey = this.lastLoadedChunkKeys[cacheKey];
+        if (cachedKey == chunkKey) {
+            return this.lastLoadedChunks[cacheKey];
+        }
+
+        Chunk ret = this.loadedChunkMap.get(chunkKey);
+
+        this.lastLoadedChunkKeys[cacheKey] = chunkKey;
+        this.lastLoadedChunks[cacheKey] = ret;
+
+        return ret;
+    }
+
+    public Chunk getChunkAtIfLoadedMainThreadNoCache(int x, int z) {
+        return this.loadedChunkMap.get(MCUtil.getCoordinateKey(x, z));
+    }
+
+    public Chunk getChunkAtMainThread(int x, int z) {
+        Chunk ret = this.getChunkAtIfLoadedMainThread(x, z);
+        if (ret != null) {
+            return ret;
+        }
+        return (Chunk)this.func_212849_a_(x, z, ChunkStatus.field_222617_m, true);
+    }
+
+    private long chunkFutureAwaitCounter;
+
+    public void getEntityTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
+        if (Thread.currentThread() != this.field_217241_g) {
+            this.field_217243_i.execute(() -> {
+                ServerChunkProvider.this.getEntityTickingChunkAsync(x, z, onLoad);
+            });
+            return;
+        }
+        this.getChunkFutureAsynchronously(x, z, 31, ChunkHolder::getEntityTickingFuture, onLoad);
+    }
+
+    public void getTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
+        if (Thread.currentThread() != this.field_217241_g) {
+            this.field_217243_i.execute(() -> {
+                ServerChunkProvider.this.getTickingChunkAsync(x, z, onLoad);
+            });
+            return;
+        }
+        this.getChunkFutureAsynchronously(x, z, 32, ChunkHolder::getTickingFuture, onLoad);
+    }
+
+    public void getFullChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
+        if (Thread.currentThread() != this.field_217241_g) {
+            this.field_217243_i.execute(() -> {
+                ServerChunkProvider.this.getFullChunkAsync(x, z, onLoad);
+            });
+            return;
+        }
+        this.getChunkFutureAsynchronously(x, z, 33, ChunkHolder::getFullChunkFuture, onLoad);
+    }
+
+    private void getChunkFutureAsynchronously(int x, int z, int ticketLevel, Function<ChunkHolder, CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>>> futureGet, java.util.function.Consumer<Chunk> onLoad) {
+        if (Thread.currentThread() != this.field_217241_g) {
+            throw new IllegalStateException();
+        }
+        ChunkPos chunkPos = new ChunkPos(x, z);
+        Long identifier = Long.valueOf(this.chunkFutureAwaitCounter++);
+        this.field_217240_d.addTicketAtLevel(TicketType.FUTURE_AWAIT, chunkPos, ticketLevel, identifier);
+        this.func_217235_l();
+
+        ChunkHolder chunk = this.field_217237_a.func_219220_a(chunkPos.func_201841_a());
+
+        if (chunk == null) {
+            throw new IllegalStateException("Expected playerchunk " + chunkPos + " in world '" + this.field_73251_h.getWorld().getName() + "'");
+        }
+
+        CompletableFuture<Either<Chunk, ChunkHolder.IChunkLoadingError>> future = futureGet.apply(chunk);
+
+        future.whenCompleteAsync((either, throwable) -> {
+            try {
+                if (throwable != null) {
+                    if (throwable instanceof ThreadDeath) {
+                        throw (ThreadDeath)throwable;
+                    }
+                    MinecraftServer.field_147145_h.fatal("Failed to complete future await for chunk " + chunkPos.toString() + " in world '" + ServerChunkProvider.this.field_73251_h.getWorld().getName() + "'", throwable);
+                } else if (either.right().isPresent()) {
+                    MinecraftServer.field_147145_h.fatal("Failed to complete future await for chunk " + chunkPos.toString() + " in world '" + ServerChunkProvider.this.field_73251_h.getWorld().getName() + "': " + either.right().get().toString());
+                }
+
+                try {
+                    if (onLoad != null) {
+                        field_217237_a.callbackExecutor.execute(() -> {
+                            onLoad.accept(either == null ? null : either.left().orElse(null)); // indicate failure to the callback.
+                        });
+                    }
+                } catch (Throwable thr) {
+                    if (thr instanceof ThreadDeath) {
+                        throw (ThreadDeath)thr;
+                    }
+                    MinecraftServer.field_147145_h.fatal("Load callback for future await failed " + chunkPos.toString() + " in world '" + ServerChunkProvider.this.field_73251_h.getWorld().getName() + "'", thr);
+                    return;
+                }
+            } finally {
+                // due to odd behaviour with CB unload implementation we need to have these AFTER the load callback.
+                ServerChunkProvider.this.field_217240_d.addTicketAtLevel(TicketType.field_219494_g, chunkPos, ticketLevel, chunkPos);
+                ServerChunkProvider.this.field_217240_d.removeTicketAtLevel(TicketType.FUTURE_AWAIT, chunkPos, ticketLevel, identifier);
+            }
+        }, this.field_217243_i);
+    }
+    // Paper end
 
     public ServerChunkProvider(ServerWorld worldserver, SaveFormat.LevelSave convertable_conversionsession, DataFixer datafixer, TemplateManager definedstructuremanager, Executor executor, ChunkGenerator chunkgenerator, int i, boolean flag, IChunkStatusListener worldloadlistener, Supplier<DimensionSavedDataManager> supplier) {
         this.field_73251_h = worldserver;
@@ -116,6 +279,49 @@ public class ServerChunkProvider extends AbstractChunkProvider {
         this.field_222877_p[0] = p_225315_2_;
     }
 
+    // Paper start - "real" get chunk if loaded
+    // Note: Partially copied from the getChunkAt method below
+    @Nullable
+    public Chunk getChunkAtIfCachedImmediately(int x, int z) {
+        long k = ChunkPos.func_77272_a(x, z);
+
+        // Note: Bypass cache since we need to check ticket level, and to make this MT-Safe
+
+        ChunkHolder playerChunk = this.func_217213_a(k);
+        if (playerChunk == null) {
+            return null;
+        }
+
+        return playerChunk.getFullChunkIfCached();
+    }
+
+    @Nullable
+    public Chunk getChunkAtIfLoadedImmediately(int x, int z) {
+        long k = ChunkPos.func_77272_a(x, z);
+
+        if (Thread.currentThread() == this.field_217241_g) {
+            return this.getChunkAtIfLoadedMainThread(x, z);
+        }
+
+        Chunk ret = null;
+        long readlock;
+        do {
+            readlock = this.loadedChunkMapSeqLock.acquireRead();
+            try {
+                ret = this.loadedChunkMap.get(k);
+            } catch (Throwable thr) {
+                if (thr instanceof ThreadDeath) {
+                    throw (ThreadDeath)thr;
+                }
+                // re-try, this means a CME occurred...
+                continue;
+            }
+        } while (!this.loadedChunkMapSeqLock.tryReleaseRead(readlock));
+
+        return ret;
+    }
+    // Paper end
+
     @Nullable
     @Override
     public IChunk func_212849_a_(int p_212849_1_, int p_212849_2_, ChunkStatus p_212849_3_, boolean p_212849_4_) {
@@ -398,10 +604,9 @@ public class ServerChunkProvider extends AbstractChunkProvider {
 
             this.field_241097_p_ = spawnercreature_d;
             this.field_73251_h.func_217381_Z().func_76319_b();
-            List<ChunkHolder> list = Lists.newArrayList(this.field_217237_a.func_223491_f());
-
-            Collections.shuffle(list);
-            list.forEach((playerchunk) -> {
+            //List<PlayerChunk> list = Lists.newArrayList(this.playerChunkMap.f()); // Paper
+            //Collections.shuffle(list); // Paper
+            this.field_217237_a.func_223491_f().forEach((playerchunk) -> { // Paper - no... just no...
                 Optional<Chunk> optional = ((Either) playerchunk.func_219296_a().getNow(ChunkHolder.field_219308_c)).left();
 
                 if (optional.isPresent()) {
diff --git a/src/main/java/net/minecraft/world/server/ServerWorld.java b/src/main/java/net/minecraft/world/server/ServerWorld.java
index 6a7aa8951810ed501375e18162f8deaedea9ef3c..56547aa014f7aacddce63b48afa9fa058dec4e68 100644
--- a/src/main/java/net/minecraft/world/server/ServerWorld.java
+++ b/src/main/java/net/minecraft/world/server/ServerWorld.java
@@ -158,7 +158,7 @@ public class ServerWorld extends World implements ISeedReader {
     private final Map<UUID, Entity> field_175741_N = Maps.newHashMap();
     private final Queue<Entity> field_217499_z = Queues.newArrayDeque();
     private final List<ServerPlayerEntity> field_217491_A = Lists.newArrayList();
-    private final ServerChunkProvider field_241102_C_;
+    public final ServerChunkProvider field_241102_C_; // Paper - public
     boolean field_217492_a;
     private final MinecraftServer field_73061_a;
     public final ServerWorldInfo field_241103_E_; // CraftBukkit - type
diff --git a/src/main/java/net/minecraft/world/server/TicketType.java b/src/main/java/net/minecraft/world/server/TicketType.java
index de9008442894446a1d6d37ed0ca119fd2d9d4a88..04114c39a533fe7b3dce27d3a7bcc33973444b31 100644
--- a/src/main/java/net/minecraft/world/server/TicketType.java
+++ b/src/main/java/net/minecraft/world/server/TicketType.java
@@ -25,6 +25,7 @@ public class TicketType<T> {
     public static final TicketType<ChunkPos> field_219494_g = func_223183_a("unknown", Comparator.comparingLong(ChunkPos::func_201841_a), 1);
     public static final TicketType<Unit> PLUGIN = func_219484_a("plugin", (a, b) -> 0); // CraftBukkit
     public static final TicketType<org.bukkit.plugin.Plugin> PLUGIN_TICKET = func_219484_a("plugin_ticket", (plugin1, plugin2) -> plugin1.getClass().getName().compareTo(plugin2.getClass().getName())); // CraftBukkit
+    public static final TicketType<Long> FUTURE_AWAIT = func_219484_a("future_await", Long::compareTo); // Paper
 
     public static <T> TicketType<T> func_219484_a(String p_219484_0_, Comparator<T> p_219484_1_) {
         return new TicketType<>(p_219484_0_, p_219484_1_, 0L);
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
index 1858aac59bd6f8e294f707f6028bf4e1eb060a83..bac338570832a1c79966bf1eb0775db1f38d32ad 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
@@ -85,6 +85,7 @@ public final class CraftItemStack extends ItemStack {
     }
 
     net.minecraft.item.ItemStack handle;
+    public net.minecraft.item.ItemStack getHandle() { return handle; } // Paper
 
     /**
      * Mirror
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
index 9ad17c560c8d99a396543ab9f97c34de648f6544..18f29de500890589e448b3b769cfe593ea064d6b 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
@@ -43,6 +43,7 @@ import org.bukkit.scheduler.BukkitWorker;
  */
 public class CraftScheduler implements BukkitScheduler {
 
+    static Plugin MINECRAFT = new MinecraftInternalPlugin();
     /**
      * Counter for IDs. Order doesn't matter, only uniqueness.
      */
@@ -177,6 +178,11 @@ public class CraftScheduler implements BukkitScheduler {
         runTaskTimer(plugin, (Object) task, delay, period);
     }
 
+    public BukkitTask scheduleInternalTask(Runnable run, int delay, String taskName) {
+        final CraftTask task = new CraftTask(run, nextId(), taskName);
+        return handle(task, delay);
+    }
+
     public BukkitTask runTaskTimer(Plugin plugin, Object runnable, long delay, long period) {
         validate(plugin, runnable);
         if (delay < 0L) {
@@ -400,13 +406,20 @@ public class CraftScheduler implements BukkitScheduler {
                     task.run();
                     task.timings.stopTiming(); // Spigot
                 } catch (final Throwable throwable) {
-                    task.getOwner().getLogger().log(
+                    // Paper start
+                    String msg = String.format(
+                        "Task #%s for %s generated an exception",
+                        task.getTaskId(),
+                        task.getOwner().getDescription().getFullName());
+                    if (task.getOwner() == MINECRAFT) {
+                        net.minecraft.server.MinecraftServer.field_147145_h.error(msg, throwable);
+                    } else {
+                        task.getOwner().getLogger().log(
                             Level.WARNING,
-                            String.format(
-                                "Task #%s for %s generated an exception",
-                                task.getTaskId(),
-                                task.getOwner().getDescription().getFullName()),
+                            msg,
                             throwable);
+                    }
+                    // Paper end
                 } finally {
                     currentTask = null;
                 }
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
index 3f55381c152b9841b524f623c9b32360e97cb8ed..d85e21b75054067b926ecfee89d62c6dd0744189 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftTask.java
@@ -39,6 +39,21 @@ public class CraftTask implements BukkitTask, Runnable { // Spigot
     CraftTask(final Object task) {
         this(null, task, CraftTask.NO_REPEATING, CraftTask.NO_REPEATING);
     }
+    // Paper start
+    public String taskName = null;
+    boolean internal = false;
+    CraftTask(final Object task, int id, String taskName) {
+        this.rTask = (Runnable) task;
+        this.cTask = null;
+        this.plugin = CraftScheduler.MINECRAFT;
+        this.taskName = taskName;
+        this.internal = true;
+        this.id = id;
+        this.period = CraftTask.NO_REPEATING;
+        this.taskName = taskName;
+        this.timings = null; // Will be changed in later patch
+    }
+    // Paper end
 
     CraftTask(final Plugin plugin, final Object task, final int id, final long period) {
         this.plugin = plugin;
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
new file mode 100644
index 0000000000000000000000000000000000000000..49dc0c441b9dd7e7745cf15ced67f383ebee1f99
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
@@ -0,0 +1,132 @@
+package org.bukkit.craftbukkit.scheduler;
+
+
+import org.bukkit.Server;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.configuration.file.FileConfiguration;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.plugin.PluginBase;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoader;
+import org.bukkit.plugin.PluginLogger;
+
+import java.io.File;
+import java.io.InputStream;
+import java.util.List;
+
+public class MinecraftInternalPlugin extends PluginBase {
+    private boolean enabled = true;
+
+    private final String pluginName;
+    private PluginDescriptionFile pdf;
+
+    public MinecraftInternalPlugin() {
+        this.pluginName = "Minecraft";
+        pdf = new PluginDescriptionFile(pluginName, "1.0", "nms");
+    }
+
+    public void setEnabled(boolean enabled) {
+        this.enabled = enabled;
+    }
+
+    @Override
+    public File getDataFolder() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public PluginDescriptionFile getDescription() {
+        return pdf;
+    }
+
+    @Override
+    public FileConfiguration getConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public InputStream getResource(String filename) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void saveConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void saveDefaultConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void saveResource(String resourcePath, boolean replace) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void reloadConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public PluginLogger getLogger() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public PluginLoader getPluginLoader() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public Server getServer() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    @Override
+    public void onDisable() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void onLoad() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void onEnable() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public boolean isNaggable() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void setNaggable(boolean canNag) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public ChunkGenerator getDefaultWorldGenerator(String worldName, String id) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/util/DummyGeneratorAccess.java b/src/main/java/org/bukkit/craftbukkit/util/DummyGeneratorAccess.java
index 339fc35240f5ae8a36ce4f42ce14d6f8d7daad45..33b8147b9838b6ba1569d6b719da005323f8dd6d 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/DummyGeneratorAccess.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/DummyGeneratorAccess.java
@@ -187,4 +187,22 @@ public class DummyGeneratorAccess implements IWorld {
     public boolean func_241212_a_(BlockPos p_241212_1_, boolean p_241212_2_, Entity p_241212_3_, int p_241212_4_) {
         throw new UnsupportedOperationException("Not supported yet.");
     }
+
+    // Paper start - if loaded util
+    @javax.annotation.Nullable
+    @Override
+    public IChunk getChunkIfLoadedImmediately(int x, int z) {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+
+    @Override
+    public BlockState getTypeIfLoaded(BlockPos blockposition) {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+
+    @Override
+    public FluidState getFluidIfLoaded(BlockPos blockposition) {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java b/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java
index 1aec70a1f1a9d8fd2cd06bde4033e19e769ab331..f72c13bedaa6fa45e26f5dcad564835bdd4af61f 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java
@@ -17,7 +17,7 @@ import java.util.RandomAccess;
 public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable {
     private static final long serialVersionUID = 8683452581112892191L;
 
-    private transient Object[] data;
+    private transient Object[] data; public final Object[] getRawDataArray() { return this.data; } // Paper - expose for raw get
     private int size;
     private int initialCapacity;
 
