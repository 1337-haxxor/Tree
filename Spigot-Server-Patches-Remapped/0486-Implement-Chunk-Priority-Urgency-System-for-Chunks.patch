From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sat, 11 Apr 2020 03:56:07 -0400
Subject: [PATCH] Implement Chunk Priority / Urgency System for Chunks

Mark chunks that are blocking main thread for world generation as urgent

Implements a general priority system so that chunks that are sorted in
the generator queues can prioritize certain chunks over another.

Urgent chunks will jump to the front of the line, ensuring that a
sync chunk load on an ungenerated chunk does not lag the server for
a long period of time if the servers generator queues are filled with
lots of chunks already.

This massively reduces the lag spikes from sync chunk gens.

Then we further prioritize loading order so nearby chunks have higher
priority than distant chunks, reducing the pressure a high no tick
view distance holds on you.

Chunks in front of the player have higher priority, to help with
fast traveling players keep up with their movement.

diff --git a/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java b/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java
index 96b1c40e7fe7edfbe743bd29397b0ea6cda4f358..62124ceaf68108ea38081b276588893a3b3621bb 100644
--- a/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java
+++ b/src/main/java/com/destroystokyo/paper/io/chunk/ChunkTaskManager.java
@@ -4,9 +4,11 @@ import com.destroystokyo.paper.io.PaperFileIOThread;
 import com.destroystokyo.paper.io.IOUtil;
 import com.destroystokyo.paper.io.PrioritizedTaskQueue;
 import com.destroystokyo.paper.io.QueueExecutorThread;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import net.minecraft.nbt.CompoundNBT;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.concurrent.ThreadTaskExecutor;
+import net.minecraft.world.chunk.ChunkStatus;
 import net.minecraft.world.chunk.IChunk;
 import net.minecraft.world.chunk.storage.ChunkSerializer;
 import net.minecraft.world.server.ChunkHolder;
@@ -106,7 +108,7 @@ public final class ChunkTaskManager {
     }
 
     static void dumpChunkInfo(Set<ChunkHolder> seenChunks, ChunkHolder chunkHolder, int x, int z) {
-        dumpChunkInfo(seenChunks, chunkHolder, x, z, 0, 1);
+        dumpChunkInfo(seenChunks, chunkHolder, x, z, 0, 4);
     }
 
     static void dumpChunkInfo(Set<ChunkHolder> seenChunks, ChunkHolder chunkHolder, int x, int z, int indent, int maxDepth) {
@@ -127,6 +129,30 @@ public final class ChunkTaskManager {
             PaperFileIOThread.LOGGER.log(Level.ERROR, indentStr + "Chunk Status - " + ((chunk == null) ? "null chunk" : chunk.func_201589_g().toString()));
             PaperFileIOThread.LOGGER.log(Level.ERROR, indentStr + "Chunk Ticket Status - "  + ChunkHolder.func_219278_b(chunkHolder.func_219299_i()));
             PaperFileIOThread.LOGGER.log(Level.ERROR, indentStr + "Chunk Holder Status - " + ((holderStatus == null) ? "null" : holderStatus.toString()));
+            PaperFileIOThread.LOGGER.log(Level.ERROR, indentStr + "Chunk Holder Priority - " + chunkHolder.getCurrentPriority());
+
+            if (!chunkHolder.neighbors.isEmpty()) {
+                if (indent >= maxDepth) {
+                    PaperFileIOThread.LOGGER.log(Level.ERROR, indentStr + "Chunk Neighbors: (Can't show, too deeply nested)");
+                    return;
+                }
+                PaperFileIOThread.LOGGER.log(Level.ERROR, indentStr + "Chunk Neighbors: ");
+                for (ChunkHolder neighbor : chunkHolder.neighbors.keySet()) {
+                    ChunkStatus status = neighbor.getChunkHolderStatus();
+                    if (status != null && status.isAtLeastStatus(ChunkHolder.func_219278_b(neighbor.func_219299_i()))) {
+                        continue;
+                    }
+                    int nx = neighbor.field_219319_n.field_77276_a;
+                    int nz = neighbor.field_219319_n.field_77275_b;
+                    if (seenChunks.contains(neighbor)) {
+                        PaperFileIOThread.LOGGER.log(Level.ERROR, indentStr + "  " + nx + "," + nz + " in " + chunkHolder.getWorld().getWorld().getName() + " (CIRCULAR)");
+                        continue;
+                    }
+                    PaperFileIOThread.LOGGER.log(Level.ERROR, indentStr + "  " + nx + "," + nz + " in " + chunkHolder.getWorld().getWorld().getName() + ":");
+                    dumpChunkInfo(seenChunks, neighbor, nx, nz, indent + 1, maxDepth);
+                }
+            }
+
         }
     }
 
diff --git a/src/main/java/net/minecraft/entity/player/ServerPlayerEntity.java b/src/main/java/net/minecraft/entity/player/ServerPlayerEntity.java
index cc6e6c70787250cd9660d0ad6ba6d8dc20023944..846facf59072d5939399a820cc81c0ef66fb1737 100644
--- a/src/main/java/net/minecraft/entity/player/ServerPlayerEntity.java
+++ b/src/main/java/net/minecraft/entity/player/ServerPlayerEntity.java
@@ -96,6 +96,7 @@ import net.minecraft.scoreboard.ScoreCriteria;
 import net.minecraft.scoreboard.ScorePlayerTeam;
 import net.minecraft.scoreboard.Scoreboard;
 import net.minecraft.scoreboard.Team;
+import net.minecraft.server.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.management.PlayerInteractionManager;
 import net.minecraft.server.management.PlayerList;
@@ -184,6 +185,12 @@ public class ServerPlayerEntity extends PlayerEntity implements IContainerListen
     private int field_184854_bX = Integer.MIN_VALUE;
     private int field_184855_bY = Integer.MIN_VALUE;
     private int field_184856_bZ = Integer.MIN_VALUE;
+    public long lastHighPriorityChecked; // Paper
+    public void forceCheckHighPriority() {
+        lastHighPriorityChecked = -1;
+        func_71121_q().func_72863_F().field_217237_a.checkHighPriorityChunks(this);
+    }
+    public boolean isRealPlayer; // Paper
     private float field_71149_ch = -1.0E8F;
     private int field_71146_ci = -99999999;
     private boolean field_71147_cj = true;
@@ -269,6 +276,21 @@ public class ServerPlayerEntity extends PlayerEntity implements IContainerListen
         this.maxHealthCache = this.func_110138_aP();
         this.cachedSingleMobDistanceMap = new com.destroystokyo.paper.util.PooledHashSets.PooledObjectLinkedOpenHashSet<>(this); // Paper
     }
+    // Paper start
+    public BlockPos getPointInFront(double inFront) {
+        double rads = Math.toRadians(MCUtil.normalizeYaw(this.field_70177_z+90)); // MC rotates yaw 90 for some odd reason
+        final double x = func_226277_ct_() + inFront * Math.cos(rads);
+        final double z = func_226281_cx_() + inFront * Math.sin(rads);
+        return new BlockPos(x, func_226278_cu_(), z);
+    }
+
+    public ChunkPos getChunkInFront(double inFront) {
+        double rads = Math.toRadians(MCUtil.normalizeYaw(this.field_70177_z+90)); // MC rotates yaw 90 for some odd reason
+        final double x = func_226277_ct_() + (inFront * 16) * Math.cos(rads);
+        final double z = func_226281_cx_() + (inFront * 16) * Math.sin(rads);
+        return new ChunkPos(MathHelper.func_76128_c(x) >> 4, MathHelper.func_76128_c(z) >> 4);
+    }
+    // Paper end
 
     // Yes, this doesn't match Vanilla, but it's the best we can do for now.
     // If this is an issue, PRs are welcome
@@ -616,6 +638,7 @@ public class ServerPlayerEntity extends PlayerEntity implements IContainerListen
             if (valid && !this.func_175149_v() || this.field_70170_p.func_175667_e(this.func_233580_cy_())) { // Paper - don't tick dead players that are not in the world currently (pending respawn)
                 super.func_70071_h_();
             }
+            if (valid && func_70089_S() && field_71135_a != null) ((ServerWorld)field_70170_p).func_72863_F().field_217237_a.checkHighPriorityChunks(this); // Paper
 
             for (int i = 0; i < this.field_71071_by.func_70302_i_(); ++i) {
                 ItemStack itemstack = this.field_71071_by.func_70301_a(i);
diff --git a/src/main/java/net/minecraft/network/play/ServerPlayNetHandler.java b/src/main/java/net/minecraft/network/play/ServerPlayNetHandler.java
index cfac465b31ccad54a924906e0d186a4a8d089fc3..90d41b4bdd8de09e52697afc4e0329d1970056c2 100644
--- a/src/main/java/net/minecraft/network/play/ServerPlayNetHandler.java
+++ b/src/main/java/net/minecraft/network/play/ServerPlayNetHandler.java
@@ -1515,6 +1515,7 @@ public class ServerPlayNetHandler implements IServerPlayNetHandler {
 
         this.field_184343_A = this.field_147368_e;
         this.field_147369_b.func_70080_a(d0, d1, d2, f, f1);
+        this.field_147369_b.forceCheckHighPriority(); // Paper
         this.field_147369_b.field_71135_a.func_147359_a(new SPlayerPositionLookPacket(d0 - d3, d1 - d4, d2 - d5, f - f2, f1 - f3, set, this.field_184363_z));
     }
 
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index 1cc5efce09b1e4f02995d3f3607fb02abc02923c..d9d21e8fe5d4a16eca007d8e3d4a6688e64fa990 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -673,6 +673,7 @@ public final class MCUtil {
                 chunkData.addProperty("x", playerChunk.field_219319_n.field_77276_a);
                 chunkData.addProperty("z", playerChunk.field_219319_n.field_77275_b);
                 chunkData.addProperty("ticket-level", playerChunk.func_219299_i());
+                chunkData.addProperty("priority", playerChunk.getCurrentPriority());
                 chunkData.addProperty("state", ChunkHolder.func_219286_c(playerChunk.func_219299_i()).toString());
                 chunkData.addProperty("queued-for-unload", chunkMap.field_219261_o.contains(playerChunk.field_219319_n.func_201841_a()));
                 chunkData.addProperty("status", status == null ? "unloaded" : status.toString());
diff --git a/src/main/java/net/minecraft/server/management/PlayerList.java b/src/main/java/net/minecraft/server/management/PlayerList.java
index fbd809c8cd02ef1aff1841dc0df514a25de8f235..34e119515a21d31528f278563a8db35fa2ba93f4 100644
--- a/src/main/java/net/minecraft/server/management/PlayerList.java
+++ b/src/main/java/net/minecraft/server/management/PlayerList.java
@@ -273,8 +273,8 @@ public abstract class PlayerList {
         final ChunkPos pos = new ChunkPos(chunkX, chunkZ);
         ChunkManager playerChunkMap = worldserver1.func_72863_F().field_217237_a;
         playerChunkMap.field_219267_u.addTicketAtLevel(TicketType.LOGIN, pos, 31, pos.func_201841_a());
-        worldserver1.func_72863_F().func_217235_l();
-        worldserver1.func_72863_F().getChunkAtAsynchronously(chunkX, chunkZ, true, true).thenApply(chunk -> {
+        worldserver1.func_72863_F().markAreaHighPriority(pos, 28, 3);
+        worldserver1.func_72863_F().getChunkAtAsynchronously(chunkX, chunkZ, true, false).thenApply(chunk -> {
             ChunkHolder updatingChunk = playerChunkMap.func_219220_a(pos.func_201841_a());
             if (updatingChunk != null) {
                 return updatingChunk.getEntityTickingFuture();
@@ -693,6 +693,7 @@ public abstract class PlayerList {
         SocketAddress socketaddress = loginlistener.field_147333_a.func_74430_c();
 
         ServerPlayerEntity entity = new ServerPlayerEntity(this.field_72400_f, this.field_72400_f.func_71218_a(World.field_234918_g_), gameprofile, new PlayerInteractionManager(this.field_72400_f.func_71218_a(World.field_234918_g_)));
+        entity.isRealPlayer = true; // Paper
         Player player = entity.getBukkitEntity();
         PlayerLoginEvent event = new PlayerLoginEvent(player, hostname, ((java.net.InetSocketAddress) socketaddress).getAddress(), ((java.net.InetSocketAddress) loginlistener.field_147333_a.getRawAddress()).getAddress());
 
@@ -899,6 +900,7 @@ public abstract class PlayerList {
         // CraftBukkit end
 
         worldserver1.func_72863_F().func_217228_a(TicketType.field_223185_g, new ChunkPos(location.getBlockX() >> 4, location.getBlockZ() >> 4), 1, entityplayer.func_145782_y()); // Paper
+        entityplayer1.forceCheckHighPriority(); // Player
         while (avoidSuffocation && !worldserver1.func_226669_j_(entityplayer1) && entityplayer1.func_226278_cu_() < 256.0D) {
             entityplayer1.func_70107_b(entityplayer1.func_226277_ct_(), entityplayer1.func_226278_cu_() + 1.0D, entityplayer1.func_226281_cx_());
         }
diff --git a/src/main/java/net/minecraft/util/math/ChunkPos.java b/src/main/java/net/minecraft/util/math/ChunkPos.java
index 86782a2fe5d744ec0821cf1e216ffde9422eec7d..2430f023866f6360cbd29e3b21e74916a1056af1 100644
--- a/src/main/java/net/minecraft/util/math/ChunkPos.java
+++ b/src/main/java/net/minecraft/util/math/ChunkPos.java
@@ -103,6 +103,7 @@ public class ChunkPos {
         return "[" + this.field_77276_a + ", " + this.field_77275_b + "]";
     }
 
+    public final BlockPos asPosition() { return func_206849_h(); } // Paper - OBFHELPER
     public BlockPos func_206849_h() {
         return new BlockPos(this.func_180334_c(), 0, this.func_180333_d());
     }
diff --git a/src/main/java/net/minecraft/world/server/ChunkHolder.java b/src/main/java/net/minecraft/world/server/ChunkHolder.java
index ae4e5ce5f0f0f9b17841224e21ce386f55027c52..573a7fe1e9f21723db85c671dbd1980d257bba65 100644
--- a/src/main/java/net/minecraft/world/server/ChunkHolder.java
+++ b/src/main/java/net/minecraft/world/server/ChunkHolder.java
@@ -1,6 +1,7 @@
 package net.minecraft.world.server;
 
 import com.mojang.datafixers.util.Either;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
 import it.unimi.dsi.fastutil.shorts.ShortArraySet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
 import java.util.List;
@@ -52,8 +53,8 @@ public class ChunkHolder {
     private CompletableFuture<IChunk> field_219315_j;
     public int field_219316_k;
     private int field_219317_l;
-    private int field_219318_m;
-    final ChunkPos field_219319_n; // Paper - private -> package
+    volatile int field_219318_m; public final int getCurrentPriority() { return field_219318_m; } // Paper - OBFHELPER - make volatile since this is concurrently accessed
+    public final ChunkPos field_219319_n; // Paper - private -> public
     private boolean field_244382_p;
     private final ShortSet[] field_244383_q;
     private int field_219324_s;
@@ -65,6 +66,7 @@ public class ChunkHolder {
     private boolean field_244384_x;
 
     private final ChunkManager chunkMap; // Paper
+    public ServerWorld getWorld() { return chunkMap.field_219255_i; } // Paper
 
     long lastAutoSaveTime; // Paper - incremental autosave
     long inactiveTimeStart; // Paper - incremental autosave
@@ -92,6 +94,120 @@ public class ChunkHolder {
         return null;
     }
     // Paper end - no-tick view distance
+    // Paper start - Chunk gen/load priority system
+    volatile int neighborPriority = -1;
+    volatile int priorityBoost = 0;
+    public final java.util.concurrent.ConcurrentHashMap<ChunkHolder, ChunkStatus> neighbors = new java.util.concurrent.ConcurrentHashMap<>();
+    public final Long2ObjectOpenHashMap<Integer> neighborPriorities = new Long2ObjectOpenHashMap<>();
+
+    private int getDemandedPriority() {
+        int priority = neighborPriority; // if we have a neighbor priority, use it
+        int myPriority = getMyPriority();
+
+        if (priority == -1 || (field_219317_l <= 33 && priority > myPriority)) {
+            priority = myPriority;
+        }
+
+        return Math.max(1, Math.min(Math.max(field_219317_l, ChunkManager.field_219249_a), priority));
+    }
+
+    private int getMyPriority() {
+        if (priorityBoost == TicketManager.URGENT_PRIORITY) {
+            return 2; // Urgent - ticket level isn't always 31 so 33-30 = 3, but allow 1 more tasks to go below this for dependents
+        }
+        return field_219317_l - priorityBoost;
+    }
+
+    private int getNeighborsPriority() {
+        return (neighborPriorities.isEmpty() ? getMyPriority() : getDemandedPriority()) + 1;
+    }
+
+    public void onNeighborRequest(ChunkHolder neighbor, ChunkStatus status) {
+        neighbor.setNeighborPriority(this, getNeighborsPriority());
+        this.neighbors.compute(neighbor, (playerChunk, currentWantedStatus) -> {
+            if (currentWantedStatus == null || !currentWantedStatus.isAtLeastStatus(status)) {
+                //System.out.println(this + " request " + neighbor + " at " + status + " currently " + currentWantedStatus);
+                return status;
+            } else {
+                //System.out.println(this + " requested " + neighbor + " at " + status + " but thats lower than other wanted status " + currentWantedStatus);
+                return currentWantedStatus;
+            }
+        });
+
+    }
+
+    public void onNeighborDone(ChunkHolder neighbor, ChunkStatus chunkstatus, IChunk chunk) {
+        this.neighbors.compute(neighbor, (playerChunk, wantedStatus) -> {
+            if (wantedStatus != null && chunkstatus.isAtLeastStatus(wantedStatus)) {
+                //System.out.println(this + " neighbor done at " + neighbor + " for status " + chunkstatus + " wanted " + wantedStatus);
+                neighbor.removeNeighborPriority(this);
+                return null;
+            } else {
+                //System.out.println(this + " neighbor finished our previous request at " + neighbor + " for status " + chunkstatus + " but we now want instead " + wantedStatus);
+                return wantedStatus;
+            }
+        });
+    }
+
+    private void removeNeighborPriority(ChunkHolder requester) {
+        synchronized (neighborPriorities) {
+            neighborPriorities.remove(requester.field_219319_n.func_201841_a());
+            recalcNeighborPriority();
+        }
+        checkPriority();
+    }
+
+
+    private void setNeighborPriority(ChunkHolder requester, int priority) {
+        synchronized (neighborPriorities) {
+            neighborPriorities.put(requester.field_219319_n.func_201841_a(), Integer.valueOf(priority));
+            recalcNeighborPriority();
+        }
+        checkPriority();
+    }
+
+    private void recalcNeighborPriority() {
+        neighborPriority = -1;
+        if (!neighborPriorities.isEmpty()) {
+            synchronized (neighborPriorities) {
+                for (Integer neighbor : neighborPriorities.values()) {
+                    if (neighbor < neighborPriority || neighborPriority == -1) {
+                        neighborPriority = neighbor;
+                    }
+                }
+            }
+        }
+    }
+    private void checkPriority() {
+        if (getCurrentPriority() != getDemandedPriority()) this.chunkMap.queueHolderUpdate(this);
+    }
+
+    public final double getDistance(ServerPlayerEntity player) {
+        return getDistance(player.func_226277_ct_(), player.func_226281_cx_());
+    }
+    public final double getDistance(double blockX, double blockZ) {
+        int cx = MCUtil.fastFloor(blockX) >> 4;
+        int cz = MCUtil.fastFloor(blockZ) >> 4;
+        final double x = field_219319_n.field_77276_a - cx;
+        final double z = field_219319_n.field_77275_b - cz;
+        return (x * x) + (z * z);
+    }
+
+    public final double getDistanceFrom(BlockPos pos) {
+        return getDistance(pos.func_177958_n(), pos.func_177952_p());
+    }
+
+    @Override
+    public String toString() {
+        return "PlayerChunk{" +
+            "location=" + field_219319_n +
+            ", ticketLevel=" + field_219317_l + "/" + func_219278_b(this.field_219317_l) +
+            ", chunkHolderStatus=" + getChunkHolderStatus() +
+            ", neighborPriority=" + getNeighborsPriority() +
+            ", priority=(" + field_219317_l + " - " + priorityBoost +" vs N " + neighborPriority + ") = " + getDemandedPriority() + " A " + getCurrentPriority() +
+            '}';
+    }
+    // Paper end
 
     public ChunkHolder(ChunkPos chunkcoordintpair, int i, WorldLightManager lightengine, ChunkHolder.IListener playerchunk_c, ChunkHolder.IPlayerProvider playerchunk_d) {
         this.field_219312_g = new AtomicReferenceArray(ChunkHolder.field_219310_e.size());
@@ -190,6 +306,18 @@ public class ChunkHolder {
         }
         return null;
     }
+    public static ChunkStatus getNextStatus(ChunkStatus status) {
+        if (status == ChunkStatus.field_222617_m) {
+            return status;
+        }
+        return field_219310_e.get(status.getStatusIndex() + 1);
+    }
+    public CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> getStatusFutureUncheckedMain(ChunkStatus chunkstatus) {
+        return ensureMain(func_219301_a(chunkstatus));
+    }
+    public <T> CompletableFuture<T> ensureMain(CompletableFuture<T> future) {
+        return future.thenApplyAsync(r -> r, chunkMap.mainInvokingExecutor);
+    }
     // Paper end
 
     public CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> func_219301_a(ChunkStatus p_219301_1_) {
@@ -436,6 +564,7 @@ public class ChunkHolder {
         return this.field_219318_m;
     }
 
+    private void setPriority(int i) { func_219275_d(i); } // Paper - OBFHELPER
     private void func_219275_d(int p_219275_1_) {
         this.field_219318_m = p_219275_1_;
     }
@@ -454,7 +583,7 @@ public class ChunkHolder {
         // CraftBukkit start
         // ChunkUnloadEvent: Called before the chunk is unloaded: isChunkLoaded is still true and chunk can still be modified by plugins.
         if (playerchunk_state.func_219065_a(ChunkHolder.LocationType.BORDER) && !playerchunk_state1.func_219065_a(ChunkHolder.LocationType.BORDER)) {
-            this.func_219301_a(ChunkStatus.field_222617_m).thenAccept((either) -> {
+            this.getStatusFutureUncheckedMain(ChunkStatus.field_222617_m).thenAccept((either) -> { // Paper - ensure main
                 Chunk chunk = (Chunk)either.left().orElse(null);
                 if (chunk != null) {
                     p_219291_1_.callbackExecutor.execute(() -> {
@@ -519,12 +648,13 @@ public class ChunkHolder {
         if (!flag2 && flag3) {
             // Paper start - cache ticking ready status
             int expectCreateCount = ++this.fullChunkCreateCount;
-            this.field_222983_h = p_219291_1_.func_222961_b(this); this.field_222983_h.thenAccept((either) -> {
+            this.field_222983_h = p_219291_1_.func_222961_b(this); ensureMain(this.field_222983_h).thenAccept((either) -> { // Paper - ensure main
                 if (either.left().isPresent() && ChunkHolder.this.fullChunkCreateCount == expectCreateCount) {
                     // note: Here is a very good place to add callbacks to logic waiting on this.
                     Chunk fullChunk = either.left().get();
                     ChunkHolder.this.isFullChunkReady = true;
                     fullChunk.playerChunk = ChunkHolder.this;
+                    this.chunkMap.field_219267_u.clearPriorityTickets(field_219319_n);
 
 
                 }
@@ -549,7 +679,7 @@ public class ChunkHolder {
 
         if (!flag4 && flag5) {
             // Paper start - cache ticking ready status
-            this.field_219313_h = p_219291_1_.func_219179_a(this); this.field_219313_h.thenAccept((either) -> {
+            this.field_219313_h = p_219291_1_.func_219179_a(this); ensureMain(this.field_219313_h).thenAccept((either) -> { // Paper - ensure main
                 if (either.left().isPresent()) {
                     // note: Here is a very good place to add callbacks to logic waiting on this.
                     Chunk tickingChunk = either.left().get();
@@ -580,7 +710,7 @@ public class ChunkHolder {
             }
 
             // Paper start - cache ticking ready status
-            this.field_219314_i = p_219291_1_.func_219188_b(this.field_219319_n); this.field_219314_i.thenAccept((either) -> {
+            this.field_219314_i = p_219291_1_.func_219188_b(this.field_219319_n); ensureMain(this.field_219314_i).thenAccept((either) -> { // Paper ensureMain
                 if (either.left().isPresent()) {
                     // note: Here is a very good place to add callbacks to logic waiting on this.
                     Chunk entityTickingChunk = either.left().get();
@@ -600,12 +730,29 @@ public class ChunkHolder {
             this.field_219314_i = ChunkHolder.field_219309_d;
         }
 
-        this.field_219327_v.func_219066_a(this.field_219319_n, this::func_219281_j, this.field_219317_l, this::func_219275_d);
+        // Paper start - raise IO/load priority if priority changes, use our preferred priority
+        priorityBoost = chunkMap.field_219267_u.getChunkPriority(field_219319_n);
+        int priority = getDemandedPriority();
+        if (getCurrentPriority() > priority) {
+            int ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY;
+            if (priority <= 10) {
+                ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
+            } else if (priority <= 20) {
+                ioPriority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY;
+            }
+            chunkMap.field_219255_i.asyncChunkTaskManager.raisePriority(field_219319_n.field_77276_a, field_219319_n.field_77275_b, ioPriority);
+        }
+        if (getCurrentPriority() != priority) {
+            this.field_219327_v.func_219066_a(this.field_219319_n, this::getCurrentPriority, priority, this::setPriority); // use preferred priority
+            int neighborsPriority = getNeighborsPriority();
+            this.neighbors.forEach((neighbor, neighborDesired) -> neighbor.setNeighborPriority(this, neighborsPriority));
+        }
+        // Paper end
         this.field_219316_k = this.field_219317_l;
         // CraftBukkit start
         // ChunkLoadEvent: Called after the chunk is loaded: isChunkLoaded returns true and chunk is ready to be modified by plugins.
         if (!playerchunk_state.func_219065_a(ChunkHolder.LocationType.BORDER) && playerchunk_state1.func_219065_a(ChunkHolder.LocationType.BORDER)) {
-            this.func_219301_a(ChunkStatus.field_222617_m).thenAccept((either) -> {
+            this.getStatusFutureUncheckedMain(ChunkStatus.field_222617_m).thenAccept((either) -> { // Paper - ensure main
                 Chunk chunk = (Chunk)either.left().orElse(null);
                 if (chunk != null) {
                     p_219291_1_.callbackExecutor.execute(() -> {
@@ -687,6 +834,7 @@ public class ChunkHolder {
 
     public interface IListener {
 
+        default void changePriority(ChunkPos chunkcoordintpair, IntSupplier intsupplier, int i, IntConsumer intconsumer) { func_219066_a(chunkcoordintpair, intsupplier, i, intconsumer); } // Paper - OBFHELPER
         void func_219066_a(ChunkPos p_219066_1_, IntSupplier p_219066_2_, int p_219066_3_, IntConsumer p_219066_4_);
     }
 
diff --git a/src/main/java/net/minecraft/world/server/ChunkManager.java b/src/main/java/net/minecraft/world/server/ChunkManager.java
index 543a49b196682829bde55bbae64f0b7a50fb2295..49423081b6d86235457f4286fa4e95a8f5cb9b56 100644
--- a/src/main/java/net/minecraft/world/server/ChunkManager.java
+++ b/src/main/java/net/minecraft/world/server/ChunkManager.java
@@ -14,6 +14,7 @@ import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap; // Paper
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.longs.LongIterator;
@@ -76,6 +77,7 @@ import net.minecraft.util.Util;
 import net.minecraft.util.concurrent.DelegatedTaskExecutor;
 import net.minecraft.util.concurrent.ITaskExecutor;
 import net.minecraft.util.concurrent.ThreadTaskExecutor;
+import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.SectionPos;
@@ -108,6 +110,7 @@ import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.bukkit.entity.Player; // CraftBukkit
+import org.spigotmc.AsyncCatcher;
 
 public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProvider {
 
@@ -145,6 +148,7 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
     public final ServerWorld field_219255_i;
     private final ServerWorldLightManager field_219256_j;
     private final ThreadTaskExecutor<Runnable> field_219257_k;
+    final java.util.concurrent.Executor mainInvokingExecutor; // Paper
     public final ChunkGenerator field_219258_l;
     private final Supplier<DimensionSavedDataManager> field_219259_m; public final Supplier<DimensionSavedDataManager> getWorldPersistentDataSupplier() { return this.field_219259_m; } // Paper - OBFHELPER
     private final PointOfInterestManager field_219260_n;
@@ -182,6 +186,7 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
 
         @Override
         public void execute(Runnable runnable) {
+            AsyncCatcher.catchOp("Callback Executor execute");
             if (queued == null) {
                 queued = new java.util.ArrayDeque<>();
             }
@@ -190,6 +195,7 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
 
         @Override
         public void run() {
+            AsyncCatcher.catchOp("Callback Executor run");
             if (queued == null) {
                 return;
             }
@@ -344,6 +350,15 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
         this.field_219255_i = worldserver;
         this.field_219258_l = chunkgenerator;
         this.field_219257_k = iasynctaskhandler;
+        // Paper start
+        this.mainInvokingExecutor = (run) -> {
+            if (MCUtil.isMainThread()) {
+                run.run();
+            } else {
+                iasynctaskhandler.execute(run);
+            }
+        };
+        // Paper end
         DelegatedTaskExecutor<Runnable> threadedmailbox = DelegatedTaskExecutor.func_213144_a(executor, "worldgen");
 
         iasynctaskhandler.getClass();
@@ -438,6 +453,7 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
         this.playerViewDistanceTickMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
             (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
              com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> newState) -> {
+                checkHighPriorityChunks(player);
                 if (newState.size() != 1) {
                     return;
                 }
@@ -456,7 +472,11 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
                 }
                 ChunkPos chunkPos = new ChunkPos(rangeX, rangeZ);
                 ChunkManager.this.field_219255_i.func_72863_F().removeTicketAtLevel(TicketType.field_219490_c, chunkPos, 31, chunkPos); // entity ticking level, TODO check on update
-            });
+                ChunkManager.this.field_219255_i.func_72863_F().clearPriorityTickets(chunkPos);
+            }, (player, prevPos, newPos) -> {
+            player.lastHighPriorityChecked = -1; // reset and recheck
+            checkHighPriorityChunks(player);
+        });
         this.playerViewDistanceNoTickMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
         this.playerViewDistanceBroadcastMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
             (ServerPlayerEntity player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
@@ -473,6 +493,115 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
             });
         // Paper end - no-tick view distance
     }
+    // Paper start - Chunk Prioritization
+    public void queueHolderUpdate(ChunkHolder playerchunk) {
+        Runnable runnable = () -> {
+            if (isUnloading(playerchunk)) {
+                return; // unloaded
+            }
+            field_219267_u.field_219383_k.add(playerchunk);
+            if (!field_219267_u.pollingPendingChunkUpdates) {
+                field_219255_i.func_72863_F().func_217235_l();
+            }
+        };
+        if (MCUtil.isMainThread()) {
+            // We can't use executor here because it will not execute tasks if its currently in the middle of executing tasks...
+            runnable.run();
+        } else {
+            field_219257_k.execute(runnable);
+        }
+    }
+
+    private boolean isUnloading(ChunkHolder playerchunk) {
+        return playerchunk == null || field_219261_o.contains(playerchunk.field_219319_n.func_201841_a());
+    }
+
+    private void updateChunkPriorityMap(Long2IntOpenHashMap map, long chunk, int level) {
+        int prev = map.getOrDefault(chunk, -1);
+        if (level > prev) {
+            map.put(chunk, level);
+        }
+    }
+
+    public void checkHighPriorityChunks(ServerPlayerEntity player) {
+        int currentTick = MinecraftServer.currentTick;
+        if (currentTick - player.lastHighPriorityChecked < 20 || !player.isRealPlayer) { // weed out fake players
+            return;
+        }
+        player.lastHighPriorityChecked = currentTick;
+        Long2IntOpenHashMap priorities = new Long2IntOpenHashMap();
+
+        int viewDistance = getEffectiveNoTickViewDistance();
+        BlockPos.Mutable pos = new BlockPos.Mutable();
+
+        // Prioritize circular near
+        double playerChunkX = MathHelper.func_76128_c(player.func_226277_ct_()) >> 4;
+        double playerChunkZ = MathHelper.func_76128_c(player.func_226281_cx_()) >> 4;
+        pos.setValues(player.func_226277_ct_(), 0, player.func_226281_cx_());
+        double twoThirdModifier = 2D / 3D;
+        MCUtil.getSpiralOutChunks(pos, Math.min(6, viewDistance)).forEach(coord -> {
+            if (shouldSkipPrioritization(coord)) return;
+
+            double dist = MCUtil.distance(playerChunkX, 0, playerChunkZ, coord.field_77276_a, 0, coord.field_77275_b);
+            // Prioritize immediate
+            if (dist <= 4) {
+                updateChunkPriorityMap(priorities, coord.func_201841_a(), (int) (27 - dist));
+                return;
+            }
+
+            // Prioritize nearby chunks
+            updateChunkPriorityMap(priorities, coord.func_201841_a(), (int) (20 - dist * twoThirdModifier));
+        });
+
+        // Prioritize Frustum near 3
+        ChunkPos front3 = player.getChunkInFront(3);
+        pos.setValues(front3.field_77276_a << 4, 0, front3.field_77275_b << 4);
+        MCUtil.getSpiralOutChunks(pos, Math.min(5, viewDistance)).forEach(coord -> {
+            if (shouldSkipPrioritization(coord)) return;
+
+            double dist = MCUtil.distance(playerChunkX, 0, playerChunkZ, coord.field_77276_a, 0, coord.field_77275_b);
+            updateChunkPriorityMap(priorities, coord.func_201841_a(), (int) (25 - dist * twoThirdModifier));
+        });
+
+        // Prioritize Frustum near 5
+        if (viewDistance > 4) {
+            ChunkPos front5 = player.getChunkInFront(5);
+            pos.setValues(front5.field_77276_a << 4, 0, front5.field_77275_b << 4);
+            MCUtil.getSpiralOutChunks(pos, 4).forEach(coord -> {
+                if (shouldSkipPrioritization(coord)) return;
+
+                double dist = MCUtil.distance(playerChunkX, 0, playerChunkZ, coord.field_77276_a, 0, coord.field_77275_b);
+                updateChunkPriorityMap(priorities, coord.func_201841_a(), (int) (25 - dist * twoThirdModifier));
+            });
+        }
+
+        // Prioritize Frustum far 7
+        if (viewDistance > 6) {
+            ChunkPos front7 = player.getChunkInFront(7);
+            pos.setValues(front7.field_77276_a << 4, 0, front7.field_77275_b << 4);
+            MCUtil.getSpiralOutChunks(pos, 3).forEach(coord -> {
+                if (shouldSkipPrioritization(coord)) {
+                    return;
+                }
+                double dist = MCUtil.distance(playerChunkX, 0, playerChunkZ, coord.field_77276_a, 0, coord.field_77275_b);
+                updateChunkPriorityMap(priorities, coord.func_201841_a(), (int) (25 - dist * twoThirdModifier));
+            });
+        }
+
+        if (priorities.isEmpty()) return;
+        field_219267_u.delayDistanceManagerTick = true;
+        priorities.long2IntEntrySet().fastForEach(entry -> field_219267_u.markHighPriority(new ChunkPos(entry.getLongKey()), entry.getIntValue()));
+        field_219267_u.delayDistanceManagerTick = false;
+        field_219255_i.func_72863_F().func_217235_l();
+
+    }
+
+    private boolean shouldSkipPrioritization(ChunkPos coord) {
+        if (playerViewDistanceNoTickMap.getObjectsInRange(coord.func_201841_a()) == null) return true;
+        ChunkHolder chunk = func_219220_a(coord.func_201841_a());
+        return chunk != null && (chunk.isFullChunkReady());
+    }
+    // Paper end
 
     public void updatePlayerMobTypeMap(Entity entity) {
         if (!this.field_219255_i.paperConfig.perPlayerMobSpawns) {
@@ -602,6 +731,7 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
         List<CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>>> list = Lists.newArrayList();
         int j = p_219236_1_.field_77276_a;
         int k = p_219236_1_.field_77275_b;
+        ChunkHolder requestingNeighbor = func_219220_a(p_219236_1_.func_201841_a()); // Paper
 
         for (int l = -p_219236_2_; l <= p_219236_2_; ++l) {
             for (int i1 = -p_219236_2_; i1 <= p_219236_2_; ++i1) {
@@ -620,6 +750,14 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
 
                 ChunkStatus chunkstatus = (ChunkStatus) p_219236_3_.apply(j1);
                 CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> completablefuture = playerchunk.func_219276_a(chunkstatus, this);
+                // Paper start
+                if (requestingNeighbor != null && requestingNeighbor != playerchunk && !completablefuture.isDone()) {
+                    requestingNeighbor.onNeighborRequest(playerchunk, chunkstatus);
+                    completablefuture.thenAccept(either -> {
+                        requestingNeighbor.onNeighborDone(playerchunk, chunkstatus, either.left().orElse(null));
+                    });
+                }
+                // Paper end
 
                 list.add(completablefuture);
             }
@@ -1087,14 +1225,22 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
         };
 
         CompletableFuture<CompoundNBT> chunkSaveFuture = this.field_219255_i.asyncChunkTaskManager.getChunkSaveFuture(p_223172_1_.field_77276_a, p_223172_1_.field_77275_b);
+        ChunkHolder playerChunk = func_219220_a(p_223172_1_.func_201841_a());
+        int chunkPriority = playerChunk != null ? playerChunk.getCurrentPriority() : 33;
+        int priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY;
+
+        if (chunkPriority <= 10) {
+            priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
+        } else if (chunkPriority <= 20) {
+            priority = com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY;
+        }
+        boolean isHighestPriority = priority == com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY;
         if (chunkSaveFuture != null) {
-            this.field_219255_i.asyncChunkTaskManager.scheduleChunkLoad(p_223172_1_.field_77276_a, p_223172_1_.field_77275_b,
-                com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY, chunkHolderConsumer, false, chunkSaveFuture);
-            this.field_219255_i.asyncChunkTaskManager.raisePriority(p_223172_1_.field_77276_a, p_223172_1_.field_77275_b, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGH_PRIORITY);
+            this.field_219255_i.asyncChunkTaskManager.scheduleChunkLoad(p_223172_1_.field_77276_a, p_223172_1_.field_77275_b, priority, chunkHolderConsumer, isHighestPriority, chunkSaveFuture);
         } else {
-            this.field_219255_i.asyncChunkTaskManager.scheduleChunkLoad(p_223172_1_.field_77276_a, p_223172_1_.field_77275_b,
-                com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY, chunkHolderConsumer, false);
+            this.field_219255_i.asyncChunkTaskManager.scheduleChunkLoad(p_223172_1_.field_77276_a, p_223172_1_.field_77275_b, priority, chunkHolderConsumer, isHighestPriority);
         }
+        this.field_219255_i.asyncChunkTaskManager.raisePriority(p_223172_1_.field_77276_a, p_223172_1_.field_77275_b, priority);
         return ret;
         // Paper end
     }
@@ -1231,7 +1377,7 @@ public class ChunkManager extends ChunkLoader implements ChunkHolder.IPlayerProv
             long i = p_219200_1_.func_219277_h().func_201841_a();
 
             p_219200_1_.getClass();
-            mailbox.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219069_a(runnable, i, p_219200_1_::func_219299_i));
+            mailbox.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219069_a(runnable, i, () -> 1)); // Paper - final loads are always urgent!
         });
     }
 
diff --git a/src/main/java/net/minecraft/world/server/ServerChunkProvider.java b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
index 37d8608c47faec3d66a805e34462ab9786dd4635..9380d3e3e0335215766bd7fb79164460258c69f2 100644
--- a/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
+++ b/src/main/java/net/minecraft/world/server/ServerChunkProvider.java
@@ -472,6 +472,26 @@ public class ServerChunkProvider extends AbstractChunkProvider {
     public <T> void removeTicketAtLevel(TicketType<T> ticketType, ChunkPos chunkPos, int ticketLevel, T identifier) {
         this.field_217240_d.removeTicketAtLevel(ticketType, chunkPos, ticketLevel, identifier);
     }
+
+    public boolean markUrgent(ChunkPos coords) {
+        return this.field_217240_d.markUrgent(coords);
+    }
+
+    public boolean markHighPriority(ChunkPos coords, int priority) {
+        return this.field_217240_d.markHighPriority(coords, priority);
+    }
+
+    public void markAreaHighPriority(ChunkPos center, int priority, int radius) {
+        this.field_217240_d.markAreaHighPriority(center, priority, radius);
+    }
+
+    public void clearAreaPriorityTickets(ChunkPos center, int radius) {
+        this.field_217240_d.clearAreaPriorityTickets(center, radius);
+    }
+
+    public void clearPriorityTickets(ChunkPos coords) {
+        this.field_217240_d.clearPriorityTickets(coords);
+    }
     // Paper end
 
     @Nullable
@@ -510,6 +530,8 @@ public class ServerChunkProvider extends AbstractChunkProvider {
 
             if (!completablefuture.isDone()) { // Paper
                 // Paper start - async chunk io/loading
+                ChunkPos pair = new ChunkPos(x, z);
+                this.field_217240_d.markUrgent(pair);
                 this.field_73251_h.asyncChunkTaskManager.raisePriority(x, z, com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY);
                 com.destroystokyo.paper.io.chunk.ChunkTaskManager.pushChunkWait(this.field_73251_h, x, z);
                 // Paper end
@@ -518,6 +540,8 @@ public class ServerChunkProvider extends AbstractChunkProvider {
             this.field_217243_i.func_213161_c(completablefuture::isDone);
                 com.destroystokyo.paper.io.chunk.ChunkTaskManager.popChunkWait(); // Paper - async chunk debug
                 this.field_73251_h.timings.syncChunkLoad.stopTiming(); // Paper
+                this.field_217240_d.clearPriorityTickets(pair); // Paper
+                this.field_217240_d.clearUrgent(pair); // Paper
             } // Paper
             ichunkaccess = (IChunk) ((Either) completablefuture.join()).map((ichunkaccess1) -> {
                 return ichunkaccess1;
@@ -570,10 +594,12 @@ public class ServerChunkProvider extends AbstractChunkProvider {
         if (flag && !currentlyUnloading) {
             // CraftBukkit end
             this.field_217240_d.func_219356_a(TicketType.field_219494_g, chunkcoordintpair, l, chunkcoordintpair);
+            if (isUrgent) this.field_217240_d.markUrgent(chunkcoordintpair); // Paper
             if (this.func_217224_a(playerchunk, l)) {
                 IProfiler gameprofilerfiller = this.field_73251_h.func_217381_Z();
 
                 gameprofilerfiller.func_76320_a("chunkLoad");
+                field_217240_d.delayDistanceManagerTick = false; // Paper - ensure this is never false
                 this.func_217235_l();
                 playerchunk = this.func_217213_a(k);
                 gameprofilerfiller.func_76319_b();
@@ -582,8 +608,13 @@ public class ServerChunkProvider extends AbstractChunkProvider {
                 }
             }
         }
-
-        return this.func_217224_a(playerchunk, l) ? ChunkHolder.field_219307_b : playerchunk.func_219276_a(chunkstatus, this.field_217237_a);
+        // Paper start
+        CompletableFuture<Either<IChunk, ChunkHolder.IChunkLoadingError>> future = this.func_217224_a(playerchunk, l) ? ChunkHolder.field_219307_b : playerchunk.func_219276_a(chunkstatus, this.field_217237_a);
+        if (isUrgent) {
+            future.thenAccept(either -> this.field_217240_d.clearUrgent(chunkcoordintpair));
+        }
+        return future;
+        // Paper end
     }
 
     private boolean func_217224_a(@Nullable ChunkHolder p_217224_1_, int p_217224_2_) {
@@ -634,6 +665,7 @@ public class ServerChunkProvider extends AbstractChunkProvider {
     }
 
     public boolean func_217235_l() { // Paper - private -> public
+        if (field_217240_d.delayDistanceManagerTick) return false; // Paper
         boolean flag = this.field_217240_d.func_219353_a(this.field_217237_a);
         boolean flag1 = this.field_217237_a.func_219245_b();
 
diff --git a/src/main/java/net/minecraft/world/server/Ticket.java b/src/main/java/net/minecraft/world/server/Ticket.java
index 9c513e5fc0a9750cb6397673ca45caa54da2754b..8542d970d3e6c3bca69df002d6f9d13677820d18 100644
--- a/src/main/java/net/minecraft/world/server/Ticket.java
+++ b/src/main/java/net/minecraft/world/server/Ticket.java
@@ -8,6 +8,7 @@ public final class Ticket<T> implements Comparable<Ticket<?>> {
     private final int field_219481_b;
     public final T field_219482_c; public final T getObjectReason() { return this.field_219482_c; } // Paper - OBFHELPER
     private long field_219483_d; public final long getCreationTick() { return this.field_219483_d; } // Paper - OBFHELPER
+    public int priority = 0; // Paper
 
     protected Ticket(TicketType<T> tickettype, int i, T t0) {
         this.field_219480_a = tickettype;
@@ -56,6 +57,7 @@ public final class Ticket<T> implements Comparable<Ticket<?>> {
         return this.field_219481_b;
     }
 
+    public final void setCurrentTick(long i) { this.func_229861_a_(i); } // Paper - OBFHELPER
     protected void func_229861_a_(long p_229861_1_) {
         this.field_219483_d = p_229861_1_;
     }
diff --git a/src/main/java/net/minecraft/world/server/TicketManager.java b/src/main/java/net/minecraft/world/server/TicketManager.java
index 823663ef27e80345c0ce0d13ee8b7077520e63bc..c88a65e0f4d3900f9ef6dec57a1b686ffce4109c 100644
--- a/src/main/java/net/minecraft/world/server/TicketManager.java
+++ b/src/main/java/net/minecraft/world/server/TicketManager.java
@@ -22,8 +22,11 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
 import net.minecraft.entity.player.ServerPlayerEntity;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.SortedArraySet;
 import net.minecraft.util.concurrent.ITaskExecutor;
+import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
 import net.minecraft.util.math.SectionPos;
 import net.minecraft.world.chunk.Chunk;
@@ -32,6 +35,7 @@ import net.minecraft.world.chunk.ChunkStatus;
 import net.minecraft.world.chunk.ChunkTaskPriorityQueueSorter;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.AsyncCatcher; // Paper
 
 public abstract class TicketManager {
 
@@ -55,7 +59,7 @@ public abstract class TicketManager {
     private final ChunkTaskPriorityQueueSorter field_219384_l;
     private final ITaskExecutor<ChunkTaskPriorityQueueSorter.FunctionEntry<Runnable>> field_219385_m;
     private final ITaskExecutor<ChunkTaskPriorityQueueSorter.RunnableEntry> field_219386_n;
-    private final LongSet field_219387_o = new LongOpenHashSet();
+    private final LongSet field_219387_o = new LongOpenHashSet(); public final LongSet getOnPlayerTicketAddQueue() { return field_219387_o; } // Paper - OBFHELPER
     private final Executor field_219388_p;
     private long field_219389_q;
 
@@ -93,6 +97,7 @@ public abstract class TicketManager {
     }
 
     private static int func_229844_a_(SortedArraySet<Ticket<?>> p_229844_0_) {
+        AsyncCatcher.catchOp("ChunkMapDistance::getLowestTicketLevel"); // Paper
         return !p_229844_0_.isEmpty() ? ((Ticket) p_229844_0_.func_226178_b_()).func_219477_b() : ChunkManager.field_219249_a + 1;
     }
 
@@ -106,6 +111,7 @@ public abstract class TicketManager {
 
     public boolean func_219353_a(ChunkManager p_219353_1_) {
         //this.f.a(); // Paper - no longer used
+        AsyncCatcher.catchOp("DistanceManagerTick"); // Paper
         this.field_219382_j.func_215497_a();
         int i = Integer.MAX_VALUE - this.field_219378_f.func_215493_a(Integer.MAX_VALUE);
         boolean flag = i != 0;
@@ -116,11 +122,13 @@ public abstract class TicketManager {
 
         // Paper start
         if (!this.field_219383_k.isEmpty()) {
+            this.pollingPendingChunkUpdates = true; try {
             while(!this.field_219383_k.isEmpty()) {
                 ChunkHolder remove = this.field_219383_k.remove();
                 remove.isUpdateQueued = false;
                 remove.func_219291_a(p_219353_1_);
             }
+            } finally { this.pollingPendingChunkUpdates = false; }
             // Paper end
             return true;
         } else {
@@ -156,8 +164,10 @@ public abstract class TicketManager {
             return flag;
         }
     }
+    boolean pollingPendingChunkUpdates = false; // Paper
 
     private boolean addTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
+        AsyncCatcher.catchOp("ChunkMapDistance::addTicket"); // Paper
         SortedArraySet<Ticket<?>> arraysetsorted = this.func_229848_e_(i);
         int j = func_229844_a_(arraysetsorted);
         Ticket<?> ticket1 = (Ticket) arraysetsorted.func_226175_a_(ticket); // CraftBukkit - decompile error
@@ -171,7 +181,9 @@ public abstract class TicketManager {
     }
 
     private boolean removeTicket(long i, Ticket<?> ticket) { // CraftBukkit - void -> boolean
+        AsyncCatcher.catchOp("ChunkMapDistance::removeTicket"); // Paper
         SortedArraySet<Ticket<?>> arraysetsorted = this.func_229848_e_(i);
+        int oldLevel = func_229844_a_(arraysetsorted); // Paper
 
         boolean removed = false; // CraftBukkit
         if (arraysetsorted.remove(ticket)) {
@@ -182,7 +194,8 @@ public abstract class TicketManager {
             this.field_219377_e.remove(i);
         }
 
-        this.field_219378_f.func_215491_b(i, func_229844_a_(arraysetsorted), false);
+        int newLevel = func_229844_a_(arraysetsorted); // Paper
+        if (newLevel > oldLevel) this.field_219378_f.func_215491_b(i, newLevel, false); // Paper
         return removed; // CraftBukkit
     }
 
@@ -191,6 +204,135 @@ public abstract class TicketManager {
         this.addTicketAtLevel(p_219356_1_, p_219356_2_, p_219356_3_, p_219356_4_);
     }
 
+    // Paper start
+    public static final int PRIORITY_TICKET_LEVEL = ChunkManager.field_219249_a;
+    public static final int URGENT_PRIORITY = 29;
+    public boolean delayDistanceManagerTick = false;
+    public boolean markUrgent(ChunkPos coords) {
+        return addPriorityTicket(coords, TicketType.URGENT, URGENT_PRIORITY);
+    }
+    public boolean markHighPriority(ChunkPos coords, int priority) {
+        priority = Math.min(URGENT_PRIORITY - 1, Math.max(1, priority));
+        return addPriorityTicket(coords, TicketType.PRIORITY, priority);
+    }
+
+    public void markAreaHighPriority(ChunkPos center, int priority, int radius) {
+        delayDistanceManagerTick = true;
+        priority = Math.min(URGENT_PRIORITY - 1, Math.max(1, priority));
+        int finalPriority = priority;
+        MCUtil.getSpiralOutChunks(center.asPosition(), radius).forEach(coords -> {
+            addPriorityTicket(coords, TicketType.PRIORITY, finalPriority);
+        });
+        delayDistanceManagerTick = false;
+        chunkMap.field_219255_i.func_72863_F().func_217235_l();
+    }
+
+    public void clearAreaPriorityTickets(ChunkPos center, int radius) {
+        delayDistanceManagerTick = true;
+        MCUtil.getSpiralOutChunks(center.asPosition(), radius).forEach(coords -> {
+            this.removeTicket(coords.func_201841_a(), new Ticket<ChunkPos>(TicketType.PRIORITY, PRIORITY_TICKET_LEVEL, coords));
+        });
+        delayDistanceManagerTick = false;
+        chunkMap.field_219255_i.func_72863_F().func_217235_l();
+    }
+
+    private boolean hasPlayerTicket(ChunkPos coords, int level) {
+        SortedArraySet<Ticket<?>> tickets = this.field_219377_e.get(coords.func_201841_a());
+        if (tickets == null || tickets.isEmpty()) {
+            return false;
+        }
+        for (Ticket<?> ticket : tickets) {
+            if (ticket.func_219479_a() == TicketType.field_219490_c && ticket.getTicketLevel() == level) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private boolean addPriorityTicket(ChunkPos coords, TicketType<ChunkPos> ticketType, int priority) {
+        AsyncCatcher.catchOp("ChunkMapDistance::addPriorityTicket");
+        long pair = coords.func_201841_a();
+        ChunkHolder chunk = chunkMap.func_219220_a(pair);
+        boolean needsTicket = chunkMap.playerViewDistanceNoTickMap.getObjectsInRange(pair) != null && !hasPlayerTicket(coords, 33);
+
+        if (needsTicket) {
+            Ticket<?> ticket = new Ticket<>(TicketType.field_219490_c, 33, coords);
+            getOnPlayerTicketAddQueue().add(pair);
+            addTicket(pair, ticket);
+        }
+        if ((chunk != null && chunk.isFullChunkReady())) {
+            if (needsTicket) {
+                chunkMap.field_219255_i.func_72863_F().func_217235_l();
+            }
+            return needsTicket;
+        }
+
+        boolean success;
+        if (!(success = updatePriorityTicket(coords, ticketType, priority))) {
+            Ticket<ChunkPos> ticket = new Ticket<ChunkPos>(ticketType, PRIORITY_TICKET_LEVEL, coords);
+            ticket.priority = priority;
+            success = this.addTicket(pair, ticket);
+        } else {
+            if (chunk == null) {
+                chunk = chunkMap.func_219220_a(pair);
+            }
+            chunkMap.queueHolderUpdate(chunk);
+        }
+
+        //chunkMap.world.getWorld().spawnParticle(priority <= 15 ? org.bukkit.Particle.EXPLOSION_HUGE : org.bukkit.Particle.EXPLOSION_NORMAL, chunkMap.world.getWorld().getPlayers(), null, coords.x << 4, 70, coords.z << 4, 2, 0, 0, 0, 1, null, true);
+
+        chunkMap.field_219255_i.func_72863_F().func_217235_l();
+
+        return success;
+    }
+
+    private boolean updatePriorityTicket(ChunkPos coords, TicketType<ChunkPos> type, int priority) {
+        SortedArraySet<Ticket<?>> tickets = this.field_219377_e.get(coords.func_201841_a());
+        if (tickets == null) {
+            return false;
+        }
+        for (Ticket<?> ticket : tickets) {
+            if (ticket.func_219479_a() == type) {
+                // We only support increasing, not decreasing, too complicated
+                ticket.setCurrentTick(this.field_219389_q);
+                ticket.priority = Math.max(ticket.priority, priority);
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public int getChunkPriority(ChunkPos coords) {
+        AsyncCatcher.catchOp("ChunkMapDistance::getChunkPriority");
+        SortedArraySet<Ticket<?>> tickets = this.field_219377_e.get(coords.func_201841_a());
+        if (tickets == null) {
+            return 0;
+        }
+        for (Ticket<?> ticket : tickets) {
+            if (ticket.func_219479_a() == TicketType.URGENT) {
+                return URGENT_PRIORITY;
+            }
+        }
+        for (Ticket<?> ticket : tickets) {
+            if (ticket.func_219479_a() == TicketType.PRIORITY && ticket.priority > 0) {
+                return ticket.priority;
+            }
+        }
+        return 0;
+    }
+
+    public void clearPriorityTickets(ChunkPos coords) {
+        AsyncCatcher.catchOp("ChunkMapDistance::clearPriority");
+        this.removeTicket(coords.func_201841_a(), new Ticket<ChunkPos>(TicketType.PRIORITY, PRIORITY_TICKET_LEVEL, coords));
+    }
+
+    public void clearUrgent(ChunkPos coords) {
+        AsyncCatcher.catchOp("ChunkMapDistance::clearUrgent");
+        this.removeTicket(coords.func_201841_a(), new Ticket<ChunkPos>(TicketType.URGENT, PRIORITY_TICKET_LEVEL, coords));
+    }
+    // Paper end
     public <T> boolean addTicketAtLevel(TicketType<T> ticketType, ChunkPos chunkcoordintpair, int level, T identifier) {
         return this.addTicket(chunkcoordintpair.func_201841_a(), new Ticket<>(ticketType, level, identifier));
         // CraftBukkit end
@@ -390,27 +532,50 @@ public abstract class TicketManager {
 
         private void func_215504_a(long p_215504_1_, int p_215504_2_, boolean p_215504_3_, boolean p_215504_4_) {
             if (p_215504_3_ != p_215504_4_) {
-                Ticket<?> ticket = new Ticket<>(TicketType.field_219490_c, 33, new ChunkPos(p_215504_1_)); // Paper - no-tick view distance
+                ChunkPos coords = new ChunkPos(p_215504_1_); // Paper
+                Ticket<?> ticket = new Ticket<>(TicketType.field_219490_c, 33, coords); // Paper - no-tick view distance
 
                 if (p_215504_4_) {
-                    TicketManager.this.field_219385_m.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219069_a(() -> {
+                    scheduleChunkLoad(p_215504_1_, MinecraftServer.currentTick, p_215504_2_, (priority) -> { // Paper - smarter ticket delay based on frustum and distance
+                    // Paper start - recheck its still valid if not cancel
+                    if (!isChunkInRange(p_215504_1_)) {
+                        TicketManager.this.field_219386_n.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219073_a(() -> {
+                            TicketManager.this.field_219388_p.execute(() -> {
+                                TicketManager.this.removeTicket(p_215504_1_, ticket);
+                                TicketManager.this.clearPriorityTickets(coords);
+                            });
+                        }, p_215504_1_, false));
+                        return;
+                    }
+                    // abort early if we got a ticket already
+                    if (hasPlayerTicket(coords, 33)) return;
+                    // skip player ticket throttle for near chunks
+                    if (priority <= 3) {
+                        TicketManager.this.addTicket(p_215504_1_, ticket);
+                        TicketManager.this.field_219387_o.add(p_215504_1_);
+                        return;
+                    }
+                    // Paper end
+                    TicketManager.this.field_219385_m.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219069_a(() -> { // CraftBukkit - decompile error
                         TicketManager.this.field_219388_p.execute(() -> {
-                            if (this.func_215505_c(this.func_215471_c(p_215504_1_))) {
+                            if (isChunkInRange(p_215504_1_)) { if (!hasPlayerTicket(coords, 33)) { // Paper - high priority might of already added it
                                 TicketManager.this.addTicket(p_215504_1_, ticket);
                                 TicketManager.this.field_219387_o.add(p_215504_1_);
-                            } else {
-                                TicketManager.this.field_219386_n.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219073_a(() -> {
+                            }} else { // Paper
+                                TicketManager.this.field_219386_n.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219073_a(() -> { // CraftBukkit - decompile error
                                 }, p_215504_1_, false));
                             }
 
                         });
                     }, p_215504_1_, () -> {
-                        return p_215504_2_;
+                        return Math.min(ChunkManager.field_219249_a, priority); // Paper
                     }));
+                    }); // Paper
                 } else {
                     TicketManager.this.field_219386_n.func_212871_a_(ChunkTaskPriorityQueueSorter.func_219073_a(() -> {
                         TicketManager.this.field_219388_p.execute(() -> {
                             TicketManager.this.removeTicket(p_215504_1_, ticket);
+                            TicketManager.this.clearPriorityTickets(coords); // Paper
                         });
                     }, p_215504_1_, true));
                 }
@@ -418,6 +583,101 @@ public abstract class TicketManager {
 
         }
 
+        // Paper start - smart scheduling of player tickets
+        private boolean isChunkInRange(long i) {
+            return this.isLoadedChunkLevel(this.getChunkLevel(i));
+        }
+        public void scheduleChunkLoad(long i, long startTick, int initialDistance, java.util.function.Consumer<Integer> task) {
+            long elapsed = MinecraftServer.currentTick - startTick;
+            ChunkPos chunkPos = new ChunkPos(i);
+            ChunkHolder updatingChunk = chunkMap.func_219220_a(i);
+            if ((updatingChunk != null && updatingChunk.isFullChunkReady()) || !isChunkInRange(i) || getChunkPriority(chunkPos) > 0) { // Copied from above
+                // no longer needed
+                task.accept(1);
+                return;
+            }
+
+            int desireDelay = 0;
+            double minDist = Double.MAX_VALUE;
+            com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayerEntity> players = chunkMap.playerViewDistanceNoTickMap.getObjectsInRange(i);
+            if (elapsed == 0 && initialDistance <= 4) {
+                // Aim for no delay on initial 6 chunk radius tickets save on performance of the below code to only > 6
+                minDist = initialDistance;
+            } else if (players != null) {
+                Object[] backingSet = players.getBackingSet();
+
+                BlockPos blockPos = chunkPos.asPosition();
+
+                boolean isFront = false;
+                BlockPos.Mutable pos = new BlockPos.Mutable();
+                for (int index = 0, len = backingSet.length; index < len; ++index) {
+                    if (!(backingSet[index] instanceof ServerPlayerEntity)) {
+                        continue;
+                    }
+                    ServerPlayerEntity player = (ServerPlayerEntity) backingSet[index];
+
+                    ChunkPos pointInFront = player.getChunkInFront(5);
+                    pos.setValues(pointInFront.field_77276_a << 4, 0, pointInFront.field_77275_b << 4);
+                    double frontDist = MCUtil.distanceSq(pos, blockPos);
+
+                    pos.setValues(player.func_226277_ct_(), 0, player.func_226281_cx_());
+                    double center = MCUtil.distanceSq(pos, blockPos);
+
+                    double dist = Math.min(frontDist, center);
+                    if (!isFront) {
+                        ChunkPos pointInBack = player.getChunkInFront(-7);
+                        pos.setValues(pointInBack.field_77276_a << 4, 0, pointInBack.field_77275_b << 4);
+                        double backDist = MCUtil.distanceSq(pos, blockPos);
+                        if (frontDist < backDist) {
+                            isFront = true;
+                        }
+                    }
+                    if (dist < minDist) {
+                        minDist = dist;
+                    }
+                }
+                if (minDist == Double.MAX_VALUE) {
+                    minDist = 15;
+                } else {
+                    minDist = Math.sqrt(minDist) / 16;
+                }
+                if (minDist > 4) {
+                    int desiredTimeDelayMax = isFront ?
+                        (minDist < 10 ? 7 : 15) : // Front
+                        (minDist < 10 ? 15 : 45); // Back
+                    desireDelay += (desiredTimeDelayMax * 20) * (minDist / 32);
+                }
+            } else {
+                minDist = initialDistance;
+                desireDelay = 1;
+            }
+            long delay = desireDelay - elapsed;
+            if (delay <= 0 && minDist > 4 && minDist < Double.MAX_VALUE) {
+                boolean hasAnyNeighbor = false;
+                for (int x = -1; x <= 1; x++) {
+                    for (int z = -1; z <= 1; z++) {
+                        if (x == 0 && z == 0) continue;
+                        long pair = ChunkPos.func_77272_a(chunkPos.field_77276_a + x, chunkPos.field_77275_b + z);
+                        ChunkHolder neighbor = chunkMap.func_219220_a(pair);
+                        ChunkStatus current = neighbor != null ? neighbor.getChunkHolderStatus() : null;
+                        if (current != null && current.isAtLeastStatus(ChunkStatus.field_222614_j)) {
+                            hasAnyNeighbor = true;
+                        }
+                    }
+                }
+                if (!hasAnyNeighbor) {
+                    delay += 20;
+                }
+            }
+            if (delay <= 0) {
+                task.accept((int) minDist);
+            } else {
+                int taskDelay = (int) Math.min(delay, minDist >= 10 ? 40 : (minDist < 6 ? 5 : 20));
+                MCUtil.scheduleTask(taskDelay, () -> scheduleChunkLoad(i, startTick, initialDistance, task), "Player Ticket Delayer");
+            }
+        }
+        // Paper end
+
         @Override
         public void func_215497_a() {
             super.func_215497_a();
@@ -449,6 +709,7 @@ public abstract class TicketManager {
 
         }
 
+        private boolean isLoadedChunkLevel(int i) { return func_215505_c(i); } // Paper - OBFHELPER
         private boolean func_215505_c(int p_215505_1_) {
             return p_215505_1_ <= this.field_215512_e - 2;
         }
@@ -465,6 +726,7 @@ public abstract class TicketManager {
             this.field_215498_a.defaultReturnValue((byte) (i + 2));
         }
 
+        protected final int getChunkLevel(long i) { return func_215471_c(i); } // Paper - OBFHELPER
         @Override
         protected int func_215471_c(long p_215471_1_) {
             return this.field_215498_a.get(p_215471_1_);
diff --git a/src/main/java/net/minecraft/world/server/TicketType.java b/src/main/java/net/minecraft/world/server/TicketType.java
index df148625acfd1f9b803bdc2082d4f27354bc8203..ce7145f48b4f3e907c413825c114aeb2bfddbd9d 100644
--- a/src/main/java/net/minecraft/world/server/TicketType.java
+++ b/src/main/java/net/minecraft/world/server/TicketType.java
@@ -28,6 +28,8 @@ public class TicketType<T> {
     public static final TicketType<org.bukkit.plugin.Plugin> PLUGIN_TICKET = func_219484_a("plugin_ticket", (plugin1, plugin2) -> plugin1.getClass().getName().compareTo(plugin2.getClass().getName())); // CraftBukkit
     public static final TicketType<Long> FUTURE_AWAIT = func_219484_a("future_await", Long::compareTo); // Paper
     public static final TicketType<Long> ASYNC_LOAD = func_219484_a("async_load", Long::compareTo); // Paper
+    public static final TicketType<ChunkPos> PRIORITY = func_223183_a("priority", Comparator.comparingLong(ChunkPos::func_201841_a), 300); // Paper
+    public static final TicketType<ChunkPos> URGENT = func_223183_a("urgent", Comparator.comparingLong(ChunkPos::func_201841_a), 300); // Paper
 
     public static <T> TicketType<T> func_219484_a(String p_219484_0_, Comparator<T> p_219484_1_) {
         return new TicketType<>(p_219484_0_, p_219484_1_, 0L);
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index c9f3fc917b1afb6c6ffa21551a02bd8bcf2e46ed..03975045e9e6715cadaed1b9d9040863c324213c 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -2502,6 +2502,10 @@ public class CraftWorld implements World {
             return future;
         }
 
+        if (!urgent) {
+            // if not urgent, at least use a slightly boosted priority
+            world.func_72863_F().markHighPriority(new ChunkPos(x, z), 1);
+        }
         return this.world.func_72863_F().getChunkAtAsynchronously(x, z, gen, urgent).thenComposeAsync((either) -> {
             net.minecraft.world.chunk.Chunk chunk = (net.minecraft.world.chunk.Chunk) either.left().orElse(null);
             return CompletableFuture.completedFuture(chunk == null ? null : chunk.getBukkitChunk());
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index ac974ef5f3bfd521f40ce768e01e18704b91ac4c..607359b06e34d89b53d624434af09856d43a5fdb 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -765,6 +765,14 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         throw new UnsupportedOperationException("Cannot set rotation of players. Consider teleporting instead.");
     }
 
+    // Paper start
+    @Override
+    public java.util.concurrent.CompletableFuture<Boolean> teleportAsync(Location loc, @javax.annotation.Nonnull PlayerTeleportEvent.TeleportCause cause) {
+        ((CraftWorld)loc.getWorld()).getHandle().func_72863_F().markAreaHighPriority(new net.minecraft.util.math.ChunkPos(net.minecraft.util.math.MathHelper.func_76128_c(loc.getX()) >> 4, net.minecraft.util.math.MathHelper.func_76128_c(loc.getZ()) >> 4), 28, 3); // Paper - load area high priority
+        return super.teleportAsync(loc, cause);
+    }
+    // Paper end
+
     @Override
     public boolean teleport(Location location, PlayerTeleportEvent.TeleportCause cause) {
         Preconditions.checkArgument(location != null, "location");
